{
  "files": [
    {
      "name": "Adoption.gs",
      "type": "server_js",
      "source": "/**\r\n * Adoption.gs - Adoption Tracking & Compliance Reporting\r\n * Tracks team engagement with the bot and generates compliance reports\r\n */\r\n\r\n/**\r\n * Compute daily adoption metrics for all team members\r\n * Run this as an end-of-day trigger (after EOD summary)\r\n */\r\nfunction computeDailyAdoptionMetrics() {\r\n  var allMembers = getCachedWorkingEmployees();\r\n  var config = getConfig();\r\n  // Filter to tracked users only for adoption metrics\r\n  var teamMembers = allMembers.filter(function (m) {\r\n    var fullMember = config.team_members.find(function (tm) { return tm.email === m.email; });\r\n    return !fullMember || (fullMember.tracking_mode || 'tracked') === 'tracked';\r\n  });\r\n  var today = new Date();\r\n  var dateStr = Utilities.formatDate(today, 'America/Chicago', 'yyyy-MM-dd');\r\n  var projectId = getProjectId();\r\n\r\n  // Get today's prompts\r\n  var promptQuery = 'SELECT user_email, prompt_type, response_received, response_latency_minutes ' +\r\n    'FROM `' + projectId + '.' + DATASET_ID + '.v_prompt_log` ' +\r\n    'WHERE DATE(sent_at, \"America/Chicago\") = \"' + dateStr + '\"';\r\n  var prompts = runBigQueryQuery(promptQuery);\r\n\r\n  // Get today's check-ins\r\n  var todayCheckIns = getTodayCheckIns();\r\n  var checkinMap = {};\r\n  todayCheckIns.forEach(function (c) { checkinMap[c.user_email] = c; });\r\n\r\n  // Get today's EODs\r\n  var todayEods = getTodayEodReports();\r\n  var eodMap = {};\r\n  todayEods.forEach(function (e) { eodMap[e.user_email] = e; });\r\n\r\n  // Get today's task actions (button clicks)\r\n  var actionQuery = 'SELECT user_email, COUNT(*) as action_count ' +\r\n    'FROM `' + projectId + '.' + DATASET_ID + '.clickup_task_actions` ' +\r\n    'WHERE DATE(timestamp, \"America/Chicago\") = \"' + dateStr + '\" ' +\r\n    'GROUP BY user_email';\r\n  var actions = runBigQueryQuery(actionQuery);\r\n  var actionMap = {};\r\n  actions.forEach(function (a) { actionMap[a.user_email] = parseInt(a.action_count); });\r\n\r\n  // Build prompt maps\r\n  var promptMap = {};\r\n  prompts.forEach(function (p) {\r\n    if (!promptMap[p.user_email]) promptMap[p.user_email] = {};\r\n    var type = p.prompt_type;\r\n    if (type === 'CHECKIN' || type === 'CHECKIN_FOLLOWUP') {\r\n      promptMap[p.user_email].checkin_prompted = true;\r\n      if (p.response_received === true || p.response_received === 'true') {\r\n        promptMap[p.user_email].checkin_responded = true;\r\n        var latency = parseFloat(p.response_latency_minutes);\r\n        if (!isNaN(latency)) {\r\n          promptMap[p.user_email].checkin_latency = latency;\r\n        }\r\n      }\r\n    }\r\n    if (type === 'EOD' || type === 'EOD_FOLLOWUP') {\r\n      promptMap[p.user_email].eod_prompted = true;\r\n      if (p.response_received === true || p.response_received === 'true') {\r\n        promptMap[p.user_email].eod_responded = true;\r\n        var eodLatency = parseFloat(p.response_latency_minutes);\r\n        if (!isNaN(eodLatency)) {\r\n          promptMap[p.user_email].eod_latency = eodLatency;\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  var rows = [];\r\n\r\n  teamMembers.forEach(function (member) {\r\n    var email = member.email;\r\n    var pm = promptMap[email] || {};\r\n    var checkin = checkinMap[email];\r\n    var eod = eodMap[email];\r\n    var buttonCount = actionMap[email] || 0;\r\n\r\n    // EOD quality signals\r\n    var eodWordCount = null;\r\n    var eodHoursIncluded = false;\r\n    var eodBlockersIncluded = false;\r\n    var eodTomorrowIncluded = false;\r\n\r\n    if (eod) {\r\n      var rawText = eod.raw_response || eod.tasks_completed || '';\r\n      eodWordCount = rawText.split(/\\s+/).filter(function (w) { return w.length > 0; }).length;\r\n      eodHoursIncluded = eod.hours_worked !== null && eod.hours_worked !== undefined && eod.hours_worked !== '';\r\n      eodBlockersIncluded = eod.blockers !== null && eod.blockers !== undefined && eod.blockers !== '';\r\n      eodTomorrowIncluded = eod.tomorrow_priority !== null && eod.tomorrow_priority !== undefined && eod.tomorrow_priority !== '';\r\n    }\r\n\r\n    rows.push({\r\n      metric_id: Utilities.getUuid(),\r\n      metric_date: dateStr,\r\n      user_email: email,\r\n      checkin_prompted: !!pm.checkin_prompted,\r\n      checkin_responded: !!pm.checkin_responded || !!checkin,\r\n      checkin_latency_minutes: pm.checkin_latency || null,\r\n      checkin_is_late: checkin ? (checkin.is_late === true || checkin.is_late === 'true') : false,\r\n      eod_prompted: !!pm.eod_prompted,\r\n      eod_responded: !!pm.eod_responded || !!eod,\r\n      eod_latency_minutes: pm.eod_latency || null,\r\n      eod_word_count: eodWordCount,\r\n      eod_hours_included: eodHoursIncluded,\r\n      eod_blockers_included: eodBlockersIncluded,\r\n      eod_tomorrow_included: eodTomorrowIncluded,\r\n      used_task_buttons: buttonCount > 0,\r\n      button_actions_count: buttonCount,\r\n      created_at: new Date().toISOString()\r\n    });\r\n  });\r\n\r\n  if (rows.length > 0) {\r\n    insertIntoBigQuery('daily_adoption_metrics', rows);\r\n  }\r\n\r\n  console.log('Computed daily adoption metrics for ' + rows.length + ' members');\r\n  return rows;\r\n}\r\n\r\n/**\r\n * Compute weekly adoption scores\r\n * Run every Friday after EOD summary\r\n */\r\nfunction computeWeeklyAdoptionScores() {\r\n  var projectId = getProjectId();\r\n  var today = new Date();\r\n  var weekStart = new Date(today);\r\n  weekStart.setDate(today.getDate() - today.getDay() + 1); // Monday\r\n  var weekStartStr = Utilities.formatDate(weekStart, 'America/Chicago', 'yyyy-MM-dd');\r\n  var todayStr = Utilities.formatDate(today, 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  var query = 'SELECT ' +\r\n    'user_email, ' +\r\n    'COUNTIF(checkin_prompted) as days_prompted_checkin, ' +\r\n    'COUNTIF(checkin_responded) as days_responded_checkin, ' +\r\n    'AVG(CASE WHEN checkin_latency_minutes IS NOT NULL THEN checkin_latency_minutes END) as avg_checkin_latency, ' +\r\n    'COUNTIF(eod_prompted) as days_prompted_eod, ' +\r\n    'COUNTIF(eod_responded) as days_responded_eod, ' +\r\n    'AVG(CASE WHEN eod_latency_minutes IS NOT NULL THEN eod_latency_minutes END) as avg_eod_latency, ' +\r\n    'AVG(CASE WHEN eod_word_count IS NOT NULL THEN eod_word_count END) as avg_eod_word_count, ' +\r\n    'COUNTIF(eod_hours_included) as days_hours_included, ' +\r\n    'COUNTIF(eod_blockers_included) as days_blockers_included, ' +\r\n    'COUNTIF(eod_tomorrow_included) as days_tomorrow_included, ' +\r\n    'COUNTIF(used_task_buttons) as days_used_buttons, ' +\r\n    'SUM(button_actions_count) as total_button_actions ' +\r\n    'FROM `' + projectId + '.' + DATASET_ID + '.daily_adoption_metrics` ' +\r\n    'WHERE metric_date BETWEEN \"' + weekStartStr + '\" AND \"' + todayStr + '\" ' +\r\n    'GROUP BY user_email';\r\n\r\n  var results = runBigQueryQuery(query);\r\n  var rows = [];\r\n\r\n  results.forEach(function (r) {\r\n    var daysPromptedCheckin = parseInt(r.days_prompted_checkin) || 0;\r\n    var daysRespondedCheckin = parseInt(r.days_responded_checkin) || 0;\r\n    var daysPromptedEod = parseInt(r.days_prompted_eod) || 0;\r\n    var daysRespondedEod = parseInt(r.days_responded_eod) || 0;\r\n    var avgCheckinLatency = parseFloat(r.avg_checkin_latency) || 0;\r\n    var avgEodLatency = parseFloat(r.avg_eod_latency) || 0;\r\n    var avgWordCount = parseFloat(r.avg_eod_word_count) || 0;\r\n    var daysHoursIncluded = parseInt(r.days_hours_included) || 0;\r\n    var daysTomorrowIncluded = parseInt(r.days_tomorrow_included) || 0;\r\n    var daysUsedButtons = parseInt(r.days_used_buttons) || 0;\r\n\r\n    // Response rate: 40% weight\r\n    var checkinRate = daysPromptedCheckin > 0 ? daysRespondedCheckin / daysPromptedCheckin : 0;\r\n    var eodRate = daysPromptedEod > 0 ? daysRespondedEod / daysPromptedEod : 0;\r\n    var responseScore = ((checkinRate + eodRate) / 2) * 40;\r\n\r\n    // Timeliness: 25% weight\r\n    var avgLatency = (avgCheckinLatency + avgEodLatency) / 2;\r\n    var timelinessScore = 0;\r\n    if (avgLatency <= 5) timelinessScore = 25;\r\n    else if (avgLatency <= 10) timelinessScore = 20;\r\n    else if (avgLatency <= 20) timelinessScore = 12.5;\r\n    else timelinessScore = 0;\r\n\r\n    // Response quality: 20% weight\r\n    var daysWithEod = daysRespondedEod || 1;\r\n    var hoursRate = daysHoursIncluded / daysWithEod;\r\n    var tomorrowRate = daysTomorrowIncluded / daysWithEod;\r\n    var wordCountAdequacy = avgWordCount >= 20 ? 1 : (avgWordCount >= 10 ? 0.5 : 0);\r\n    var qualityScore = ((hoursRate + tomorrowRate + wordCountAdequacy) / 3) * 20;\r\n\r\n    // Feature adoption: 15% weight\r\n    var daysTotal = Math.max(daysPromptedCheckin, daysPromptedEod, 1);\r\n    var buttonAdoptionRate = daysUsedButtons / daysTotal;\r\n    var featureScore = buttonAdoptionRate * 15;\r\n\r\n    var totalScore = Math.round(responseScore + timelinessScore + qualityScore + featureScore);\r\n\r\n    rows.push({\r\n      score_id: Utilities.getUuid(),\r\n      week_start: weekStartStr,\r\n      week_end: todayStr,\r\n      user_email: r.user_email,\r\n      checkin_response_rate: Math.round(checkinRate * 100),\r\n      eod_response_rate: Math.round(eodRate * 100),\r\n      avg_checkin_latency_minutes: Math.round(avgCheckinLatency * 10) / 10,\r\n      avg_eod_latency_minutes: Math.round(avgEodLatency * 10) / 10,\r\n      avg_eod_word_count: Math.round(avgWordCount),\r\n      hours_inclusion_rate: Math.round(hoursRate * 100),\r\n      tomorrow_inclusion_rate: Math.round(tomorrowRate * 100),\r\n      button_adoption_rate: Math.round(buttonAdoptionRate * 100),\r\n      adoption_score: totalScore,\r\n      created_at: new Date().toISOString()\r\n    });\r\n  });\r\n\r\n  if (rows.length > 0) {\r\n    insertIntoBigQuery('weekly_adoption_scores', rows);\r\n  }\r\n\r\n  console.log('Computed weekly adoption scores for ' + rows.length + ' members');\r\n  return rows;\r\n}\r\n\r\n/**\r\n * Generate and send weekly adoption report\r\n * Called by triggerWeeklyAdoptionReport (Friday after EOD)\r\n */\r\nfunction generateWeeklyAdoptionReport() {\r\n  console.log('Generating weekly adoption report...');\r\n\r\n  // Compute fresh scores\r\n  var scores = computeWeeklyAdoptionScores();\r\n\r\n  if (!scores || scores.length === 0) {\r\n    console.log('No adoption data to report');\r\n    return;\r\n  }\r\n\r\n  // Sort by adoption score ascending (worst first)\r\n  scores.sort(function (a, b) { return a.adoption_score - b.adoption_score; });\r\n\r\n  var teamMembers = getCachedWorkingEmployees();\r\n  var nameMap = {};\r\n  teamMembers.forEach(function (m) {\r\n    nameMap[m.email] = m.name || m.email.split('@')[0];\r\n  });\r\n\r\n  // Team averages\r\n  var totalScore = 0;\r\n  var totalCheckinRate = 0;\r\n  var totalEodRate = 0;\r\n  var totalLatency = 0;\r\n  scores.forEach(function (s) {\r\n    totalScore += s.adoption_score;\r\n    totalCheckinRate += s.checkin_response_rate;\r\n    totalEodRate += s.eod_response_rate;\r\n    totalLatency += s.avg_checkin_latency_minutes;\r\n  });\r\n  var count = scores.length;\r\n  var avgScore = Math.round(totalScore / count);\r\n  var avgCheckin = Math.round(totalCheckinRate / count);\r\n  var avgEod = Math.round(totalEodRate / count);\r\n  var avgLatency = Math.round(totalLatency / count * 10) / 10;\r\n\r\n  // Build message\r\n  var message = 'üìä *Weekly Adoption Report*\\n\\n';\r\n  message += '*Team Overview:*\\n';\r\n  message += 'Avg Adoption Score: ' + avgScore + '/100\\n';\r\n  message += 'Check-in Rate: ' + avgCheckin + '% | EOD Rate: ' + avgEod + '%\\n';\r\n  message += 'Avg Response Time: ' + avgLatency + ' min\\n\\n';\r\n\r\n  // Flag anyone below 70\r\n  var flagged = scores.filter(function (s) { return s.adoption_score < 70; });\r\n  if (flagged.length > 0) {\r\n    message += 'üö© *Needs Attention (Score < 70):*\\n';\r\n    flagged.forEach(function (s) {\r\n      var name = nameMap[s.user_email] || s.user_email;\r\n      var gaps = [];\r\n      if (s.checkin_response_rate < 80) gaps.push('check-in ' + s.checkin_response_rate + '%');\r\n      if (s.eod_response_rate < 80) gaps.push('EOD ' + s.eod_response_rate + '%');\r\n      if (s.hours_inclusion_rate < 50) gaps.push('no hours');\r\n      if (s.button_adoption_rate < 20) gaps.push('ignores task buttons');\r\n      if (s.avg_checkin_latency_minutes > 20) gaps.push('slow response ' + s.avg_checkin_latency_minutes + 'min');\r\n      message += '  ' + name + ': ' + s.adoption_score + '/100';\r\n      if (gaps.length > 0) message += ' (' + gaps.join(', ') + ')';\r\n      message += '\\n';\r\n    });\r\n    message += '\\n';\r\n  }\r\n\r\n  // Top performers\r\n  var topPerformers = scores.filter(function (s) { return s.adoption_score >= 90; });\r\n  if (topPerformers.length > 0) {\r\n    message += '‚≠ê *Top Performers (Score 90+):*\\n';\r\n    topPerformers.reverse().forEach(function (s) {\r\n      var name = nameMap[s.user_email] || s.user_email;\r\n      message += '  ' + name + ': ' + s.adoption_score + '/100\\n';\r\n    });\r\n    message += '\\n';\r\n  }\r\n\r\n  // Full breakdown sorted by score descending\r\n  message += '*Full Team Breakdown:*\\n';\r\n  scores.reverse().forEach(function (s) {\r\n    var name = nameMap[s.user_email] || s.user_email;\r\n    message += '  ' + name + ': ' + s.adoption_score + ' | CI:' + s.checkin_response_rate + '% EOD:' + s.eod_response_rate + '% Btns:' + s.button_adoption_rate + '%\\n';\r\n  });\r\n\r\n  // Send to manager and escalation recipients\r\n  var recipients = getReportRecipients('adoption_report');\r\n  if (!recipients || recipients.length === 0) {\r\n    var config = getConfig();\r\n    recipients = [config.settings.manager_email];\r\n  }\r\n\r\n  recipients.forEach(function (r) {\r\n    sendDirectMessage(r, message);\r\n  });\r\n\r\n  logSystemEvent('ADOPTION_REPORT', 'SENT', { avg_score: avgScore, team_size: count });\r\n  console.log('Weekly adoption report sent to ' + recipients.length + ' recipients');\r\n}\r\n\r\n/**\r\n * Midweek compliance check (Wednesday)\r\n * Alerts manager if anyone has missed 2+ check-ins or EODs this week\r\n */\r\nfunction midweekComplianceCheck() {\r\n  var projectId = getProjectId();\r\n  var today = new Date();\r\n  var weekStart = new Date(today);\r\n  weekStart.setDate(today.getDate() - today.getDay() + 1); // Monday\r\n  var weekStartStr = Utilities.formatDate(weekStart, 'America/Chicago', 'yyyy-MM-dd');\r\n  var todayStr = Utilities.formatDate(today, 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  // Count workdays so far this week\r\n  var dayOfWeek = today.getDay(); // 0=Sun, 1=Mon, ..., 3=Wed\r\n  var workdaysSoFar = dayOfWeek;\r\n\r\n  if (workdaysSoFar < 2) return; // Not enough data before Tuesday\r\n\r\n  var query = 'SELECT user_email, ' +\r\n    'COUNTIF(checkin_responded) as checkins, ' +\r\n    'COUNTIF(eod_responded) as eods, ' +\r\n    'COUNT(*) as days_tracked ' +\r\n    'FROM `' + projectId + '.' + DATASET_ID + '.daily_adoption_metrics` ' +\r\n    'WHERE metric_date BETWEEN \"' + weekStartStr + '\" AND \"' + todayStr + '\" ' +\r\n    'GROUP BY user_email';\r\n\r\n  var results = runBigQueryQuery(query);\r\n  var allMembers = getCachedWorkingEmployees();\r\n  var config2 = getConfig();\r\n  // Filter to tracked users only\r\n  var teamMembers = allMembers.filter(function (m) {\r\n    var fullMember = config2.team_members.find(function (tm) { return tm.email === m.email; });\r\n    return !fullMember || (fullMember.tracking_mode || 'tracked') === 'tracked';\r\n  });\r\n  var nameMap = {};\r\n  teamMembers.forEach(function (m) { nameMap[m.email] = m.name || m.email.split('@')[0]; });\r\n\r\n  var flagged = [];\r\n  results.forEach(function (r) {\r\n    if (!nameMap[r.user_email]) return; // Skip not_tracked or unknown users\r\n    var daysTracked = parseInt(r.days_tracked) || 0;\r\n    var checkins = parseInt(r.checkins) || 0;\r\n    var eods = parseInt(r.eods) || 0;\r\n    var missedCheckins = daysTracked - checkins;\r\n    var missedEods = daysTracked - eods;\r\n\r\n    if (missedCheckins >= 2 || missedEods >= 2) {\r\n      var name = nameMap[r.user_email] || r.user_email;\r\n      var issues = [];\r\n      if (missedCheckins >= 2) issues.push(missedCheckins + ' missed check-ins');\r\n      if (missedEods >= 2) issues.push(missedEods + ' missed EODs');\r\n      flagged.push(name + ': ' + issues.join(', '));\r\n    }\r\n  });\r\n\r\n  // Also flag anyone not in the metrics at all\r\n  var trackedEmails = {};\r\n  results.forEach(function (r) { trackedEmails[r.user_email] = true; });\r\n  teamMembers.forEach(function (m) {\r\n    if (!trackedEmails[m.email]) {\r\n      flagged.push((m.name || m.email.split('@')[0]) + ': no activity recorded this week');\r\n    }\r\n  });\r\n\r\n  if (flagged.length > 0) {\r\n    var message = '‚ö†Ô∏è *Midweek Compliance Alert*\\n\\n' +\r\n      'The following team members have compliance gaps this week:\\n\\n';\r\n    flagged.forEach(function (f) {\r\n      message += '  ' + f + '\\n';\r\n    });\r\n    message += '\\nConsider following up before Friday.';\r\n\r\n    var config = getConfig();\r\n    sendDirectMessage(config.settings.manager_email, message);\r\n    logSystemEvent('MIDWEEK_COMPLIANCE', 'ALERT', { flagged_count: flagged.length });\r\n  }\r\n\r\n  console.log('Midweek compliance check: ' + flagged.length + ' flagged');\r\n}\r\n"
    },
    {
      "name": "Alerts.gs",
      "type": "server_js",
      "source": "/**\r\n * Alerts.gs - Error Alerting & Notifications\r\n * Sends critical error alerts to the manager\r\n */\r\n\r\n/**\r\n * Send a critical error alert to the manager\r\n * Use this for integration failures, not routine warnings\r\n */\r\nfunction sendErrorAlert(source, errorMessage, details) {\r\n  try {\r\n    var config = getConfig();\r\n    var managerEmail = config.settings.manager_email;\r\n    if (!managerEmail) return;\r\n\r\n    var message = 'üö® *Bot Error Alert*\\n\\n' +\r\n      '*Source:* ' + source + '\\n' +\r\n      '*Error:* ' + errorMessage + '\\n';\r\n\r\n    if (details) {\r\n      message += '*Details:* ' + (typeof details === 'string' ? details : JSON.stringify(details)) + '\\n';\r\n    }\r\n\r\n    message += '*Time:* ' + new Date().toISOString();\r\n\r\n    sendDirectMessage(managerEmail, message);\r\n  } catch (e) {\r\n    // Don't let alert failures cause cascading errors\r\n    console.error('Failed to send error alert:', e.message);\r\n  }\r\n}\r\n\r\n/**\r\n * Wrap a function call with error alerting\r\n * Usage: safeExecute('ClickUp Sync', function() { dailyClickUpSync(); });\r\n */\r\nfunction safeExecute(operationName, fn) {\r\n  try {\r\n    return fn();\r\n  } catch (error) {\r\n    console.error(operationName + ' failed:', error.message, error.stack);\r\n    sendErrorAlert(operationName, error.message);\r\n    return null;\r\n  }\r\n}\r\n"
    },
    {
      "name": "BigQuery.gs",
      "type": "server_js",
      "source": "/**\r\n * BigQuery.gs - BigQuery Data Storage\r\n * Handles all BigQuery operations\r\n */\r\n\r\nconst DATASET_ID = 'checkin_bot';\r\n\r\n/**\r\n * Insert rows into a BigQuery table\r\n */\r\nfunction insertIntoBigQuery(tableName, rows) {\r\n  if (!rows || rows.length === 0) return;\r\n\r\n  const projectId = getProjectId();\r\n  const token = getServiceAccountToken('https://www.googleapis.com/auth/bigquery');\r\n\r\n  if (!token) {\r\n    console.error('SA token missing, falling back to built-in BigQuery service');\r\n    try {\r\n      const insertRequest = {\r\n        rows: rows.map(row => ({ insertId: Utilities.getUuid(), json: row }))\r\n      };\r\n      BigQuery.Tabledata.insertAll(insertRequest, projectId, DATASET_ID, tableName);\r\n    } catch (e) {\r\n      console.error('Built-in fallback failed:', e.message);\r\n    }\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const url = `https://bigquery.googleapis.com/bigquery/v2/projects/${projectId}/datasets/${DATASET_ID}/tables/${tableName}/insertAll`;\r\n    const payload = {\r\n      rows: rows.map(row => ({\r\n        insertId: Utilities.getUuid(),\r\n        json: row\r\n      }))\r\n    };\r\n\r\n    const options = {\r\n      method: 'post',\r\n      contentType: 'application/json',\r\n      headers: { Authorization: 'Bearer ' + token },\r\n      payload: JSON.stringify(payload),\r\n      muteHttpExceptions: true\r\n    };\r\n\r\n    const response = UrlFetchApp.fetch(url, options);\r\n    if (response.getResponseCode() !== 200) {\r\n      console.error(`BigQuery REST insert error for ${tableName}:`, response.getContentText());\r\n    } else {\r\n      console.log(`Successfully inserted ${rows.length} rows into ${tableName} via SA`);\r\n    }\r\n  } catch (error) {\r\n    console.error(`BigQuery REST insert exception for ${tableName}:`, error.message);\r\n  }\r\n}\r\n\r\n/**\r\n * Run a BigQuery query and return results\r\n */\r\nfunction runBigQueryQuery(query) {\r\n  const projectId = getProjectId();\r\n  const token = getServiceAccountToken('https://www.googleapis.com/auth/bigquery');\r\n\r\n  if (!token) {\r\n    console.error('SA token missing for query, falling back to built-in service');\r\n    try {\r\n      var alertConfig = getConfig();\r\n      sendDirectMessage(alertConfig.settings.manager_email,\r\n        '‚ö†Ô∏è BigQuery service account token failed. Using built-in fallback. Check SA key expiry.');\r\n    } catch (alertErr) { /* don't let alert failure break the query */ }\r\n    try {\r\n      const request = { query: query, useLegacySql: false };\r\n      let queryResults = BigQuery.Jobs.query(request, projectId);\r\n      if (!queryResults.rows) return [];\r\n      return queryResults.rows.map(row => {\r\n        const obj = {};\r\n        row.f.forEach((cell, i) => {\r\n          obj[queryResults.schema.fields[i].name] = cell.v;\r\n        });\r\n        return obj;\r\n      });\r\n    } catch (e) {\r\n      console.error('Built-in BigQuery fallback failed:', e.message);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  try {\r\n    const url = `https://bigquery.googleapis.com/bigquery/v2/projects/${projectId}/queries`;\r\n    const payload = { query: query, useLegacySql: false };\r\n\r\n    const options = {\r\n      method: 'post',\r\n      contentType: 'application/json',\r\n      headers: { Authorization: 'Bearer ' + token },\r\n      payload: JSON.stringify(payload),\r\n      muteHttpExceptions: true\r\n    };\r\n\r\n    let response = UrlFetchApp.fetch(url, options);\r\n    let queryResults = JSON.parse(response.getContentText());\r\n\r\n    if (response.getResponseCode() !== 200) {\r\n      console.error('BigQuery REST query error:', response.getContentText());\r\n      return [];\r\n    }\r\n\r\n    const jobId = queryResults.jobReference.jobId;\r\n\r\n    // Polling if not complete\r\n    while (!queryResults.jobComplete) {\r\n      Utilities.sleep(1000);\r\n      const pollUrl = `https://bigquery.googleapis.com/bigquery/v2/projects/${projectId}/queries/${jobId}`;\r\n      const pollResponse = UrlFetchApp.fetch(pollUrl, {\r\n        method: 'get',\r\n        headers: { Authorization: 'Bearer ' + token },\r\n        muteHttpExceptions: true\r\n      });\r\n      queryResults = JSON.parse(pollResponse.getContentText());\r\n    }\r\n\r\n    // Parse results\r\n    if (!queryResults.rows) return [];\r\n\r\n    const schema = queryResults.schema;\r\n    return queryResults.rows.map(row => {\r\n      const obj = {};\r\n      row.f.forEach((cell, i) => {\r\n        const fieldName = schema.fields[i].name;\r\n        obj[fieldName] = cell.v;\r\n      });\r\n      return obj;\r\n    });\r\n  } catch (error) {\r\n    console.error('BigQuery REST query exception:', error.message);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a record already exists for a user on a given date\r\n * Used for deduplication of check-ins and EODs\r\n */\r\nfunction hasExistingRecord(tableName, emailField, dateField, email, date) {\r\n  var safeEmail = sanitizeForBQ(email);\r\n  var dateStr = Utilities.formatDate(date, 'America/Chicago', 'yyyy-MM-dd');\r\n  var query = 'SELECT COUNT(*) as cnt FROM `' + getProjectId() + '.' + DATASET_ID + '.' + tableName +\r\n    '` WHERE ' + emailField + ' = \"' + safeEmail + '\" AND ' + dateField + ' = \"' + dateStr + '\"';\r\n  var results = runBigQueryQuery(query);\r\n  return results.length > 0 && parseInt(results[0].cnt) > 0;\r\n}\r\n\r\n/**\r\n * Log a check-in (with deduplication)\r\n */\r\nfunction logCheckIn(email, timestamp, response, isLate) {\r\n  // Deduplication: skip if already checked in today\r\n  if (hasExistingRecord('check_ins', 'user_email', 'checkin_date', email, timestamp)) {\r\n    console.log('Duplicate check-in skipped for ' + email);\r\n    return null;\r\n  }\r\n\r\n  const row = {\r\n    checkin_id: Utilities.getUuid(),\r\n    user_email: email,\r\n    checkin_date: Utilities.formatDate(timestamp, 'America/Chicago', 'yyyy-MM-dd'),\r\n    checkin_timestamp: timestamp.toISOString(),\r\n    response_text: response,\r\n    is_late: isLate,\r\n    created_at: new Date().toISOString()\r\n  };\r\n\r\n  insertIntoBigQuery('check_ins', [row]);\r\n  return row.checkin_id;\r\n}\r\n\r\n/**\r\n * Log an EOD report (with deduplication)\r\n */\r\nfunction logEodReport(email, timestamp, tasksCompleted, blockers, tomorrowPriority, rawResponse, hoursWorked) {\r\n  // Deduplication: skip if already submitted EOD today\r\n  if (hasExistingRecord('eod_reports', 'user_email', 'eod_date', email, timestamp)) {\r\n    console.log('Duplicate EOD report skipped for ' + email);\r\n    return null;\r\n  }\r\n\r\n  const row = {\r\n    eod_id: Utilities.getUuid(),\r\n    user_email: email,\r\n    eod_date: Utilities.formatDate(timestamp, 'America/Chicago', 'yyyy-MM-dd'),\r\n    eod_timestamp: timestamp.toISOString(),\r\n    tasks_completed: tasksCompleted,\r\n    blockers: blockers,\r\n    tomorrow_priority: tomorrowPriority,\r\n    raw_response: rawResponse,\r\n    hours_worked: hoursWorked !== null && hoursWorked !== undefined ? hoursWorked : null,\r\n    created_at: new Date().toISOString()\r\n  };\r\n\r\n  insertIntoBigQuery('eod_reports', [row]);\r\n  return row.eod_id;\r\n}\r\n\r\n/**\r\n * Log a missed check-in\r\n */\r\nfunction logMissedCheckIn(email, date, type) {\r\n  const row = {\r\n    missed_id: Utilities.getUuid(),\r\n    user_email: email,\r\n    missed_date: Utilities.formatDate(date, 'America/Chicago', 'yyyy-MM-dd'),\r\n    missed_type: type, // 'CHECKIN' or 'EOD'\r\n    created_at: new Date().toISOString()\r\n  };\r\n\r\n  insertIntoBigQuery('missed_checkins', [row]);\r\n}\r\n\r\n/**\r\n * Log task action from ClickUp\r\n */\r\nfunction logTaskAction(userEmail, taskId, taskName, listId, listName, actionType, oldStatus, newStatus, oldDueDate, newDueDate, status, source) {\r\n  const row = {\r\n    action_id: Utilities.getUuid(),\r\n    timestamp: new Date().toISOString(),\r\n    user_email: userEmail,\r\n    task_id: taskId,\r\n    task_name: taskName,\r\n    list_id: listId,\r\n    list_name: listName,\r\n    action_type: actionType,\r\n    old_status: oldStatus,\r\n    new_status: newStatus,\r\n    old_due_date: oldDueDate,\r\n    new_due_date: newDueDate,\r\n    status: status,\r\n    source: source || 'clickup'\r\n  };\r\n\r\n  insertIntoBigQuery('clickup_task_actions', [row]);\r\n}\r\n\r\n/**\r\n * Log task delay with reason\r\n */\r\nfunction logTaskDelay(userEmail, taskId, taskName, originalDueDate, newDueDate, delayReason, delayCount, source) {\r\n  const row = {\r\n    delay_id: Utilities.getUuid(),\r\n    timestamp: new Date().toISOString(),\r\n    user_email: userEmail,\r\n    task_id: taskId,\r\n    task_name: taskName,\r\n    original_due_date: originalDueDate,\r\n    new_due_date: newDueDate,\r\n    delay_reason: delayReason,\r\n    delay_count: delayCount,\r\n    source: source || 'clickup'\r\n  };\r\n\r\n  insertIntoBigQuery('task_delays', [row]);\r\n}\r\n\r\n/**\r\n * Log overdue snapshot\r\n */\r\nfunction logOverdueSnapshot(snapshots) {\r\n  if (!snapshots || snapshots.length === 0) return;\r\n\r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  const rows = snapshots.map(s => ({\r\n    snapshot_date: today,\r\n    user_email: s.user_email,\r\n    task_id: s.task_id,\r\n    task_name: s.task_name,\r\n    list_name: s.list_name,\r\n    original_due_date: s.original_due_date,\r\n    days_overdue: s.days_overdue,\r\n    is_chronic: s.days_overdue >= 3,\r\n    delay_count: s.delay_count || 0\r\n  }));\r\n\r\n  insertIntoBigQuery('overdue_snapshots', rows);\r\n}\r\n\r\n/**\r\n * Log daily ClickUp snapshot\r\n */\r\nfunction logClickUpDailySnapshot(snapshots) {\r\n  insertIntoBigQuery('clickup_daily_snapshot', snapshots);\r\n}\r\n\r\n/**\r\n * Log system event\r\n */\r\nfunction logSystemEvent(eventType, status, details = {}) {\r\n  const row = {\r\n    event_id: Utilities.getUuid(),\r\n    timestamp: new Date().toISOString(),\r\n    event_type: eventType,\r\n    status: status,\r\n    details: JSON.stringify(details)\r\n  };\r\n\r\n  insertIntoBigQuery('system_events', [row]);\r\n}\r\n\r\n/**\r\n * Log error to sheet (fallback)\r\n */\r\nfunction logErrorToSheet(tableName, data, error) {\r\n  console.error(`Error inserting into ${tableName}:`, error, 'Data:', JSON.stringify(data));\r\n}\r\n\r\n/**\r\n * Log a bot error to BigQuery for tracking\r\n */\r\nfunction logBotError(functionName, error, context) {\r\n  try {\r\n    insertIntoBigQuery('bot_errors', [{\r\n      error_id: Utilities.getUuid(),\r\n      timestamp: new Date().toISOString(),\r\n      function_name: functionName || 'unknown',\r\n      error_message: error ? (error.message || String(error)) : '',\r\n      error_stack: error ? (error.stack || '') : '',\r\n      context: context ? JSON.stringify(context) : ''\r\n    }]);\r\n  } catch (e) {\r\n    // Avoid infinite loop if bot_errors table insert itself fails\r\n    console.error('Failed to log bot error:', e.message);\r\n  }\r\n}\r\n\r\n/**\r\n * Get today's check-ins\r\n */\r\nfunction getTodayCheckIns() {\r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n  const projectId = getProjectId();\r\n\r\n  const query = `\r\n    SELECT user_email, checkin_timestamp, is_late\r\n    FROM \\`${projectId}.${DATASET_ID}.check_ins\\`\r\n    WHERE checkin_date = '${today}'\r\n  `;\r\n\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get today's EOD reports\r\n */\r\nfunction getTodayEodReports() {\r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n  const projectId = getProjectId();\r\n\r\n  const query = `\r\n    SELECT user_email, eod_timestamp, tasks_completed, blockers, tomorrow_priority, hours_worked\r\n    FROM \\`${projectId}.${DATASET_ID}.v_eod_reports\\`\r\n    WHERE eod_date = '${today}'\r\n  `;\r\n\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Sanitize a string for safe use in BigQuery queries (BUG #12 fix)\r\n * Escapes single quotes and removes dangerous characters\r\n */\r\nfunction sanitizeForBQ(value) {\r\n  if (value === null || value === undefined) return '';\r\n  // Escape backslashes FIRST, then quotes (order matters to avoid double-escaping)\r\n  return String(value).replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\").replace(/;/g, '');\r\n}\r\n\r\n/**\r\n * Get user's check-in streak\r\n */\r\nfunction getUserStreak(email) {\r\n  const projectId = getProjectId();\r\n  const safeEmail = sanitizeForBQ(email);\r\n\r\n  const query = `\r\n    WITH consecutive_days AS (\r\n      SELECT\r\n        checkin_date,\r\n        DATE_DIFF(checkin_date, LAG(checkin_date) OVER (ORDER BY checkin_date), DAY) as day_diff\r\n      FROM \\`${projectId}.${DATASET_ID}.check_ins\\`\r\n      WHERE user_email = '${safeEmail}'\r\n      ORDER BY checkin_date DESC\r\n    )\r\n    SELECT COUNT(*) as streak\r\n    FROM (\r\n      SELECT checkin_date\r\n      FROM consecutive_days\r\n      WHERE day_diff IS NULL OR day_diff = 1\r\n    )\r\n  `;\r\n\r\n  const result = runBigQueryQuery(query);\r\n  return result.length > 0 ? parseInt(result[0].streak) : 0;\r\n}\r\n\r\n/**\r\n * Get weekly stats for a user\r\n */\r\nfunction getUserWeeklyStats(email) {\r\n  const projectId = getProjectId();\r\n  const safeEmail = sanitizeForBQ(email);\r\n\r\n  const query = `\r\n    SELECT\r\n      COUNT(DISTINCT c.checkin_date) as checkin_days,\r\n      SUM(CASE WHEN c.is_late THEN 1 ELSE 0 END) as late_days,\r\n      COUNT(DISTINCT e.eod_date) as eod_days\r\n    FROM \\`${projectId}.${DATASET_ID}.check_ins\\` c\r\n    LEFT JOIN \\`${projectId}.${DATASET_ID}.v_eod_reports\\` e\r\n      ON c.user_email = e.user_email AND c.checkin_date = e.eod_date\r\n    WHERE c.user_email = '${safeEmail}'\r\n      AND c.checkin_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)\r\n  `;\r\n\r\n  const result = runBigQueryQuery(query);\r\n  return result.length > 0 ? result[0] : { checkin_days: 0, late_days: 0, eod_days: 0 };\r\n}\r\n\r\n/**\r\n * Get task completion stats for a user this week\r\n */\r\nfunction getUserTaskStats(email) {\r\n  const projectId = getProjectId();\r\n  const safeEmail = sanitizeForBQ(email);\r\n\r\n  const query = `\r\n    SELECT\r\n      SUM(tasks_due_today) as total_due,\r\n      SUM(tasks_completed_today) as total_completed,\r\n      SUM(tasks_moved_tomorrow) as total_moved,\r\n      SUM(tasks_overdue) as total_overdue,\r\n      AVG(completion_rate) as avg_completion_rate\r\n    FROM \\`${projectId}.${DATASET_ID}.clickup_daily_snapshot\\`\r\n    WHERE user_email = '${safeEmail}'\r\n      AND snapshot_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)\r\n  `;\r\n\r\n  const result = runBigQueryQuery(query);\r\n  return result.length > 0 ? result[0] : null;\r\n}\r\n\r\n/**\r\n * Get team overdue summary\r\n */\r\nfunction getTeamOverdueSummary() {\r\n  const projectId = getProjectId();\r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  const query = `\r\n    SELECT\r\n      user_email,\r\n      COUNT(*) as total_overdue,\r\n      MAX(days_overdue) as max_days_overdue,\r\n      ROUND(AVG(days_overdue), 1) as avg_days_overdue,\r\n      SUM(CASE WHEN is_chronic THEN 1 ELSE 0 END) as chronic_count\r\n    FROM \\`${projectId}.${DATASET_ID}.overdue_snapshots\\`\r\n    WHERE snapshot_date = '${today}'\r\n    GROUP BY user_email\r\n    ORDER BY total_overdue DESC\r\n  `;\r\n\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get delay reasons breakdown for this week\r\n */\r\nfunction getWeeklyDelayReasons() {\r\n  const projectId = getProjectId();\r\n\r\n  const query = `\r\n    SELECT\r\n      delay_reason,\r\n      COUNT(*) as count\r\n    FROM \\`${projectId}.${DATASET_ID}.task_delays\\`\r\n    WHERE timestamp >= TIMESTAMP_TRUNC(CURRENT_TIMESTAMP(), WEEK(MONDAY))\r\n    GROUP BY delay_reason\r\n    ORDER BY count DESC\r\n  `;\r\n\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get repeat delayed tasks\r\n */\r\nfunction getRepeatDelayedTasks() {\r\n  const projectId = getProjectId();\r\n\r\n  const query = `\r\n    SELECT\r\n      task_id,\r\n      task_name,\r\n      user_email,\r\n      COUNT(*) as times_delayed\r\n    FROM \\`${projectId}.${DATASET_ID}.task_delays\\`\r\n    WHERE timestamp >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 14 DAY)\r\n    GROUP BY task_id, task_name, user_email\r\n    HAVING COUNT(*) >= 3\r\n    ORDER BY times_delayed DESC\r\n  `;\r\n\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get task action count for user today\r\n */\r\nfunction getUserTodayTaskActions(email) {\r\n  const projectId = getProjectId();\r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n  const safeEmail = sanitizeForBQ(email);\r\n\r\n  const query = `\r\n    SELECT action_type, COUNT(*) as count FROM (\r\n      SELECT task_id, action_type FROM (\r\n        SELECT task_id, action_type, ROW_NUMBER() OVER (PARTITION BY task_id ORDER BY timestamp DESC) as rn\r\n        FROM \\`${projectId}.${DATASET_ID}.clickup_task_actions\\`\r\n        WHERE user_email = '${safeEmail}'\r\n          AND DATE(timestamp) = '${today}'\r\n      ) WHERE rn = 1\r\n    ) GROUP BY action_type\r\n  `;\r\n\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get real weekly stats for the team (BUG #9 fix)\r\n * Used by generateWeeklySummary to replace hardcoded values\r\n */\r\nfunction getWeeklyTeamStats() {\r\n  const projectId = getProjectId();\r\n\r\n  var statsResult = runBigQueryQuery(`\r\n    SELECT\r\n      COUNT(DISTINCT user_email) as total_members,\r\n      COUNT(DISTINCT checkin_date) as total_days,\r\n      COUNT(*) as total_checkins,\r\n      SUM(CASE WHEN is_late THEN 1 ELSE 0 END) as late_checkins\r\n    FROM \\`${projectId}.${DATASET_ID}.check_ins\\`\r\n    WHERE checkin_date >= DATE_TRUNC(CURRENT_DATE(), WEEK(MONDAY))\r\n  `);\r\n\r\n  var eodResult = runBigQueryQuery(`\r\n    SELECT COUNT(*) as total_eods\r\n    FROM \\`${projectId}.${DATASET_ID}.v_eod_reports\\`\r\n    WHERE eod_date >= DATE_TRUNC(CURRENT_DATE(), WEEK(MONDAY))\r\n  `);\r\n\r\n  var taskResult = runBigQueryQuery(`\r\n    SELECT\r\n      SUM(tasks_due_today) as total_due,\r\n      SUM(tasks_completed_today) as total_completed,\r\n      SUM(tasks_moved_tomorrow) as total_moved,\r\n      SUM(tasks_overdue) as total_overdue\r\n    FROM \\`${projectId}.${DATASET_ID}.clickup_daily_snapshot\\`\r\n    WHERE snapshot_date >= DATE_TRUNC(CURRENT_DATE(), WEEK(MONDAY))\r\n  `);\r\n\r\n  var perfectResult = runBigQueryQuery(`\r\n    SELECT user_email\r\n    FROM \\`${projectId}.${DATASET_ID}.check_ins\\`\r\n    WHERE checkin_date >= DATE_TRUNC(CURRENT_DATE(), WEEK(MONDAY))\r\n      AND is_late = FALSE\r\n    GROUP BY user_email\r\n    HAVING COUNT(DISTINCT checkin_date) >= 5\r\n  `);\r\n\r\n  var stats = statsResult.length > 0 ? statsResult[0] : {};\r\n  var eod = eodResult.length > 0 ? eodResult[0] : {};\r\n  var tasks = taskResult.length > 0 ? taskResult[0] : {};\r\n\r\n  var totalMembers = parseInt(stats.total_members) || 1;\r\n  var totalCheckins = parseInt(stats.total_checkins) || 0;\r\n  var lateCheckins = parseInt(stats.late_checkins) || 0;\r\n  var totalEods = parseInt(eod.total_eods) || 0;\r\n  var expectedCheckins = totalMembers * 5; // 5 workdays\r\n\r\n  return {\r\n    checkinRate: expectedCheckins > 0 ? Math.round(totalCheckins / expectedCheckins * 100) : 0,\r\n    onTimeRate: totalCheckins > 0 ? Math.round((totalCheckins - lateCheckins) / totalCheckins * 100) : 0,\r\n    eodRate: expectedCheckins > 0 ? Math.round(totalEods / expectedCheckins * 100) : 0,\r\n    avgLateMinutes: 0, // Would need timestamp analysis\r\n    perfectAttendance: perfectResult.map(function (r) { return r.user_email.split('@')[0]; }),\r\n    totalDue: parseInt(tasks.total_due) || 0,\r\n    totalCompleted: parseInt(tasks.total_completed) || 0,\r\n    totalMoved: parseInt(tasks.total_moved) || 0,\r\n    totalOverdue: parseInt(tasks.total_overdue) || 0\r\n  };\r\n}\r\n\r\n/**\r\n * Setup all BigQuery tables (BUG #16 fix)\r\n * Run once after initial deployment to create required tables\r\n */\r\nfunction setupBigQueryTables() {\r\n  var projectId = getProjectId();\r\n\r\n  var tables = {\r\n    check_ins: [\r\n      { name: 'checkin_id', type: 'STRING' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'checkin_date', type: 'DATE' },\r\n      { name: 'checkin_timestamp', type: 'TIMESTAMP' },\r\n      { name: 'response_text', type: 'STRING' },\r\n      { name: 'is_late', type: 'BOOLEAN' },\r\n      { name: 'created_at', type: 'TIMESTAMP' }\r\n    ],\r\n    eod_reports: [\r\n      { name: 'eod_id', type: 'STRING' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'eod_date', type: 'DATE' },\r\n      { name: 'eod_timestamp', type: 'TIMESTAMP' },\r\n      { name: 'tasks_completed', type: 'STRING' },\r\n      { name: 'blockers', type: 'STRING' },\r\n      { name: 'tomorrow_priority', type: 'STRING' },\r\n      { name: 'raw_response', type: 'STRING' },\r\n      { name: 'hours_worked', type: 'FLOAT' },\r\n      { name: 'created_at', type: 'TIMESTAMP' }\r\n    ],\r\n    missed_checkins: [\r\n      { name: 'missed_id', type: 'STRING' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'missed_date', type: 'DATE' },\r\n      { name: 'missed_type', type: 'STRING' },\r\n      { name: 'created_at', type: 'TIMESTAMP' }\r\n    ],\r\n    clickup_task_actions: [\r\n      { name: 'action_id', type: 'STRING' },\r\n      { name: 'timestamp', type: 'TIMESTAMP' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'task_id', type: 'STRING' },\r\n      { name: 'task_name', type: 'STRING' },\r\n      { name: 'list_id', type: 'STRING' },\r\n      { name: 'list_name', type: 'STRING' },\r\n      { name: 'action_type', type: 'STRING' },\r\n      { name: 'old_status', type: 'STRING' },\r\n      { name: 'new_status', type: 'STRING' },\r\n      { name: 'old_due_date', type: 'STRING' },\r\n      { name: 'new_due_date', type: 'STRING' },\r\n      { name: 'status', type: 'STRING' },\r\n      { name: 'source', type: 'STRING' }\r\n    ],\r\n    task_delays: [\r\n      { name: 'delay_id', type: 'STRING' },\r\n      { name: 'timestamp', type: 'TIMESTAMP' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'task_id', type: 'STRING' },\r\n      { name: 'task_name', type: 'STRING' },\r\n      { name: 'original_due_date', type: 'STRING' },\r\n      { name: 'new_due_date', type: 'STRING' },\r\n      { name: 'delay_reason', type: 'STRING' },\r\n      { name: 'delay_count', type: 'INTEGER' },\r\n      { name: 'source', type: 'STRING' }\r\n    ],\r\n    overdue_snapshots: [\r\n      { name: 'snapshot_date', type: 'DATE' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'task_id', type: 'STRING' },\r\n      { name: 'task_name', type: 'STRING' },\r\n      { name: 'list_name', type: 'STRING' },\r\n      { name: 'original_due_date', type: 'STRING' },\r\n      { name: 'days_overdue', type: 'INTEGER' },\r\n      { name: 'is_chronic', type: 'BOOLEAN' },\r\n      { name: 'delay_count', type: 'INTEGER' }\r\n    ],\r\n    clickup_daily_snapshot: [\r\n      { name: 'snapshot_date', type: 'DATE' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'tasks_due_today', type: 'INTEGER' },\r\n      { name: 'tasks_overdue', type: 'INTEGER' },\r\n      { name: 'tasks_due_this_week', type: 'INTEGER' },\r\n      { name: 'tasks_completed_today', type: 'INTEGER' },\r\n      { name: 'tasks_moved_tomorrow', type: 'INTEGER' },\r\n      { name: 'completion_rate', type: 'FLOAT' }\r\n    ],\r\n    escalations: [\r\n      { name: 'escalation_id', type: 'STRING' },\r\n      { name: 'escalation_type', type: 'STRING' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'task_id', type: 'STRING' },\r\n      { name: 'task_name', type: 'STRING' },\r\n      { name: 'days_overdue', type: 'INTEGER' },\r\n      { name: 'recipients', type: 'STRING' },\r\n      { name: 'created_at', type: 'TIMESTAMP' }\r\n    ],\r\n    ai_evaluations: [\r\n      { name: 'evaluation_id', type: 'STRING' },\r\n      { name: 'evaluation_date', type: 'DATE' },\r\n      { name: 'evaluation_text', type: 'STRING' },\r\n      { name: 'team_size', type: 'INTEGER' },\r\n      { name: 'created_at', type: 'TIMESTAMP' }\r\n    ],\r\n    badges_awarded: [\r\n      { name: 'badge_id', type: 'STRING' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'badge_key', type: 'STRING' },\r\n      { name: 'badge_emoji', type: 'STRING' },\r\n      { name: 'badge_name', type: 'STRING' },\r\n      { name: 'awarded_at', type: 'TIMESTAMP' }\r\n    ],\r\n    system_events: [\r\n      { name: 'event_id', type: 'STRING' },\r\n      { name: 'timestamp', type: 'TIMESTAMP' },\r\n      { name: 'event_type', type: 'STRING' },\r\n      { name: 'status', type: 'STRING' },\r\n      { name: 'details', type: 'STRING' }\r\n    ],\r\n    sage_hr_syncs: [\r\n      { name: 'sync_date', type: 'TIMESTAMP' },\r\n      { name: 'total_employees', type: 'INTEGER' },\r\n      { name: 'active_employees', type: 'INTEGER' },\r\n      { name: 'on_leave_today', type: 'INTEGER' },\r\n      { name: 'working_today', type: 'INTEGER' }\r\n    ],\r\n    employees: [\r\n      { name: 'employee_id', type: 'STRING' },\r\n      { name: 'email', type: 'STRING' },\r\n      { name: 'name', type: 'STRING' },\r\n      { name: 'department', type: 'STRING' },\r\n      { name: 'position', type: 'STRING' },\r\n      { name: 'manager_email', type: 'STRING' },\r\n      { name: 'status', type: 'STRING' },\r\n      { name: 'start_date', type: 'DATE' },\r\n      { name: 'task_source', type: 'STRING' },\r\n      { name: 'updated_at', type: 'TIMESTAMP' }\r\n    ],\r\n    time_off: [\r\n      { name: 'time_off_id', type: 'STRING' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'leave_date', type: 'DATE' },\r\n      { name: 'leave_type', type: 'STRING' },\r\n      { name: 'status', type: 'STRING' },\r\n      { name: 'created_at', type: 'TIMESTAMP' }\r\n    ],\r\n    gamification_streaks: [\r\n      { name: 'streak_id', type: 'STRING' },\r\n      { name: 'user_email', type: 'STRING' },\r\n      { name: 'streak_type', type: 'STRING' },\r\n      { name: 'current_streak', type: 'INTEGER' },\r\n      { name: 'best_streak', type: 'INTEGER' },\r\n      { name: 'last_updated', type: 'TIMESTAMP' }\r\n    ],\r\n    bot_errors: [\r\n      { name: 'error_id', type: 'STRING' },\r\n      { name: 'timestamp', type: 'TIMESTAMP' },\r\n      { name: 'function_name', type: 'STRING' },\r\n      { name: 'error_message', type: 'STRING' },\r\n      { name: 'error_stack', type: 'STRING' },\r\n      { name: 'context', type: 'STRING' }\r\n    ]\r\n  };\r\n\r\n  // Create dataset if needed\r\n  try {\r\n    BigQuery.Datasets.get(projectId, DATASET_ID);\r\n    console.log('Dataset already exists: ' + DATASET_ID);\r\n  } catch (e) {\r\n    try {\r\n      BigQuery.Datasets.insert({ datasetReference: { projectId: projectId, datasetId: DATASET_ID } }, projectId);\r\n      console.log('Created dataset: ' + DATASET_ID);\r\n    } catch (e2) {\r\n      console.error('Failed to create dataset:', e2.message);\r\n      return;\r\n    }\r\n  }\r\n\r\n  // Create tables\r\n  var created = 0;\r\n  var existing = 0;\r\n  for (var tableName in tables) {\r\n    try {\r\n      BigQuery.Tables.get(projectId, DATASET_ID, tableName);\r\n      console.log('Table already exists: ' + tableName);\r\n      existing++;\r\n    } catch (e) {\r\n      try {\r\n        var tableResource = {\r\n          tableReference: { projectId: projectId, datasetId: DATASET_ID, tableId: tableName },\r\n          schema: { fields: tables[tableName] }\r\n        };\r\n        BigQuery.Tables.insert(tableResource, projectId, DATASET_ID);\r\n        console.log('Created table: ' + tableName);\r\n        created++;\r\n      } catch (e2) {\r\n        console.error('Failed to create table ' + tableName + ':', e2.message);\r\n      }\r\n    }\r\n  }\r\n\r\n  console.log('Table setup complete: ' + created + ' created, ' + existing + ' already existed');\r\n\r\n  // Handle ALTER TABLE for existing eod_reports table - add hours_worked column if missing\r\n  try {\r\n    var alterQuery = 'ALTER TABLE `' + projectId + '.' + DATASET_ID + '.eod_reports` ADD COLUMN IF NOT EXISTS hours_worked FLOAT64';\r\n    runBigQueryQuery(alterQuery);\r\n    console.log('Ensured hours_worked column exists in eod_reports');\r\n  } catch (e) {\r\n    console.log('hours_worked column may already exist or ALTER failed:', e.message);\r\n  }\r\n\r\n  // Add source column to clickup_task_actions if missing\r\n  try {\r\n    var alterActions = 'ALTER TABLE `' + projectId + '.' + DATASET_ID + '.clickup_task_actions` ADD COLUMN IF NOT EXISTS source STRING';\r\n    runBigQueryQuery(alterActions);\r\n    console.log('Ensured source column exists in clickup_task_actions');\r\n  } catch (e) {\r\n    console.log('source column in clickup_task_actions may already exist or ALTER failed:', e.message);\r\n  }\r\n\r\n  // Add source column to task_delays if missing\r\n  try {\r\n    var alterDelays = 'ALTER TABLE `' + projectId + '.' + DATASET_ID + '.task_delays` ADD COLUMN IF NOT EXISTS source STRING';\r\n    runBigQueryQuery(alterDelays);\r\n    console.log('Ensured source column exists in task_delays');\r\n  } catch (e) {\r\n    console.log('source column in task_delays may already exist or ALTER failed:', e.message);\r\n  }\r\n\r\n  // Create deduplication view for eod_reports (Append-Only Fix)\r\n  try {\r\n    var viewQuery = 'CREATE OR REPLACE VIEW `' + projectId + '.' + DATASET_ID + '.v_eod_reports` AS '\r\n      + 'SELECT * EXCEPT(row_num) FROM ('\r\n      + '  SELECT *, ROW_NUMBER() OVER (PARTITION BY user_email, eod_date ORDER BY created_at DESC) as row_num '\r\n      + '  FROM `' + projectId + '.' + DATASET_ID + '.eod_reports` '\r\n      + ') WHERE row_num = 1';\r\n    runBigQueryQuery(viewQuery);\r\n    console.log('Created/Updated deduplication view v_eod_reports');\r\n  } catch (e) {\r\n    console.error('Failed to create v_eod_reports view:', e.message);\r\n  }\r\n\r\n  // Create deduplication view for prompt_log (Append-Only Fix)\r\n  // logPromptResponse inserts a new row instead of UPDATE to avoid streaming buffer errors\r\n  try {\r\n    var promptViewQuery = 'CREATE OR REPLACE VIEW `' + projectId + '.' + DATASET_ID + '.v_prompt_log` AS '\r\n      + 'SELECT * EXCEPT(row_num) FROM ('\r\n      + '  SELECT *, ROW_NUMBER() OVER (PARTITION BY prompt_id ORDER BY created_at DESC) as row_num '\r\n      + '  FROM `' + projectId + '.' + DATASET_ID + '.prompt_log` '\r\n      + ') WHERE row_num = 1';\r\n    runBigQueryQuery(promptViewQuery);\r\n    console.log('Created/Updated deduplication view v_prompt_log');\r\n  } catch (e) {\r\n    console.error('Failed to create v_prompt_log view:', e.message);\r\n  }\r\n}\r\n\r\n/**\r\n * Get last week's wins for Monday kickoff message\r\n * Returns: { topCompleter, totalCompleted, teamCheckinRate }\r\n */\r\nfunction getLastWeekWins() {\r\n  var projectId = getProjectId();\r\n\r\n  // Top completer last week\r\n  var topResult = runBigQueryQuery(\r\n    'SELECT user_email, SUM(tasks_completed_today) as total_completed'\r\n    + ' FROM `' + projectId + '.' + DATASET_ID + '.clickup_daily_snapshot`'\r\n    + ' WHERE snapshot_date >= DATE_SUB(DATE_TRUNC(CURRENT_DATE(), WEEK(MONDAY)), INTERVAL 7 DAY)'\r\n    + '   AND snapshot_date < DATE_TRUNC(CURRENT_DATE(), WEEK(MONDAY))'\r\n    + ' GROUP BY user_email'\r\n    + ' ORDER BY total_completed DESC'\r\n    + ' LIMIT 1'\r\n  );\r\n\r\n  // Total completed last week\r\n  var totalResult = runBigQueryQuery(\r\n    'SELECT SUM(tasks_completed_today) as total'\r\n    + ' FROM `' + projectId + '.' + DATASET_ID + '.clickup_daily_snapshot`'\r\n    + ' WHERE snapshot_date >= DATE_SUB(DATE_TRUNC(CURRENT_DATE(), WEEK(MONDAY)), INTERVAL 7 DAY)'\r\n    + '   AND snapshot_date < DATE_TRUNC(CURRENT_DATE(), WEEK(MONDAY))'\r\n  );\r\n\r\n  // Check-in rate last week\r\n  var checkinResult = runBigQueryQuery(\r\n    'SELECT COUNT(*) as total_checkins, COUNT(DISTINCT user_email) as unique_users'\r\n    + ' FROM `' + projectId + '.' + DATASET_ID + '.check_ins`'\r\n    + ' WHERE checkin_date >= DATE_SUB(DATE_TRUNC(CURRENT_DATE(), WEEK(MONDAY)), INTERVAL 7 DAY)'\r\n    + '   AND checkin_date < DATE_TRUNC(CURRENT_DATE(), WEEK(MONDAY))'\r\n  );\r\n\r\n  var topCompleter = topResult.length > 0 ? {\r\n    email: topResult[0].user_email,\r\n    name: topResult[0].user_email.split('@')[0],\r\n    count: parseInt(topResult[0].total_completed) || 0\r\n  } : null;\r\n\r\n  var totalCompleted = totalResult.length > 0 ? parseInt(totalResult[0].total) || 0 : 0;\r\n\r\n  var checkins = checkinResult.length > 0 ? parseInt(checkinResult[0].total_checkins) || 0 : 0;\r\n  var uniqueUsers = checkinResult.length > 0 ? parseInt(checkinResult[0].unique_users) || 1 : 1;\r\n  var teamCheckinRate = uniqueUsers > 0 ? Math.round(checkins / (uniqueUsers * 5) * 100) : 0;\r\n\r\n  return {\r\n    topCompleter: topCompleter,\r\n    totalCompleted: totalCompleted,\r\n    teamCheckinRate: teamCheckinRate\r\n  };\r\n}\r\n\r\n/**\r\n * Get active streaks that are at risk (for Monday kickoff)\r\n * Returns array of { email, name, streak }\r\n */\r\nfunction getActiveStreaks() {\r\n  var projectId = getProjectId();\r\n\r\n  var result = runBigQueryQuery(\r\n    'WITH ranked AS ('\r\n    + '  SELECT user_email, checkin_date,'\r\n    + '    DATE_DIFF(checkin_date, LAG(checkin_date) OVER (PARTITION BY user_email ORDER BY checkin_date), DAY) as gap'\r\n    + '  FROM `' + projectId + '.' + DATASET_ID + '.check_ins`'\r\n    + '  WHERE checkin_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 60 DAY)'\r\n    + '  AND is_late = FALSE'\r\n    + '),'\r\n    + 'streak_breaks AS ('\r\n    + '  SELECT user_email, checkin_date, gap,'\r\n    + '    SUM(CASE WHEN gap > 3 OR gap IS NULL THEN 1 ELSE 0 END) OVER (PARTITION BY user_email ORDER BY checkin_date) as grp'\r\n    + '  FROM ranked'\r\n    + ')'\r\n    + ' SELECT user_email, COUNT(*) as streak_length'\r\n    + ' FROM streak_breaks'\r\n    + ' WHERE grp = (SELECT MAX(grp) FROM streak_breaks sb WHERE sb.user_email = streak_breaks.user_email)'\r\n    + ' GROUP BY user_email'\r\n    + ' HAVING COUNT(*) >= 5'\r\n    + ' ORDER BY streak_length DESC'\r\n  );\r\n\r\n  return result.map(function (r) {\r\n    return {\r\n      email: r.user_email,\r\n      name: r.user_email.split('@')[0],\r\n      streak: parseInt(r.streak_length) || 0\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * Update today's EOD report with hours (bare-number follow-up)\r\n */\r\nfunction updateTodayEodHours(email, hours) {\r\n  var projectId = getProjectId();\r\n  var safeEmail = sanitizeForBQ(email);\r\n  var today = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  // Append-only pattern: INSERT new row with hours instead of UPDATE\r\n  var query = 'INSERT INTO `' + projectId + '.' + DATASET_ID + '.eod_reports` '\r\n    + '(eod_id, user_email, eod_date, eod_timestamp, tasks_completed, blockers, tomorrow_priority, raw_response, hours_worked, created_at) '\r\n    + 'SELECT \\'' + Utilities.getUuid() + '\\', \\'' + safeEmail + '\\', eod_date, eod_timestamp, tasks_completed, blockers, tomorrow_priority, raw_response, ' + hours + ', CURRENT_TIMESTAMP() '\r\n    + 'FROM `' + projectId + '.' + DATASET_ID + '.v_eod_reports` '\r\n    + 'WHERE user_email = \\'' + safeEmail + '\\' AND eod_date = \\'' + today + '\\'';\r\n\r\n  runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get weekly hours data - per-person daily hours for current week\r\n */\r\nfunction getWeeklyHoursData() {\r\n  var projectId = getProjectId();\r\n  var query = 'SELECT user_email, eod_date, hours_worked, tasks_completed'\r\n    + ' FROM `' + projectId + '.' + DATASET_ID + '.v_eod_reports`'\r\n    + ' WHERE eod_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY)'\r\n    + ' AND hours_worked IS NOT NULL'\r\n    + ' ORDER BY user_email, eod_date';\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get hours trends - weekly averages for 4-week trends\r\n */\r\nfunction getHoursTrends() {\r\n  var projectId = getProjectId();\r\n  var query = 'SELECT'\r\n    + ' user_email,'\r\n    + ' EXTRACT(ISOWEEK FROM eod_date) AS week_num,'\r\n    + ' MIN(eod_date) AS week_start,'\r\n    + ' ROUND(AVG(hours_worked), 1) AS avg_daily_hours,'\r\n    + ' ROUND(SUM(hours_worked), 1) AS total_hours,'\r\n    + ' COUNT(*) AS days_reported'\r\n    + ' FROM `' + projectId + '.' + DATASET_ID + '.v_eod_reports`'\r\n    + ' WHERE eod_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 28 DAY)'\r\n    + ' AND hours_worked IS NOT NULL'\r\n    + ' GROUP BY user_email, week_num'\r\n    + ' ORDER BY user_email, week_num';\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n// ============================================\r\n// AI EVALUATION HISTORICAL DATA (V2)\r\n// ============================================\r\n\r\n/**\r\n * Get weekly attendance stats for ALL team members (batched)\r\n * Returns: [{user_email, checkin_days, late_days, eod_days}]\r\n */\r\nfunction getTeamWeeklyAttendanceStats() {\r\n  var projectId = getProjectId();\r\n  var query = 'SELECT '\r\n    + '  c.user_email, '\r\n    + '  COUNT(DISTINCT c.checkin_date) as checkin_days, '\r\n    + '  SUM(CASE WHEN c.is_late THEN 1 ELSE 0 END) as late_days, '\r\n    + '  COUNT(DISTINCT e.eod_date) as eod_days '\r\n    + 'FROM `' + projectId + '.' + DATASET_ID + '.check_ins` c '\r\n    + 'LEFT JOIN `' + projectId + '.' + DATASET_ID + '.v_eod_reports` e '\r\n    + '  ON c.user_email = e.user_email AND c.checkin_date = e.eod_date '\r\n    + 'WHERE c.checkin_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY) '\r\n    + 'GROUP BY c.user_email';\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get task completion stats for ALL team members (batched)\r\n * Returns: [{user_email, total_due, total_completed, total_moved, total_overdue, avg_completion_rate}]\r\n */\r\nfunction getTeamTaskStats() {\r\n  var projectId = getProjectId();\r\n  var query = 'SELECT '\r\n    + '  user_email, '\r\n    + '  SUM(tasks_due_today) as total_due, '\r\n    + '  SUM(tasks_completed_today) as total_completed, '\r\n    + '  SUM(tasks_moved_tomorrow) as total_moved, '\r\n    + '  SUM(tasks_overdue) as total_overdue, '\r\n    + '  ROUND(AVG(completion_rate), 1) as avg_completion_rate '\r\n    + 'FROM `' + projectId + '.' + DATASET_ID + '.clickup_daily_snapshot` '\r\n    + 'WHERE snapshot_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 7 DAY) '\r\n    + 'GROUP BY user_email';\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get on-time check-in streaks for ALL team members (batched)\r\n * Returns: [{user_email, streak_length}]\r\n */\r\nfunction getTeamStreaks() {\r\n  var projectId = getProjectId();\r\n  var query = 'WITH ranked AS ('\r\n    + '  SELECT user_email, checkin_date,'\r\n    + '    DATE_DIFF(checkin_date, LAG(checkin_date) OVER (PARTITION BY user_email ORDER BY checkin_date), DAY) as gap'\r\n    + '  FROM `' + projectId + '.' + DATASET_ID + '.check_ins`'\r\n    + '  WHERE checkin_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 60 DAY)'\r\n    + '  AND is_late = FALSE'\r\n    + '),'\r\n    + 'streak_breaks AS ('\r\n    + '  SELECT user_email, checkin_date, gap,'\r\n    + '    SUM(CASE WHEN gap > 3 OR gap IS NULL THEN 1 ELSE 0 END) OVER (PARTITION BY user_email ORDER BY checkin_date) as grp'\r\n    + '  FROM ranked'\r\n    + ')'\r\n    + ' SELECT user_email, COUNT(*) as streak_length'\r\n    + ' FROM streak_breaks'\r\n    + ' WHERE grp = (SELECT MAX(grp) FROM streak_breaks sb WHERE sb.user_email = streak_breaks.user_email)'\r\n    + ' GROUP BY user_email';\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get yesterday's stated priorities (tomorrow_priority) for each user\r\n * Handles Monday ‚Üí Friday lookback automatically\r\n * Returns: [{user_email, tomorrow_priority}]\r\n */\r\nfunction getYesterdayEodPriorities() {\r\n  var projectId = getProjectId();\r\n  var query = 'SELECT user_email, tomorrow_priority '\r\n    + 'FROM `' + projectId + '.' + DATASET_ID + '.v_eod_reports` '\r\n    + 'WHERE eod_date = ( '\r\n    + '  SELECT MAX(eod_date) FROM `' + projectId + '.' + DATASET_ID + '.v_eod_reports` '\r\n    + '  WHERE eod_date < CURRENT_DATE() '\r\n    + '  AND eod_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 4 DAY) '\r\n    + ') '\r\n    + 'AND tomorrow_priority IS NOT NULL '\r\n    + 'AND tomorrow_priority != \"\"';\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n/**\r\n * Get the most recent AI evaluation for continuity\r\n * Returns: {evaluation_date, evaluation_text} or null\r\n */\r\nfunction getLastAiEvaluation() {\r\n  var projectId = getProjectId();\r\n  var query = 'SELECT evaluation_date, evaluation_text '\r\n    + 'FROM `' + projectId + '.' + DATASET_ID + '.ai_evaluations` '\r\n    + 'WHERE evaluation_date < CURRENT_DATE() '\r\n    + 'ORDER BY evaluation_date DESC '\r\n    + 'LIMIT 1';\r\n  var results = runBigQueryQuery(query);\r\n  return results.length > 0 ? results[0] : null;\r\n}\r\n\r\n// ============================================\r\n// PROMPT LOGGING (V2)\r\n// ============================================\r\n\r\n/**\r\n * Log a prompt sent to a user\r\n * Returns the prompt_id for tracking\r\n */\r\nfunction logPromptSent(email, promptType) {\r\n  var promptId = Utilities.getUuid();\r\n  var now = new Date();\r\n  var row = {\r\n    prompt_id: promptId,\r\n    user_email: email,\r\n    prompt_type: promptType,\r\n    sent_at: now.toISOString(),\r\n    response_received: false,\r\n    response_at: null,\r\n    response_latency_minutes: null,\r\n    created_at: now.toISOString()\r\n  };\r\n  insertIntoBigQuery('prompt_log', [row]);\r\n\r\n  // Cache the prompt_id for this user+type so we can match the response\r\n  // Using prompt type in key prevents collisions when multiple prompts sent before response\r\n  var cache = CacheService.getScriptCache();\r\n  cache.put('LAST_PROMPT_' + promptType + '_' + email, JSON.stringify({\r\n    prompt_id: promptId,\r\n    prompt_type: promptType,\r\n    sent_at: now.toISOString()\r\n  }), 14400); // 4 hour TTL\r\n  return promptId;\r\n}\r\n\r\n/**\r\n * Log a prompt response from a user\r\n * Matches to the last sent prompt of given type and calculates latency\r\n * Uses append-only INSERT instead of UPDATE to avoid BigQuery streaming buffer errors\r\n * @param {string} email User email\r\n * @param {string} promptType The prompt type to match (e.g. 'CHECKIN', 'EOD')\r\n */\r\nfunction logPromptResponse(email, promptType) {\r\n  var cache = CacheService.getScriptCache();\r\n  var raw = cache.get('LAST_PROMPT_' + promptType + '_' + email);\r\n  if (!raw) return null;\r\n\r\n  var promptData = JSON.parse(raw);\r\n  var now = new Date();\r\n  var sentAt = new Date(promptData.sent_at);\r\n  var latencyMinutes = Math.round((now - sentAt) / 60000 * 10) / 10;\r\n\r\n  // Append-only pattern: INSERT a new row with response data (avoids streaming buffer DML error)\r\n  // Use v_prompt_log view to deduplicate by prompt_id (takes latest row)\r\n  try {\r\n    var row = {\r\n      prompt_id: promptData.prompt_id,\r\n      user_email: email,\r\n      prompt_type: promptData.prompt_type,\r\n      sent_at: promptData.sent_at,\r\n      response_received: true,\r\n      response_at: now.toISOString(),\r\n      response_latency_minutes: latencyMinutes,\r\n      created_at: now.toISOString()\r\n    };\r\n    insertIntoBigQuery('prompt_log', [row]);\r\n  } catch (e) {\r\n    console.warn('prompt_log INSERT failed:', e.message);\r\n  }\r\n\r\n  cache.remove('LAST_PROMPT_' + promptType + '_' + email);\r\n  return { prompt_id: promptData.prompt_id, latency_minutes: latencyMinutes, prompt_type: promptData.prompt_type };\r\n}\r\n\r\n// ============================================\r\n// TASK PUSH COUNT TRACKING (V2)\r\n// ============================================\r\n\r\n/**\r\n * Get push count for a task (how many times it was moved to \"Tomorrow\")\r\n */\r\nfunction getTaskPushCount(taskId) {\r\n  var projectId = getProjectId();\r\n  var query = 'SELECT COUNT(*) as push_count FROM `' + projectId + '.' + DATASET_ID + '.clickup_task_actions` ' +\r\n    'WHERE task_id = \"' + taskId + '\" AND action_type = \"TOMORROW\"';\r\n  var results = runBigQueryQuery(query);\r\n  return results.length > 0 ? parseInt(results[0].push_count) : 0;\r\n}\r\n\r\n/**\r\n * Get all tasks pushed 3+ times (chronic delays)\r\n */\r\nfunction getChronicallyDelayedTasks() {\r\n  var projectId = getProjectId();\r\n  var query = 'SELECT task_id, task_name, user_email, COUNT(*) as push_count, ' +\r\n    'MAX(timestamp) as last_pushed ' +\r\n    'FROM `' + projectId + '.' + DATASET_ID + '.clickup_task_actions` ' +\r\n    'WHERE action_type = \"TOMORROW\" ' +\r\n    'GROUP BY task_id, task_name, user_email ' +\r\n    'HAVING push_count >= 3 ' +\r\n    'ORDER BY push_count DESC';\r\n  return runBigQueryQuery(query);\r\n}\r\n\r\n// ============================================\r\n// V2 TABLE CREATION\r\n// ============================================\r\n\r\n/**\r\n * Create all new BigQuery tables for V2 features\r\n * Run this once during setup\r\n */\r\nfunction createV2Tables() {\r\n  var projectId = getProjectId();\r\n\r\n  var tables = [\r\n    {\r\n      name: 'prompt_log',\r\n      schema: [\r\n        { name: 'prompt_id', type: 'STRING', mode: 'REQUIRED' },\r\n        { name: 'user_email', type: 'STRING', mode: 'REQUIRED' },\r\n        { name: 'prompt_type', type: 'STRING', mode: 'REQUIRED' },\r\n        { name: 'sent_at', type: 'TIMESTAMP', mode: 'REQUIRED' },\r\n        { name: 'response_received', type: 'BOOLEAN' },\r\n        { name: 'response_at', type: 'TIMESTAMP' },\r\n        { name: 'response_latency_minutes', type: 'FLOAT' },\r\n        { name: 'created_at', type: 'TIMESTAMP', mode: 'REQUIRED' }\r\n      ]\r\n    },\r\n    {\r\n      name: 'daily_adoption_metrics',\r\n      schema: [\r\n        { name: 'metric_id', type: 'STRING', mode: 'REQUIRED' },\r\n        { name: 'metric_date', type: 'DATE', mode: 'REQUIRED' },\r\n        { name: 'user_email', type: 'STRING', mode: 'REQUIRED' },\r\n        { name: 'checkin_prompted', type: 'BOOLEAN' },\r\n        { name: 'checkin_responded', type: 'BOOLEAN' },\r\n        { name: 'checkin_latency_minutes', type: 'FLOAT' },\r\n        { name: 'checkin_is_late', type: 'BOOLEAN' },\r\n        { name: 'eod_prompted', type: 'BOOLEAN' },\r\n        { name: 'eod_responded', type: 'BOOLEAN' },\r\n        { name: 'eod_latency_minutes', type: 'FLOAT' },\r\n        { name: 'eod_word_count', type: 'INTEGER' },\r\n        { name: 'eod_hours_included', type: 'BOOLEAN' },\r\n        { name: 'eod_blockers_included', type: 'BOOLEAN' },\r\n        { name: 'eod_tomorrow_included', type: 'BOOLEAN' },\r\n        { name: 'used_task_buttons', type: 'BOOLEAN' },\r\n        { name: 'button_actions_count', type: 'INTEGER' },\r\n        { name: 'created_at', type: 'TIMESTAMP', mode: 'REQUIRED' }\r\n      ]\r\n    },\r\n    {\r\n      name: 'weekly_adoption_scores',\r\n      schema: [\r\n        { name: 'score_id', type: 'STRING', mode: 'REQUIRED' },\r\n        { name: 'week_start', type: 'DATE', mode: 'REQUIRED' },\r\n        { name: 'week_end', type: 'DATE', mode: 'REQUIRED' },\r\n        { name: 'user_email', type: 'STRING', mode: 'REQUIRED' },\r\n        { name: 'checkin_response_rate', type: 'INTEGER' },\r\n        { name: 'eod_response_rate', type: 'INTEGER' },\r\n        { name: 'avg_checkin_latency_minutes', type: 'FLOAT' },\r\n        { name: 'avg_eod_latency_minutes', type: 'FLOAT' },\r\n        { name: 'avg_eod_word_count', type: 'INTEGER' },\r\n        { name: 'hours_inclusion_rate', type: 'INTEGER' },\r\n        { name: 'tomorrow_inclusion_rate', type: 'INTEGER' },\r\n        { name: 'button_adoption_rate', type: 'INTEGER' },\r\n        { name: 'adoption_score', type: 'INTEGER' },\r\n        { name: 'created_at', type: 'TIMESTAMP', mode: 'REQUIRED' }\r\n      ]\r\n    }\r\n  ];\r\n\r\n  tables.forEach(function (table) {\r\n    try {\r\n      var resource = {\r\n        tableReference: {\r\n          projectId: projectId,\r\n          datasetId: DATASET_ID,\r\n          tableId: table.name\r\n        },\r\n        schema: { fields: table.schema }\r\n      };\r\n      BigQuery.Tables.insert(resource, projectId, DATASET_ID);\r\n      console.log('Created table: ' + table.name);\r\n    } catch (e) {\r\n      if (e.message.includes('Already Exists')) {\r\n        console.log('Table already exists: ' + table.name);\r\n      } else {\r\n        console.error('Error creating table ' + table.name + ':', e.message);\r\n      }\r\n    }\r\n  });\r\n}\r\n"
    },
    {
      "name": "Chat.gs",
      "type": "server_js",
      "source": "/**\r\n * Chat.gs - Google Chat Integration\r\n * Handles DMs, channel posts, and message formatting\r\n * Uses REST API for app-initiated messages with Service Account for cards support\r\n */\r\n\r\n// Cache for DM space IDs\r\nconst DM_SPACE_CACHE = {};\r\n\r\n\r\n\r\n/**\r\n * Check if service account is configured\r\n */\r\nfunction isServiceAccountConfigured() {\r\n  const props = PropertiesService.getScriptProperties();\r\n  return !!props.getProperty('SERVICE_ACCOUNT_KEY');\r\n}\r\n\r\n/**\r\n * Get DM space for a user (from storage only - does not create)\r\n * Spaces are stored when users message the bot\r\n */\r\nfunction getDMSpace(userEmail) {\r\n  // Check in-memory cache first\r\n  if (DM_SPACE_CACHE[userEmail]) {\r\n    return DM_SPACE_CACHE[userEmail];\r\n  }\r\n\r\n  // Check persistent storage (individual property per user)\r\n  try {\r\n    const props = PropertiesService.getScriptProperties();\r\n    var key = 'DM_SPACE_' + userEmail.replace(/[^a-zA-Z0-9]/g, '_');\r\n    var spaceName = props.getProperty(key);\r\n\r\n    if (spaceName) {\r\n      DM_SPACE_CACHE[userEmail] = spaceName;\r\n      return spaceName;\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error getting DM space for ${userEmail}:`, error);\r\n  }\r\n\r\n  // No space found - user needs to message the bot first\r\n  console.log(`No DM space stored for ${userEmail} - user must message bot first`);\r\n  return null;\r\n}\r\n\r\n/**\r\n * Store DM space when user first interacts with bot\r\n * Stores as individual property: DM_SPACE_{email}\r\n */\r\nfunction storeDMSpace(userEmail, spaceName) {\r\n  try {\r\n    // Update in-memory cache\r\n    DM_SPACE_CACHE[userEmail] = spaceName;\r\n\r\n    // Persist to Script Properties (individual property per user)\r\n    const props = PropertiesService.getScriptProperties();\r\n    var key = 'DM_SPACE_' + userEmail.replace(/[^a-zA-Z0-9]/g, '_');\r\n    props.setProperty(key, spaceName);\r\n\r\n    console.log(`Stored DM space for ${userEmail}: ${spaceName}`);\r\n  } catch (error) {\r\n    console.error(`Error storing DM space for ${userEmail}:`, error);\r\n  }\r\n}\r\n\r\n/**\r\n * One-time migration: move DM spaces from JSON blob to individual properties\r\n * Run once after deploying V2\r\n */\r\nfunction migrateDMSpaces() {\r\n  try {\r\n    var props = PropertiesService.getScriptProperties();\r\n    var blobJson = props.getProperty('DM_SPACES');\r\n    if (!blobJson) {\r\n      console.log('No DM_SPACES blob to migrate');\r\n      return;\r\n    }\r\n\r\n    var dmSpaces = JSON.parse(blobJson);\r\n    var count = 0;\r\n    for (var email in dmSpaces) {\r\n      var key = 'DM_SPACE_' + email.replace(/[^a-zA-Z0-9]/g, '_');\r\n      props.setProperty(key, dmSpaces[email]);\r\n      count++;\r\n    }\r\n\r\n    // Delete the old blob\r\n    props.deleteProperty('DM_SPACES');\r\n    console.log('Migrated ' + count + ' DM spaces to individual properties');\r\n  } catch (error) {\r\n    console.error('Error migrating DM spaces:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Send a direct message to a user\r\n */\r\nfunction sendDirectMessage(userEmail, text, cards = null) {\r\n  const spaceName = getDMSpace(userEmail);\r\n\r\n  if (!spaceName) {\r\n    console.error(`Cannot send DM to ${userEmail}: no space available`);\r\n    return null;\r\n  }\r\n\r\n  return sendMessageToSpace(spaceName, text, cards);\r\n}\r\n\r\n/**\r\n * Send message to a space (DM or channel)\r\n * Uses Service Account for cards support, falls back to user OAuth for text-only\r\n */\r\nfunction sendMessageToSpace(spaceName, text, cards = null) {\r\n  if (!spaceName) {\r\n    console.error('sendMessageToSpace: spaceName is required');\r\n    return { sent: false, error: 'Missing spaceName' };\r\n  }\r\n\r\n  try {\r\n    let accessToken;\r\n    let useServiceAccount = false;\r\n\r\n    // Use service account if available for all message types\r\n    if (isServiceAccountConfigured()) {\r\n      accessToken = getServiceAccountToken('https://www.googleapis.com/auth/chat.bot');\r\n      if (accessToken) {\r\n        useServiceAccount = true;\r\n      } else {\r\n        console.warn('Service account token failed, falling back to text-only message');\r\n      }\r\n    }\r\n\r\n    // Fall back to user OAuth if no service account or no cards\r\n    if (!accessToken) {\r\n      accessToken = ScriptApp.getOAuthToken();\r\n    }\r\n\r\n    // Build message payload\r\n    const payload = {\r\n      text: text\r\n    };\r\n\r\n    // Only add cards if using service account\r\n    if (cards && useServiceAccount) {\r\n      payload.cardsV2 = cards;\r\n    } else if (cards) {\r\n      console.log('Note: Cards require service account - sending text only');\r\n    }\r\n\r\n    // Configure HTTP request\r\n    const options = {\r\n      method: 'post',\r\n      contentType: 'application/json',\r\n      headers: {\r\n        'Authorization': 'Bearer ' + accessToken\r\n      },\r\n      payload: JSON.stringify(payload),\r\n      muteHttpExceptions: true\r\n    };\r\n\r\n    console.log('Sending message to ' + spaceName + ', useServiceAccount: ' + useServiceAccount);\r\n\r\n    // Call Chat API\r\n    const url = `https://chat.googleapis.com/v1/${spaceName}/messages`;\r\n    const response = UrlFetchApp.fetch(url, options);\r\n    const responseCode = response.getResponseCode();\r\n\r\n    if (responseCode === 200 || responseCode === 201) {\r\n      console.log(`Message sent successfully to ${spaceName}` + (useServiceAccount ? ' (with cards)' : ''));\r\n      const responseData = JSON.parse(response.getContentText());\r\n      return {\r\n        sent: true,\r\n        spaceName: spaceName,\r\n        messageName: responseData.name,\r\n        hasCards: useServiceAccount && !!cards\r\n      };\r\n    } else {\r\n      const errorText = response.getContentText();\r\n      console.error(`Failed to send message to ${spaceName}: ${responseCode}`);\r\n      console.error(`Error details: ${errorText}`);\r\n      return {\r\n        sent: false,\r\n        error: `HTTP ${responseCode}: ${errorText}`\r\n      };\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error(`Exception in sendMessageToSpace for ${spaceName}:`);\r\n    console.error(`Error: ${error.message}`);\r\n    console.error(`Stack: ${error.stack}`);\r\n    return {\r\n      sent: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Send message to a channel/space\r\n */\r\nfunction sendChannelMessage(spaceId, text, cards = null) {\r\n  return sendMessageToSpace(spaceId, text, cards);\r\n}\r\n\r\n/**\r\n * Update an existing message (BUG #14 fix)\r\n * Uses Chat REST API with service account auth\r\n */\r\nfunction updateMessage(messageName, text, cards) {\r\n  if (!messageName) {\r\n    console.error('updateMessage: messageName is required');\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    var accessToken = null;\r\n    var updateMask = 'text';\r\n\r\n    if (isServiceAccountConfigured()) {\r\n      accessToken = getServiceAccountToken();\r\n    }\r\n    if (!accessToken) {\r\n      accessToken = ScriptApp.getOAuthToken();\r\n    }\r\n\r\n    var payload = { text: text };\r\n\r\n    if (cards && isServiceAccountConfigured()) {\r\n      payload.cardsV2 = cards;\r\n      updateMask = 'text,cardsV2';\r\n    }\r\n\r\n    var url = 'https://chat.googleapis.com/v1/' + messageName + '?updateMask=' + updateMask;\r\n    var options = {\r\n      method: 'put',\r\n      contentType: 'application/json',\r\n      headers: {\r\n        'Authorization': 'Bearer ' + accessToken\r\n      },\r\n      payload: JSON.stringify(payload),\r\n      muteHttpExceptions: true\r\n    };\r\n\r\n    var response = UrlFetchApp.fetch(url, options);\r\n    var responseCode = response.getResponseCode();\r\n\r\n    if (responseCode === 200) {\r\n      console.log('Message updated: ' + messageName);\r\n      return JSON.parse(response.getContentText());\r\n    } else {\r\n      console.error('Failed to update message: ' + responseCode + ' - ' + response.getContentText());\r\n      return null;\r\n    }\r\n  } catch (error) {\r\n    console.error('Error updating message:', error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Send escalation to all recipients as individual DMs (BUG #5 fix)\r\n * Replaces placeholder createGroupDM - sends individual DMs instead\r\n */\r\nfunction sendEscalationToRecipients(emails, message) {\r\n  var results = [];\r\n  for (var i = 0; i < emails.length; i++) {\r\n    try {\r\n      var result = sendDirectMessage(emails[i], message);\r\n      results.push({ email: emails[i], sent: result ? result.sent : false });\r\n    } catch (err) {\r\n      console.error('Error sending escalation to ' + emails[i] + ':', err.message);\r\n      results.push({ email: emails[i], sent: false, error: err.message });\r\n    }\r\n  }\r\n  return results;\r\n}\r\n\r\n/**\r\n * Get the team updates channel space ID from config\r\n */\r\nfunction getTeamUpdatesChannel() {\r\n  const config = getConfig();\r\n  return config.settings.team_updates_space_id;\r\n}\r\n\r\n/**\r\n * Post morning summary to team channel\r\n */\r\nfunction postMorningSummary(checkedIn, late, missing, overdueStats, onLeaveToday, todayBirthdays, notTracked) {\r\n  const spaceId = getTeamUpdatesChannel();\r\n  if (!spaceId) {\r\n    console.error('Team updates channel not configured');\r\n    return;\r\n  }\r\n\r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'EEEE, MMMM d');\r\n\r\n  let message = `üìä **Morning Summary - ${today}**\\n\\n`;\r\n  // Total = checkedIn + missing (late are already included in checkedIn)\r\n  message += `‚úÖ Checked in: ${checkedIn.length}/${checkedIn.length + missing.length}\\n`;\r\n\r\n  if (late.length > 0) {\r\n    message += `‚è∞ Late: ${late.length} (${late.map(e => e.name || e.email.split('@')[0]).join(', ')})\\n`;\r\n  }\r\n\r\n  if (missing.length > 0) {\r\n    message += `‚ùå Missing: ${missing.length} (${missing.map(e => e.name || e.email.split('@')[0]).join(', ')})\\n`;\r\n  }\r\n\r\n  // OUT TODAY section - PTO / leave\r\n  if (onLeaveToday && onLeaveToday.length > 0) {\r\n    message += `\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `üèñÔ∏è **Out Today**\\n\\n`;\r\n    onLeaveToday.forEach(function (person) {\r\n      message += `‚Ä¢ ${person.name} ‚Äî ${person.leave_type}\\n`;\r\n    });\r\n  }\r\n\r\n  // BIRTHDAYS section\r\n  if (todayBirthdays && todayBirthdays.length > 0) {\r\n    message += `\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `üéÇ **Birthdays Today**\\n\\n`;\r\n    todayBirthdays.forEach(function (person) {\r\n      message += `‚Ä¢ Happy Birthday, ${person.name}! üéâ\\n`;\r\n    });\r\n  }\r\n\r\n  // Add overdue stats if available\r\n  if (overdueStats && overdueStats.totalOverdue > 0) {\r\n    message += `\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `‚ö†Ô∏è **Team Overdue Alert**\\n\\n`;\r\n    message += `Total overdue tasks: ${overdueStats.totalOverdue} across ${overdueStats.peopleWithOverdue} people\\n\\n`;\r\n\r\n    if (overdueStats.topOffenders && overdueStats.topOffenders.length > 0) {\r\n      message += `Top overdue:\\n`;\r\n      overdueStats.topOffenders.slice(0, 3).forEach(o => {\r\n        message += `‚Ä¢ ${o.name}: ${o.count} overdue (oldest: ${o.maxDays} days)\\n`;\r\n      });\r\n    }\r\n\r\n    if (overdueStats.chronicCount > 0) {\r\n      message += `\\nüî¥ Chronic (3+ days): ${overdueStats.chronicCount} tasks\\n`;\r\n    }\r\n  }\r\n\r\n  // Not tracked section\r\n  if (notTracked && notTracked.length > 0) {\r\n    message += `\\nüìå Not tracked: ${notTracked.map(function(m) { return m.name || m.email.split('@')[0]; }).join(', ')}\\n`;\r\n  }\r\n\r\n  sendChannelMessage(spaceId, message);\r\n}\r\n\r\n/**\r\n * Post EOD summary to team channel\r\n */\r\nfunction postEodSummary(submitted, missing, taskStats, perPersonCompletions, todayBlockers, notTracked) {\r\n  const spaceId = getTeamUpdatesChannel();\r\n  if (!spaceId) return;\r\n\r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'EEEE, MMMM d');\r\n\r\n  let message = `üìä **EOD Summary - ${today}**\\n\\n`;\r\n  message += `üìù Submitted: ${submitted.length}/${submitted.length + missing.length}\\n`;\r\n\r\n  if (missing.length > 0) {\r\n    message += `‚ùå Missing: ${missing.length} (${missing.map(e => e.name || e.email.split('@')[0]).join(', ')})\\n`;\r\n  }\r\n\r\n  // Add task completion stats\r\n  if (taskStats) {\r\n    message += `\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `üìã **Task Completion Today**\\n\\n`;\r\n    message += `‚úÖ Completed: ${taskStats.completed} tasks\\n`;\r\n    message += `‚û°Ô∏è Delayed to tomorrow: ${taskStats.delayed} tasks\\n`;\r\n    message += `üî¥ Still overdue: ${taskStats.stillOverdue} tasks\\n`;\r\n\r\n    if (taskStats.delayReasons && Object.keys(taskStats.delayReasons).length > 0) {\r\n      message += `\\n**Delay Reasons:**\\n`;\r\n      Object.entries(taskStats.delayReasons).forEach(([reason, count]) => {\r\n        message += `‚Ä¢ ${formatDelayReason(reason)}: ${count}\\n`;\r\n      });\r\n    }\r\n\r\n    if (taskStats.newlyOverdue && taskStats.newlyOverdue.length > 0) {\r\n      message += `\\n**Newly Overdue Today:** ${taskStats.newlyOverdue.length} tasks\\n`;\r\n      taskStats.newlyOverdue.slice(0, 3).forEach(t => {\r\n        message += `‚Ä¢ ${t.userName}: ${t.taskName}\\n`;\r\n      });\r\n    }\r\n  }\r\n\r\n  // Per-person completions (top performers)\r\n  if (perPersonCompletions && perPersonCompletions.length > 0) {\r\n    message += `\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `üèÜ **Top Completions**\\n\\n`;\r\n    perPersonCompletions.slice(0, 5).forEach(function (p) {\r\n      var delayed = p.delayed > 0 ? ` (${p.delayed} delayed)` : '';\r\n      message += `‚Ä¢ ${p.name}: ${p.completed} completed${delayed}\\n`;\r\n    });\r\n  }\r\n\r\n  // Blockers section\r\n  if (todayBlockers && todayBlockers.length > 0) {\r\n    message += `\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `üöß **Blockers Reported**\\n\\n`;\r\n    todayBlockers.forEach(function (b) {\r\n      message += `‚Ä¢ **${b.name}**: ${b.blocker}\\n`;\r\n    });\r\n  }\r\n\r\n  // Not tracked section\r\n  if (notTracked && notTracked.length > 0) {\r\n    message += `\\nüìå Not tracked: ${notTracked.map(function(m) { return m.name || m.email.split('@')[0]; }).join(', ')}\\n`;\r\n  }\r\n\r\n  sendChannelMessage(spaceId, message);\r\n}\r\n\r\n/**\r\n * Post Monday kickoff message\r\n */\r\nfunction postMondayKickoff(weekStats, lastWeekWins, activeStreaks) {\r\n  const spaceId = getTeamUpdatesChannel();\r\n  if (!spaceId) return;\r\n\r\n  const weekStart = Utilities.formatDate(new Date(), 'America/Chicago', 'MMMM d');\r\n\r\n  let message = `üóìÔ∏è **Week of ${weekStart}**\\n\\n`;\r\n  message += `Good morning team! Here's a preview of what's due this week.\\n\\n`;\r\n\r\n  // Last Week's Wins section\r\n  if (lastWeekWins) {\r\n    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `üèÜ **Last Week's Wins**\\n\\n`;\r\n\r\n    if (lastWeekWins.topCompleter && lastWeekWins.topCompleter.count > 0) {\r\n      message += `ü•á Top Performer: **${lastWeekWins.topCompleter.name}** (${lastWeekWins.topCompleter.count} tasks completed)\\n`;\r\n    }\r\n    if (lastWeekWins.totalCompleted > 0) {\r\n      message += `üìã Team Total: ${lastWeekWins.totalCompleted} tasks completed\\n`;\r\n    }\r\n    if (lastWeekWins.teamCheckinRate > 0) {\r\n      message += `‚úÖ Team Check-in Rate: ${lastWeekWins.teamCheckinRate}%\\n`;\r\n    }\r\n    message += `\\n`;\r\n  }\r\n\r\n  // Streaks on the Line section\r\n  if (activeStreaks && activeStreaks.length > 0) {\r\n    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `üî• **Streaks on the Line**\\n\\n`;\r\n    activeStreaks.slice(0, 5).forEach(function (s) {\r\n      message += `‚Ä¢ ${s.name}: ${s.streak}-day streak ‚Äî keep it going!\\n`;\r\n    });\r\n    message += `\\n`;\r\n  }\r\n\r\n  // Weekly task load\r\n  if (weekStats) {\r\n    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `üìä **Team Task Load:**\\n`;\r\n    message += `‚Ä¢ Monday: ${weekStats.monday || 0} tasks due\\n`;\r\n    message += `‚Ä¢ Tuesday: ${weekStats.tuesday || 0} tasks due\\n`;\r\n    message += `‚Ä¢ Wednesday: ${weekStats.wednesday || 0} tasks due\\n`;\r\n    message += `‚Ä¢ Thursday: ${weekStats.thursday || 0} tasks due\\n`;\r\n    message += `‚Ä¢ Friday: ${weekStats.friday || 0} tasks due\\n\\n`;\r\n\r\n    if (weekStats.overdue > 0) {\r\n      message += `‚ö†Ô∏è **Overdue from last week:** ${weekStats.overdue} tasks\\n\\n`;\r\n    }\r\n  }\r\n\r\n  message += `Individual task lists are in your DMs. Let's have a great week! üí™`;\r\n\r\n  sendChannelMessage(spaceId, message);\r\n}\r\n\r\n/**\r\n * Format delay reason for display\r\n */\r\nfunction formatDelayReason(reason) {\r\n  const labels = {\r\n    'WAITING_INPUT': 'Waiting on input',\r\n    'NO_TIME': 'No time today',\r\n    'SCOPE_CHANGED': 'Scope changed',\r\n    'OTHER': 'Other'\r\n  };\r\n  return labels[reason] || reason;\r\n}\r\n\r\n/**\r\n * Build a basic card\r\n */\r\nfunction buildCard(cardId, header, sections) {\r\n  return {\r\n    cardId: cardId,\r\n    card: {\r\n      header: header,\r\n      sections: sections\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Build header for card\r\n */\r\nfunction buildCardHeader(title, subtitle = null, imageUrl = null) {\r\n  const header = { title: title };\r\n  if (subtitle) header.subtitle = subtitle;\r\n  if (imageUrl) header.imageUrl = imageUrl;\r\n  return header;\r\n}\r\n\r\n/**\r\n * Build text widget\r\n */\r\nfunction buildTextWidget(text) {\r\n  return {\r\n    textParagraph: { text: text }\r\n  };\r\n}\r\n\r\n/**\r\n * Build decorated text widget\r\n */\r\nfunction buildDecoratedText(text, icon = null, topLabel = null) {\r\n  const widget = {\r\n    decoratedText: { text: text }\r\n  };\r\n  if (icon) widget.decoratedText.startIcon = { knownIcon: icon };\r\n  if (topLabel) widget.decoratedText.topLabel = topLabel;\r\n  return widget;\r\n}\r\n\r\n/**\r\n * Build button list widget\r\n */\r\nfunction buildButtonList(buttons) {\r\n  return {\r\n    buttonList: { buttons: buttons }\r\n  };\r\n}\r\n\r\n/**\r\n * Build a single button\r\n */\r\nfunction buildButton(text, actionFunction, parameters = {}) {\r\n  return {\r\n    text: text,\r\n    onClick: {\r\n      action: {\r\n        function: actionFunction,\r\n        parameters: Object.entries(parameters).map(([key, value]) => ({\r\n          key: key,\r\n          value: String(value)\r\n        }))\r\n      }\r\n    }\r\n  };\r\n}\r\n"
    },
    {
      "name": "ClickUp.gs",
      "type": "server_js",
      "source": "/**\r\n * ClickUp.gs - ClickUp API Integration\r\n * Handles all ClickUp API calls with caching\r\n */\r\n\r\nconst CLICKUP_BASE_URL = 'https://api.clickup.com/api/v2';\r\n\r\n/**\r\n * Get ClickUp API token from config\r\n */\r\nfunction getClickUpToken() {\r\n  return PropertiesService.getScriptProperties().getProperty('CLICKUP_API_TOKEN');\r\n}\r\n\r\n/**\r\n * Make authenticated request to ClickUp API\r\n */\r\nfunction clickUpRequest(endpoint, method = 'GET', payload = null) {\r\n  const token = getClickUpToken();\r\n\r\n  if (!token) {\r\n    console.error('ClickUp API token not configured');\r\n    return null;\r\n  }\r\n\r\n  const options = {\r\n    method: method,\r\n    headers: {\r\n      'Authorization': token,\r\n      'Content-Type': 'application/json'\r\n    },\r\n    muteHttpExceptions: true\r\n  };\r\n\r\n  if (payload) {\r\n    options.payload = JSON.stringify(payload);\r\n  }\r\n\r\n  try {\r\n    const response = UrlFetchApp.fetch(CLICKUP_BASE_URL + endpoint, options);\r\n    const code = response.getResponseCode();\r\n\r\n    if (code === 429) {\r\n      // Rate limited - wait and retry\r\n      console.warn('ClickUp rate limited, waiting 60s...');\r\n      Utilities.sleep(60000);\r\n      return clickUpRequest(endpoint, method, payload);\r\n    }\r\n\r\n    if (code >= 400) {\r\n      console.error(`ClickUp API error: ${code} - ${response.getContentText()}`);\r\n      return null;\r\n    }\r\n\r\n    return JSON.parse(response.getContentText());\r\n  } catch (error) {\r\n    console.error('ClickUp request failed:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get workspace structure (cached)\r\n */\r\nfunction getWorkspaceStructure() {\r\n  const cache = CacheService.getScriptCache();\r\n  const cached = cache.get('clickup_workspace');\r\n\r\n  if (cached) {\r\n    try {\r\n      return JSON.parse(cached);\r\n    } catch (e) {\r\n      // Invalid cache, continue to fetch fresh\r\n    }\r\n  }\r\n\r\n  console.log('Fetching fresh ClickUp workspace structure...');\r\n\r\n  // Fetch teams\r\n  const teams = clickUpRequest('/team');\r\n  if (!teams || !teams.teams || teams.teams.length === 0) {\r\n    console.error('No ClickUp teams found');\r\n    return null;\r\n  }\r\n\r\n  const teamId = teams.teams[0].id;\r\n\r\n  const structure = {\r\n    teamId: teamId,\r\n    spaces: [],\r\n    lists: [],\r\n    statuses: {},\r\n    members: {}\r\n  };\r\n\r\n  // Get spaces\r\n  const spaces = clickUpRequest(`/team/${teamId}/space`);\r\n  if (!spaces || !spaces.spaces) {\r\n    console.error('Failed to fetch ClickUp spaces');\r\n    return null;\r\n  }\r\n\r\n  for (const space of spaces.spaces) {\r\n    structure.spaces.push({\r\n      id: space.id,\r\n      name: space.name\r\n    });\r\n\r\n    // Get folders\r\n    const folders = clickUpRequest(`/space/${space.id}/folder`);\r\n    if (folders && folders.folders) {\r\n      for (const folder of folders.folders) {\r\n        for (const list of (folder.lists || [])) {\r\n          structure.lists.push({\r\n            id: list.id,\r\n            name: list.name,\r\n            folder: folder.name,\r\n            space: space.name\r\n          });\r\n          // Get statuses from list\r\n          const listDetails = clickUpRequest(`/list/${list.id}`);\r\n          if (listDetails && listDetails.statuses) {\r\n            structure.statuses[list.id] = listDetails.statuses;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Get folderless lists\r\n    const folderlessLists = clickUpRequest(`/space/${space.id}/list`);\r\n    if (folderlessLists && folderlessLists.lists) {\r\n      for (const list of folderlessLists.lists) {\r\n        structure.lists.push({\r\n          id: list.id,\r\n          name: list.name,\r\n          folder: null,\r\n          space: space.name\r\n        });\r\n        const listDetails = clickUpRequest(`/list/${list.id}`);\r\n        if (listDetails && listDetails.statuses) {\r\n          structure.statuses[list.id] = listDetails.statuses;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Get team members\r\n  const team = clickUpRequest(`/team/${teamId}`);\r\n  if (team && team.team && team.team.members) {\r\n    for (const member of team.team.members) {\r\n      if (member.user && member.user.email) {\r\n        structure.members[member.user.email.toLowerCase()] = {\r\n          id: member.user.id,\r\n          username: member.user.username,\r\n          email: member.user.email\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  // Cache for 1 hour\r\n  try {\r\n    cache.put('clickup_workspace', JSON.stringify(structure), 3600);\r\n  } catch (e) {\r\n    console.warn('Failed to cache workspace structure:', e);\r\n  }\r\n\r\n  console.log(`Cached ClickUp structure: ${structure.lists.length} lists, ${Object.keys(structure.members).length} members`);\r\n  return structure;\r\n}\r\n\r\n/**\r\n * Clear workspace cache\r\n */\r\nfunction clearClickUpCache() {\r\n  CacheService.getScriptCache().remove('clickup_workspace');\r\n}\r\n\r\n/**\r\n * Get ClickUp user ID from Google email\r\n */\r\nfunction getClickUpUserId(googleEmail) {\r\n  const structure = getWorkspaceStructure();\r\n  if (!structure) return null;\r\n\r\n  const emailLower = googleEmail.toLowerCase();\r\n\r\n  // Try direct email match\r\n  if (structure.members[emailLower]) {\r\n    return structure.members[emailLower].id;\r\n  }\r\n\r\n  // Try config sheet mapping\r\n  const config = getConfig();\r\n  const userMap = config.clickup_user_map || {};\r\n  if (userMap[googleEmail]) {\r\n    return userMap[googleEmail].clickup_user_id;\r\n  }\r\n\r\n  console.warn(`No ClickUp user found for: ${googleEmail}`);\r\n  return null;\r\n}\r\n\r\n/**\r\n * Get tasks due for a user\r\n * @param {string} googleEmail - User's Google email\r\n * @param {string} dueBy - 'today' or 'week'\r\n * @returns {Array} Array of task objects\r\n */\r\nfunction getTasksDueForUser(googleEmail, dueBy = 'today') {\r\n  const clickUpUserId = getClickUpUserId(googleEmail);\r\n  if (!clickUpUserId) {\r\n    console.warn(`Cannot fetch tasks for ${googleEmail}: no ClickUp user ID`);\r\n    return [];\r\n  }\r\n\r\n  const structure = getWorkspaceStructure();\r\n  if (!structure) return [];\r\n\r\n  const now = new Date();\r\n  const timezone = 'America/Chicago';\r\n\r\n  let dueDateLt, dueDateGt;\r\n\r\n  if (dueBy === 'today') {\r\n    // End of today\r\n    const endOfDay = new Date(now);\r\n    endOfDay.setHours(23, 59, 59, 999);\r\n    dueDateLt = endOfDay.getTime();\r\n    dueDateGt = 0; // Include all overdue\r\n  } else if (dueBy === 'week') {\r\n    // End of Friday\r\n    const friday = new Date(now);\r\n    const daysUntilFriday = (5 - now.getDay() + 7) % 7;\r\n    friday.setDate(now.getDate() + daysUntilFriday);\r\n    friday.setHours(23, 59, 59, 999);\r\n    dueDateLt = friday.getTime();\r\n\r\n    // BUG #10 fix: Include ALL overdue tasks (not just from this week)\r\n    // so Monday preview shows tasks overdue from previous weeks\r\n    dueDateGt = 0;\r\n  }\r\n\r\n  const endpoint = `/team/${structure.teamId}/task?` +\r\n    `assignees[]=${clickUpUserId}&` +\r\n    `due_date_lt=${dueDateLt}&` +\r\n    (dueDateGt > 0 ? `due_date_gt=${dueDateGt}&` : '') +\r\n    `include_closed=false&` +\r\n    `subtasks=false`;\r\n\r\n  const result = clickUpRequest(endpoint);\r\n\r\n  if (!result || !result.tasks) {\r\n    console.warn(`No tasks returned for ${googleEmail}`);\r\n    return [];\r\n  }\r\n\r\n  // Start of today for overdue calculation\r\n  const startOfToday = new Date(now);\r\n  startOfToday.setHours(0, 0, 0, 0);\r\n\r\n  // Enrich with list info and calculate overdue\r\n  return result.tasks.map(task => {\r\n    const list = structure.lists.find(l => l.id === task.list.id);\r\n    const dueDate = task.due_date ? new Date(parseInt(task.due_date)) : null;\r\n    const isOverdue = dueDate && dueDate < startOfToday;\r\n    const daysOverdue = isOverdue ? Math.floor((startOfToday - dueDate) / (1000 * 60 * 60 * 24)) : 0;\r\n\r\n    return {\r\n      id: task.id,\r\n      name: task.name,\r\n      description: task.description || '',\r\n      status: task.status?.status || 'unknown',\r\n      statusType: task.status?.type || 'open',\r\n      dueDate: dueDate,\r\n      dueDateStr: dueDate ? Utilities.formatDate(dueDate, timezone, 'EEE, MMM d') : null,\r\n      listId: task.list.id,\r\n      listName: list ? list.name : task.list.name,\r\n      folderName: list ? list.folder : null,\r\n      spaceName: list ? list.space : null,\r\n      url: task.url,\r\n      isOverdue: isOverdue,\r\n      daysOverdue: daysOverdue,\r\n      priority: task.priority?.priority || null,\r\n      timeEstimateMs: task.time_estimate || null,\r\n      timeEstimateHrs: task.time_estimate ? Math.round(task.time_estimate / 3600000 * 10) / 10 : null\r\n    };\r\n  }).sort((a, b) => {\r\n    // Sort: overdue first (by days), then by due date\r\n    if (a.isOverdue && !b.isOverdue) return -1;\r\n    if (!a.isOverdue && b.isOverdue) return 1;\r\n    if (a.isOverdue && b.isOverdue) return b.daysOverdue - a.daysOverdue;\r\n    return (a.dueDate || new Date('2099-01-01')) - (b.dueDate || new Date('2099-01-01'));\r\n  });\r\n}\r\n\r\n/**\r\n * Get statuses for a specific list.\r\n * Uses cached workspace if available, otherwise fetches just the list directly (fast).\r\n * Per-list statuses are also cached individually to avoid rate limits.\r\n */\r\nfunction _getListStatuses(listId) {\r\n  const cache = CacheService.getScriptCache();\r\n\r\n  // Try cached workspace first (no API call)\r\n  const cachedWorkspace = cache.get('clickup_workspace');\r\n  if (cachedWorkspace) {\r\n    try {\r\n      const structure = JSON.parse(cachedWorkspace);\r\n      if (structure.statuses && structure.statuses[listId]) {\r\n        return structure.statuses[listId];\r\n      }\r\n    } catch (e) { /* fall through */ }\r\n  }\r\n\r\n  // Try per-list cache (no API call)\r\n  const listCacheKey = 'clickup_list_statuses_' + listId;\r\n  const cachedList = cache.get(listCacheKey);\r\n  if (cachedList) {\r\n    try {\r\n      return JSON.parse(cachedList);\r\n    } catch (e) { /* fall through */ }\r\n  }\r\n\r\n  // No cache ‚Äî fetch just this list (1 API call, ~500ms)\r\n  console.log('Fetching statuses for list ' + listId + ' directly (no full workspace crawl)');\r\n  const listDetails = clickUpRequest('/list/' + listId);\r\n  const statuses = (listDetails && listDetails.statuses) ? listDetails.statuses : [];\r\n\r\n  // Cache per-list statuses for 1 hour\r\n  try {\r\n    cache.put(listCacheKey, JSON.stringify(statuses), 3600);\r\n  } catch (e) {\r\n    console.warn('Failed to cache list statuses:', e);\r\n  }\r\n\r\n  return statuses;\r\n}\r\n\r\n/**\r\n * Get closed status for a list\r\n */\r\nfunction getClosedStatus(listId) {\r\n  const statuses = _getListStatuses(listId);\r\n  const closed = statuses.find(s => s.type === 'closed');\r\n  return closed ? closed.status : 'complete';\r\n}\r\n\r\n/**\r\n * Get in-progress status for a list\r\n */\r\nfunction getInProgressStatus(listId) {\r\n  const statuses = _getListStatuses(listId);\r\n  var inProgress = statuses.find(s =>\r\n    s.status.toLowerCase().includes('progress') || s.status.toLowerCase().includes('working')\r\n  );\r\n  if (inProgress == undefined) inProgress = statuses.find(s => s.type === 'custom' && s.orderindex > 0);\r\n  return inProgress ? inProgress.status : 'in progress';\r\n}\r\n\r\n/**\r\n * Update task status\r\n */\r\nfunction updateTaskStatus(taskId, newStatus) {\r\n  return clickUpRequest(`/task/${taskId}`, 'PUT', {\r\n    status: newStatus\r\n  });\r\n}\r\n\r\n/**\r\n * Update task due date\r\n */\r\nfunction updateTaskDueDate(taskId, newDueDate) {\r\n  return clickUpRequest(`/task/${taskId}`, 'PUT', {\r\n    due_date: newDueDate.getTime(),\r\n    due_date_time: false\r\n  });\r\n}\r\n\r\n/**\r\n * Add comment to task\r\n */\r\nfunction addTaskComment(taskId, comment) {\r\n  return clickUpRequest(`/task/${taskId}/comment`, 'POST', {\r\n    comment_text: comment\r\n  });\r\n}\r\n\r\n/**\r\n * Mark task complete\r\n */\r\nfunction markTaskComplete(taskId, listId, userName) {\r\n  const closedStatus = getClosedStatus(listId);\r\n  const result = updateTaskStatus(taskId, closedStatus);\r\n\r\n  if (result) {\r\n    const config = getConfig();\r\n    if (config.clickup_config.add_comments !== false) {\r\n      const timestamp = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd HH:mm:ss z');\r\n      addTaskComment(taskId,\r\n        `‚úÖ Marked complete via Daily Check-in Bot\\nBy: ${userName}\\nDate: ${timestamp}`\r\n      );\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Move task to tomorrow\r\n */\r\nfunction moveTaskToTomorrow(taskId) {\r\n  const tomorrow = new Date();\r\n  tomorrow.setDate(tomorrow.getDate() + 1);\r\n  tomorrow.setHours(17, 0, 0, 0); // 5 PM tomorrow\r\n\r\n  return updateTaskDueDate(taskId, tomorrow);\r\n}\r\n\r\n/**\r\n * Set task to in progress\r\n */\r\nfunction setTaskInProgress(taskId, listId) {\r\n  const inProgressStatus = getInProgressStatus(listId);\r\n  return updateTaskStatus(taskId, inProgressStatus);\r\n}\r\n\r\n/**\r\n * Get task by ID\r\n */\r\nfunction getTaskById(taskId) {\r\n  return clickUpRequest(`/task/${taskId}`);\r\n}\r\n\r\n/**\r\n * Get all overdue tasks for the team\r\n */\r\nfunction getAllOverdueTasks() {\r\n  const structure = getWorkspaceStructure();\r\n  if (!structure) return [];\r\n\r\n  const now = new Date();\r\n  const startOfToday = new Date(now);\r\n  startOfToday.setHours(0, 0, 0, 0);\r\n\r\n  const endpoint = `/team/${structure.teamId}/task?` +\r\n    `due_date_lt=${startOfToday.getTime()}&` +\r\n    `include_closed=false&` +\r\n    `subtasks=false`;\r\n\r\n  const result = clickUpRequest(endpoint);\r\n\r\n  if (!result || !result.tasks) return [];\r\n\r\n  return result.tasks.map(task => {\r\n    const dueDate = task.due_date ? new Date(parseInt(task.due_date)) : null;\r\n    const daysOverdue = dueDate ? Math.floor((startOfToday - dueDate) / (1000 * 60 * 60 * 24)) : 0;\r\n\r\n    // Find assignee email\r\n    let assigneeEmail = null;\r\n    if (task.assignees && task.assignees.length > 0) {\r\n      const assignee = task.assignees[0];\r\n      // Reverse lookup from structure.members\r\n      for (const [email, member] of Object.entries(structure.members)) {\r\n        if (member.id === assignee.id) {\r\n          assigneeEmail = email;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      id: task.id,\r\n      name: task.name,\r\n      listId: task.list.id,\r\n      listName: task.list.name,\r\n      dueDate: dueDate,\r\n      daysOverdue: daysOverdue,\r\n      isChronic: daysOverdue >= 3,\r\n      assigneeEmail: assigneeEmail,\r\n      url: task.url\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * Get task delay count (how many times it's been moved)\r\n */\r\nfunction getTaskDelayCount(taskId) {\r\n  const projectId = getProjectId();\r\n\r\n  const safeTaskId = sanitizeForBQ(taskId);\r\n  const query = `\r\n    SELECT COUNT(*) as count\r\n    FROM \\`${projectId}.checkin_bot.task_delays\\`\r\n    WHERE task_id = '${safeTaskId}'\r\n  `;\r\n\r\n  const result = runBigQueryQuery(query);\r\n  return result.length > 0 ? parseInt(result[0].count) : 0;\r\n}\r\n"
    },
    {
      "name": "ClickUpCards.gs",
      "type": "server_js",
      "source": "/**\r\n * ClickUpCards.gs - Task Card Builders & Action Handlers\r\n * Builds Google Chat cards for ClickUp tasks and handles button actions\r\n */\r\n\r\n/**\r\n * Build a task card for EOD with action buttons\r\n */\r\nfunction buildTaskCard(task, index) {\r\n  const overdueText = task.isOverdue\r\n    ? `‚ö†Ô∏è OVERDUE (${task.daysOverdue} days)`\r\n    : `Due: ${task.dueDateStr || 'Today'}`;\r\n\r\n  const severityIcon = task.daysOverdue >= 3 ? 'üî¥' : (task.daysOverdue >= 1 ? 'üü†' : 'üìã');\r\n\r\n  return {\r\n    cardId: `task_${task.id}_${index}`,\r\n    card: {\r\n      header: {\r\n        title: `${severityIcon} ${task.name}`,\r\n        subtitle: `üìÅ ${task.listName}`\r\n      },\r\n      sections: [\r\n        {\r\n          widgets: [\r\n            {\r\n              decoratedText: {\r\n                text: overdueText,\r\n                startIcon: { knownIcon: 'CLOCK' }\r\n              }\r\n            },\r\n            {\r\n              buttonList: {\r\n                buttons: [\r\n                  {\r\n                    text: '‚úÖ Done',\r\n                    onClick: {\r\n                      action: {\r\n                        function: 'handleTaskAction',\r\n                        parameters: [\r\n                          { key: 'taskId', value: task.id },\r\n                          { key: 'listId', value: task.listId },\r\n                          { key: 'taskName', value: task.name },\r\n                          { key: 'action', value: 'COMPLETE' },\r\n                          { key: 'source', value: task.source || 'clickup' }\r\n                        ]\r\n                      }\r\n                    }\r\n                  },\r\n                  {\r\n                    text: 'üîÑ In Progress',\r\n                    onClick: {\r\n                      action: {\r\n                        function: 'handleTaskAction',\r\n                        parameters: [\r\n                          { key: 'taskId', value: task.id },\r\n                          { key: 'listId', value: task.listId },\r\n                          { key: 'taskName', value: task.name },\r\n                          { key: 'action', value: 'IN_PROGRESS' },\r\n                          { key: 'source', value: task.source || 'clickup' }\r\n                        ]\r\n                      }\r\n                    }\r\n                  },\r\n                  {\r\n                    text: '‚û°Ô∏è Tomorrow',\r\n                    onClick: {\r\n                      action: {\r\n                        function: 'handleDelayAction',\r\n                        parameters: [\r\n                          { key: 'taskId', value: task.id },\r\n                          { key: 'listId', value: task.listId },\r\n                          { key: 'taskName', value: task.name },\r\n                          { key: 'source', value: task.source || 'clickup' }\r\n                        ]\r\n                      }\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Build delay reason selection card\r\n */\r\nfunction buildDelayReasonCard(taskId, listId, taskName, source) {\r\n  var taskSource = source || 'clickup';\r\n  return {\r\n    cardId: `delay_reason_${taskId}`,\r\n    card: {\r\n      header: {\r\n        title: '‚û°Ô∏è Moving to Tomorrow',\r\n        subtitle: taskName\r\n      },\r\n      sections: [\r\n        {\r\n          widgets: [\r\n            {\r\n              textParagraph: {\r\n                text: 'Quick note - why is this moving?'\r\n              }\r\n            },\r\n            {\r\n              buttonList: {\r\n                buttons: [\r\n                  {\r\n                    text: 'üì¶ Waiting on input',\r\n                    onClick: {\r\n                      action: {\r\n                        function: 'handleDelayReasonSelected',\r\n                        parameters: [\r\n                          { key: 'taskId', value: taskId },\r\n                          { key: 'listId', value: listId },\r\n                          { key: 'taskName', value: taskName },\r\n                          { key: 'reason', value: 'WAITING_INPUT' },\r\n                          { key: 'source', value: taskSource }\r\n                        ]\r\n                      }\r\n                    }\r\n                  },\r\n                  {\r\n                    text: '‚è∞ No time today',\r\n                    onClick: {\r\n                      action: {\r\n                        function: 'handleDelayReasonSelected',\r\n                        parameters: [\r\n                          { key: 'taskId', value: taskId },\r\n                          { key: 'listId', value: listId },\r\n                          { key: 'taskName', value: taskName },\r\n                          { key: 'reason', value: 'NO_TIME' },\r\n                          { key: 'source', value: taskSource }\r\n                        ]\r\n                      }\r\n                    }\r\n                  },\r\n                  {\r\n                    text: 'üîÑ Scope changed',\r\n                    onClick: {\r\n                      action: {\r\n                        function: 'handleDelayReasonSelected',\r\n                        parameters: [\r\n                          { key: 'taskId', value: taskId },\r\n                          { key: 'listId', value: listId },\r\n                          { key: 'taskName', value: taskName },\r\n                          { key: 'reason', value: 'SCOPE_CHANGED' },\r\n                          { key: 'source', value: taskSource }\r\n                        ]\r\n                      }\r\n                    }\r\n                  },\r\n                  {\r\n                    text: '‚ùì Other',\r\n                    onClick: {\r\n                      action: {\r\n                        function: 'handleDelayReasonSelected',\r\n                        parameters: [\r\n                          { key: 'taskId', value: taskId },\r\n                          { key: 'listId', value: listId },\r\n                          { key: 'taskName', value: taskName },\r\n                          { key: 'reason', value: 'OTHER' },\r\n                          { key: 'source', value: taskSource }\r\n                        ]\r\n                      }\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Build morning task list message (text, no action buttons)\r\n */\r\nfunction buildMorningTaskMessage(tasks, userName) {\r\n  const todayTasks = tasks.filter(t => !t.isOverdue);\r\n  const overdueTasks = tasks.filter(t => t.isOverdue);\r\n\r\n  let message = `Good morning${userName ? ', ' + userName : ''}! üëã\\n\\n`;\r\n\r\n  if (todayTasks.length > 0) {\r\n    message += `üìã **Tasks due today:** ${todayTasks.length}\\n`;\r\n    todayTasks.forEach((task, i) => {\r\n      message += `${i + 1}. ${task.name}\\n   üìÅ ${task.listName}\\n`;\r\n    });\r\n    message += '\\n';\r\n  }\r\n\r\n  if (overdueTasks.length > 0) {\r\n    message += `‚ö†Ô∏è **OVERDUE (Action Required):** ${overdueTasks.length}\\n`;\r\n    overdueTasks.forEach((task, i) => {\r\n      const severity = task.daysOverdue >= 3 ? 'üî¥' : 'üü†';\r\n      message += `${severity} ${task.name}\\n`;\r\n      message += `   üìÅ ${task.listName} ‚Ä¢ Was due: ${task.dueDateStr} (${task.daysOverdue} days ago)\\n`;\r\n    });\r\n    message += '\\nThese need immediate attention. Please prioritize or update status.\\n\\n';\r\n  }\r\n\r\n  if (tasks.length === 0) {\r\n    message += `‚úÖ No tasks due today in ClickUp.\\n\\n`;\r\n  }\r\n\r\n  message += `Reply \"here\" to confirm you're online, or share your #1 priority.`;\r\n\r\n  return message;\r\n}\r\n\r\n/**\r\n * Build EOD task message with cards\r\n */\r\nfunction buildEodTaskMessage(tasks) {\r\n  if (!tasks || tasks.length === 0) {\r\n    return {\r\n      text: `Time for your EOD report! üìù\\n\\n‚úÖ No tasks were due today.\\n\\nPlease share:\\n‚Ä¢ Any tasks you completed\\n‚Ä¢ Blockers (if any)\\n‚Ä¢ Tomorrow's priority`,\r\n      cardsV2: null\r\n    };\r\n  }\r\n\r\n  const cards = tasks.slice(0, 10).map((task, i) => buildTaskCard(task, i)); // Limit to 10 cards\r\n\r\n  let text = `Time for your EOD report! üìù\\n\\nüìã **Tasks that were due today:** ${tasks.length}`;\r\n\r\n  if (tasks.length > 10) {\r\n    text += `\\n\\n(Showing first 10 of ${tasks.length} tasks)`;\r\n  }\r\n\r\n  return {\r\n    text: text,\r\n    cardsV2: cards,\r\n    followUpText: `\\nAfter updating tasks above, please also share:\\n‚Ä¢ Any **additional tasks** you completed (not in ClickUp)\\n‚Ä¢ **Blockers** (if any)\\n‚Ä¢ **Tomorrow's priority**`\r\n  };\r\n}\r\n\r\n/**\r\n * Build weekly task preview for Monday\r\n */\r\nfunction buildWeeklyTaskPreview(tasks, userName) {\r\n  const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];\r\n  const today = new Date();\r\n  const tasksByDay = {};\r\n  const overdue = [];\r\n\r\n  // Initialize days\r\n  days.forEach(day => tasksByDay[day] = []);\r\n\r\n  // Sort tasks by day\r\n  tasks.forEach(task => {\r\n    if (task.isOverdue) {\r\n      overdue.push(task);\r\n    } else if (task.dueDate) {\r\n      const dayIndex = task.dueDate.getDay() - 1; // Monday = 0\r\n      if (dayIndex >= 0 && dayIndex < 5) {\r\n        tasksByDay[days[dayIndex]].push(task);\r\n      }\r\n    }\r\n  });\r\n\r\n  let message = `Good morning${userName ? ', ' + userName : ''}! üëã\\n\\n`;\r\n  message += `üóìÔ∏è **Your tasks this week:**\\n\\n`;\r\n\r\n  days.forEach((day, index) => {\r\n    const dayTasks = tasksByDay[day];\r\n    const isToday = index === (today.getDay() - 1);\r\n\r\n    message += `**${day}${isToday ? ' (Today)' : ''}:**\\n`;\r\n    if (dayTasks.length === 0) {\r\n      message += `‚Ä¢ (none)\\n`;\r\n    } else {\r\n      dayTasks.forEach(task => {\r\n        message += `‚Ä¢ ${task.name}\\n`;\r\n      });\r\n    }\r\n    message += '\\n';\r\n  });\r\n\r\n  if (overdue.length > 0) {\r\n    message += `‚ö†Ô∏è **Overdue from last week:**\\n`;\r\n    overdue.forEach(task => {\r\n      const severity = task.daysOverdue >= 3 ? 'üî¥' : 'üü†';\r\n      message += `${severity} ${task.name} (${task.daysOverdue} days overdue)\\n`;\r\n    });\r\n    message += '\\n';\r\n  }\r\n\r\n  message += `Reply \"here\" to confirm you're online!`;\r\n\r\n  return message;\r\n}\r\n\r\n/**\r\n * Safely extract parameters from card action event (BUG #8 fix)\r\n * Handles both array format and object format from Google Chat\r\n */\r\nfunction _extractCardParams(event) {\r\n  var params = {};\r\n\r\n  // Try common.parameters (array format)\r\n  var commonParams = event.commonEventObject && event.commonEventObject.parameters;\r\n  if (commonParams) {\r\n    if (Array.isArray(commonParams)) {\r\n      commonParams.forEach(function (p) { params[p.key] = p.value; });\r\n    } else if (typeof commonParams === 'object') {\r\n      // Object format: { key1: value1, key2: value2 }\r\n      params = commonParams;\r\n    }\r\n  }\r\n\r\n  // Try action.parameters (array format)\r\n  var actionParams = event.action && event.action.parameters;\r\n  if (actionParams && Object.keys(params).length === 0) {\r\n    if (Array.isArray(actionParams)) {\r\n      actionParams.forEach(function (p) { params[p.key] = p.value; });\r\n    } else if (typeof actionParams === 'object') {\r\n      params = actionParams;\r\n    }\r\n  }\r\n\r\n  return params;\r\n}\r\n\r\n/**\r\n * Handle task action button click\r\n */\r\nfunction handleTaskAction(event) {\r\n  var params = _extractCardParams(event);\r\n\r\n  console.log('handleTaskAction event = ', JSON.stringify(event));\r\n  console.log('handleTaskAction params = ', JSON.stringify(params));\r\n  const taskId = params.taskId;\r\n  const listId = params.listId;\r\n  const taskName = params.taskName;\r\n  const action = params.action;\r\n  const source = params.source || 'clickup';\r\n  const userEmail = event.chat.user.email;\r\n  const userName = event.chat.user.displayName;\r\n\r\n  // Route Odoo tasks to Odoo handler\r\n  if (source === 'odoo') {\r\n    return createChatResponse(handleOdooTaskAction(taskId, taskName, action, listId, event));\r\n  }\r\n\r\n  let result;\r\n  let responseText;\r\n  let newStatus = null;\r\n\r\n  // Get current task state for logging (ClickUp)\r\n  const task = getTaskById(taskId);\r\n  const oldStatus = task ? task.status?.status : null;\r\n  const oldDueDate = task && task.due_date ? new Date(parseInt(task.due_date)) : null;\r\n\r\n  switch (action) {\r\n    case 'COMPLETE':\r\n      result = markTaskComplete(taskId, listId, userName);\r\n      newStatus = getClosedStatus(listId);\r\n      responseText = result\r\n        ? `‚úÖ Marked complete: \"${taskName}\"`\r\n        : `‚ùå Error updating task. Please try again.`;\r\n      break;\r\n\r\n    case 'IN_PROGRESS':\r\n      result = setTaskInProgress(taskId, listId);\r\n      newStatus = getInProgressStatus(listId);\r\n      responseText = result\r\n        ? `üîÑ Updated to In Progress: \"${taskName}\"`\r\n        : `‚ùå Error updating task. Please try again.`;\r\n      break;\r\n\r\n    default:\r\n      responseText = `‚ùå Unknown action`;\r\n      result = false;\r\n  }\r\n\r\n  // Log to BigQuery\r\n  logTaskAction(\r\n    userEmail,\r\n    taskId,\r\n    taskName,\r\n    listId,\r\n    task?.list?.name || '',\r\n    action,\r\n    oldStatus,\r\n    newStatus,\r\n    oldDueDate ? Utilities.formatDate(oldDueDate, 'America/Chicago', 'yyyy-MM-dd') : null,\r\n    null,\r\n    result ? 'SUCCESS' : 'FAILED',\r\n    'clickup'\r\n  );\r\n\r\n  return createChatResponse({\r\n    actionResponse: {\r\n      type: 'UPDATE_MESSAGE'\r\n    },\r\n    text: responseText\r\n  });\r\n}\r\n\r\n/**\r\n * Handle delay button click - show reason selection\r\n */\r\nfunction handleDelayAction(event) {\r\n  var params = _extractCardParams(event);\r\n\r\n  const card = buildDelayReasonCard(params.taskId, params.listId, params.taskName, params.source || 'clickup');\r\n\r\n  return createChatResponse({\r\n    actionResponse: {\r\n      type: 'UPDATE_MESSAGE'\r\n    },\r\n    cardsV2: [card]\r\n  });\r\n}\r\n\r\n/**\r\n * Handle delay reason selection\r\n */\r\nfunction handleDelayReasonSelected(event) {\r\n  var params = _extractCardParams(event);\r\n\r\n  console.log('handleDelayReasonSelected event = ', JSON.stringify(event));\r\n  console.log('handleDelayReasonSelected params = ', JSON.stringify(params));\r\n  const taskId = params.taskId;\r\n  const listId = params.listId;\r\n  const taskName = params.taskName;\r\n  const reason = params.reason;\r\n  const source = params.source || 'clickup';\r\n  const userEmail = event.chat.user.email;\r\n\r\n  // Handle Odoo task delay\r\n  if (source === 'odoo') {\r\n    var tomorrow = new Date();\r\n    tomorrow.setDate(tomorrow.getDate() + 1);\r\n    var tomorrowStr = Utilities.formatDate(tomorrow, 'America/Chicago', 'yyyy-MM-dd');\r\n    var numericId = parseInt(taskId, 10);\r\n    updateTaskDeadline(numericId, tomorrowStr);\r\n\r\n    var delayCount = getTaskDelayCount(taskId) + 1;\r\n    logTaskDelay(userEmail, taskId, taskName, null, tomorrowStr, reason, delayCount, 'odoo');\r\n    logTaskAction(userEmail, taskId, taskName, listId, '', 'TOMORROW', null, null, null, tomorrowStr, 'SUCCESS', 'odoo');\r\n\r\n    if (delayCount >= 3) {\r\n      sendRepeatDelayAlert(userEmail, taskId, taskName, delayCount);\r\n    }\r\n\r\n    var reasonText = formatDelayReason(reason);\r\n    return createChatResponse({\r\n      actionResponse: { type: 'UPDATE_MESSAGE' },\r\n      text: '‚û°Ô∏è Moved to tomorrow: \"' + taskName + '\"\\nüìù Reason: ' + reasonText\r\n    });\r\n  }\r\n\r\n  // ClickUp task delay\r\n  const task = getTaskById(taskId);\r\n  const oldDueDate = task && task.due_date ? new Date(parseInt(task.due_date)) : null;\r\n\r\n  // Move task to tomorrow\r\n  const result = moveTaskToTomorrow(taskId);\r\n\r\n  if (result) {\r\n    // Get delay count\r\n    const delayCount = getTaskDelayCount(taskId) + 1;\r\n\r\n    // Calculate new due date\r\n    const tomorrow = new Date();\r\n    tomorrow.setDate(tomorrow.getDate() + 1);\r\n\r\n    // Log delay\r\n    logTaskDelay(\r\n      userEmail,\r\n      taskId,\r\n      taskName,\r\n      oldDueDate ? Utilities.formatDate(oldDueDate, 'America/Chicago', 'yyyy-MM-dd') : null,\r\n      Utilities.formatDate(tomorrow, 'America/Chicago', 'yyyy-MM-dd'),\r\n      reason,\r\n      delayCount,\r\n      'clickup'\r\n    );\r\n\r\n    // Log task action\r\n    logTaskAction(\r\n      userEmail,\r\n      taskId,\r\n      taskName,\r\n      listId,\r\n      task?.list?.name || '',\r\n      'TOMORROW',\r\n      null,\r\n      null,\r\n      oldDueDate ? Utilities.formatDate(oldDueDate, 'America/Chicago', 'yyyy-MM-dd') : null,\r\n      Utilities.formatDate(tomorrow, 'America/Chicago', 'yyyy-MM-dd'),\r\n      'SUCCESS',\r\n      'clickup'\r\n    );\r\n\r\n    // Check for repeat delay alert\r\n    if (delayCount >= 3) {\r\n      sendRepeatDelayAlert(userEmail, taskId, taskName, delayCount);\r\n    }\r\n\r\n    const reasonText = formatDelayReason(reason);\r\n    return createChatResponse({\r\n      actionResponse: {\r\n        type: 'UPDATE_MESSAGE'\r\n      },\r\n      text: `‚û°Ô∏è Moved to tomorrow: \"${taskName}\"\\nüìù Reason: ${reasonText}`\r\n    });\r\n  } else {\r\n    return createChatResponse({\r\n      actionResponse: {\r\n        type: 'UPDATE_MESSAGE'\r\n      },\r\n      text: `‚ùå Error moving task. Please try again.`\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Send alert for repeat delayed task\r\n */\r\nfunction sendRepeatDelayAlert(userEmail, taskId, taskName, delayCount) {\r\n  const config = getConfig();\r\n  const recipients = getReportRecipients('escalation');\r\n\r\n  const task = getTaskById(taskId);\r\n  const taskUrl = task ? task.url : '';\r\n\r\n  const message = `‚ö†Ô∏è **Repeated Delay Alert**\\n\\n` +\r\n    `Task: \"${taskName}\"\\n` +\r\n    `Assigned to: ${userEmail}\\n\\n` +\r\n    `This task has been moved to \"tomorrow\" **${delayCount} times**.\\n\\n` +\r\n    `Pattern suggests this task may need reassignment or the assignee needs support.\\n\\n` +\r\n    (taskUrl ? `[View in ClickUp](${taskUrl})` : '');\r\n\r\n  // Send to escalation recipients\r\n  recipients.forEach(recipient => {\r\n    if (recipient !== userEmail) { // Don't alert the user themselves\r\n      sendDirectMessage(recipient, message);\r\n    }\r\n  });\r\n\r\n  // Also notify the user\r\n  sendDirectMessage(userEmail,\r\n    `‚ö†Ô∏è **Heads up:** You've moved \"${taskName}\" ${delayCount} times.\\n\\n` +\r\n    `If you're blocked or need help, please reach out to your manager.`\r\n  );\r\n}\r\n\r\n/**\r\n * Handle task actions for Odoo-sourced tasks\r\n * Routes COMPLETE, IN_PROGRESS, and TOMORROW to Odoo APIs\r\n */\r\nfunction handleOdooTaskAction(taskId, taskName, actionType, listId, event) {\r\n  var numericId = parseInt(taskId, 10);\r\n  var userEmail = event.user.email;\r\n\r\n  if (actionType === 'COMPLETE') {\r\n    // Find the \"Done\" stage for this task's project\r\n    try {\r\n      var stages = getTaskStages();\r\n      var doneStage = stages.find(function (s) { return s.fold === true; })\r\n        || stages.find(function (s) { return s.name.toLowerCase().includes('done'); });\r\n\r\n      if (doneStage) {\r\n        updateTaskStage(numericId, doneStage.id);\r\n      }\r\n    } catch (err) {\r\n      console.error('Odoo stage update error:', err.message);\r\n    }\r\n\r\n    logTaskAction(userEmail, taskId, taskName, listId, '', 'COMPLETE', null, null, null, null, 'SUCCESS', 'odoo');\r\n\r\n    return {\r\n      actionResponse: { type: 'UPDATE_MESSAGE' },\r\n      text: '‚úÖ Marked complete: \"' + taskName + '\"'\r\n    };\r\n\r\n  } else if (actionType === 'IN_PROGRESS') {\r\n    try {\r\n      var stages = getTaskStages();\r\n      var ipStage = stages.find(function (s) { return s.name.toLowerCase().includes('progress'); });\r\n      if (ipStage) {\r\n        updateTaskStage(numericId, ipStage.id);\r\n      }\r\n    } catch (err) {\r\n      console.error('Odoo stage update error:', err.message);\r\n    }\r\n\r\n    logTaskAction(userEmail, taskId, taskName, listId, '', 'IN_PROGRESS', null, null, null, null, 'SUCCESS', 'odoo');\r\n\r\n    return {\r\n      actionResponse: { type: 'UPDATE_MESSAGE' },\r\n      text: 'üîÑ Updated to In Progress: \"' + taskName + '\"'\r\n    };\r\n\r\n  } else {\r\n    return {\r\n      actionResponse: { type: 'UPDATE_MESSAGE' },\r\n      text: '‚ùå Unknown action for Odoo task'\r\n    };\r\n  }\r\n}\r\n\r\n// formatDelayReason is defined in Chat.js (BUG #13 fix - removed duplicate)\r\n"
    },
    {
      "name": "ClickUpSync.gs",
      "type": "server_js",
      "source": "/**\r\n * ClickUpSync.gs - Scheduled Sync & Snapshot Functions\r\n * Handles daily ClickUp syncs and metric snapshots\r\n */\r\n\r\n/**\r\n * Daily ClickUp sync - runs at 6:15 AM\r\n * Refreshes cache and prepares task data for the day\r\n */\r\nfunction dailyClickUpSync() {\r\n  console.log('Starting daily ClickUp sync...');\r\n  \r\n  if (!isWorkday()) {\r\n    console.log('Not a workday, skipping ClickUp sync');\r\n    return;\r\n  }\r\n  \r\n  const config = getConfig();\r\n  if (!config.clickup_config.enabled) {\r\n    console.log('ClickUp integration disabled');\r\n    return;\r\n  }\r\n  \r\n  // Clear cache to force fresh data\r\n  clearClickUpCache();\r\n  \r\n  // Refresh workspace structure\r\n  const structure = getWorkspaceStructure();\r\n  \r\n  if (!structure) {\r\n    logSystemEvent('CLICKUP_SYNC', 'FAILED', { error: 'Could not fetch workspace structure' });\r\n    \r\n    // Alert manager\r\n    sendDirectMessage(\r\n      config.settings.manager_email,\r\n      '‚ö†Ô∏è **ClickUp Sync Failed**\\n\\nCould not connect to ClickUp API. Task features will be limited today.'\r\n    );\r\n    return;\r\n  }\r\n  \r\n  console.log(`Synced ${structure.lists.length} lists, ${Object.keys(structure.members).length} members`);\r\n  \r\n  // Get all working team members\r\n  const teamMembers = getCachedWorkingEmployees();\r\n  \r\n  // Pre-fetch tasks for metrics\r\n  let totalTasksToday = 0;\r\n  let totalOverdue = 0;\r\n  const overdueByPerson = {};\r\n  \r\n  for (const member of teamMembers) {\r\n    const tasks = getTasksDueForUser(member.email, 'today');\r\n    totalTasksToday += tasks.filter(t => !t.isOverdue).length;\r\n    \r\n    const overdue = tasks.filter(t => t.isOverdue);\r\n    totalOverdue += overdue.length;\r\n    \r\n    if (overdue.length > 0) {\r\n      overdueByPerson[member.email] = {\r\n        count: overdue.length,\r\n        maxDays: Math.max(...overdue.map(t => t.daysOverdue)),\r\n        tasks: overdue\r\n      };\r\n    }\r\n  }\r\n  \r\n  // Log sync completion\r\n  logSystemEvent('CLICKUP_SYNC', 'SUCCESS', {\r\n    lists: structure.lists.length,\r\n    members: Object.keys(structure.members).length,\r\n    tasksToday: totalTasksToday,\r\n    totalOverdue: totalOverdue,\r\n    peopleWithOverdue: Object.keys(overdueByPerson).length\r\n  });\r\n  \r\n  console.log(`ClickUp sync complete: ${totalTasksToday} tasks due today, ${totalOverdue} overdue`);\r\n  \r\n  // Store overdue snapshot\r\n  saveOverdueSnapshot(overdueByPerson);\r\n  \r\n  // Check for chronic overdue alerts\r\n  checkChronicOverdueAlerts();\r\n  \r\n  // Check team overdue threshold\r\n  checkTeamOverdueThreshold();\r\n}\r\n\r\n/**\r\n * Save overdue snapshot to BigQuery\r\n */\r\nfunction saveOverdueSnapshot(overdueByPerson) {\r\n  const snapshots = [];\r\n  \r\n  for (const [email, data] of Object.entries(overdueByPerson)) {\r\n    for (const task of data.tasks) {\r\n      snapshots.push({\r\n        user_email: email,\r\n        task_id: task.id,\r\n        task_name: task.name,\r\n        list_name: task.listName,\r\n        original_due_date: task.dueDate ? Utilities.formatDate(task.dueDate, 'America/Chicago', 'yyyy-MM-dd') : null,\r\n        days_overdue: task.daysOverdue,\r\n        delay_count: getTaskDelayCount(task.id)\r\n      });\r\n    }\r\n  }\r\n  \r\n  if (snapshots.length > 0) {\r\n    logOverdueSnapshot(snapshots);\r\n  }\r\n}\r\n\r\n/**\r\n * Daily ClickUp snapshot - runs at 5:15 PM\r\n * Saves completion metrics to BigQuery\r\n */\r\nfunction dailyClickUpSnapshot() {\r\n  console.log('Creating daily ClickUp snapshot...');\r\n  \r\n  if (!isWorkday()) {\r\n    console.log('Not a workday, skipping ClickUp snapshot');\r\n    return;\r\n  }\r\n  \r\n  const config = getConfig();\r\n  if (!config.clickup_config.enabled) {\r\n    return;\r\n  }\r\n  \r\n  const today = new Date();\r\n  const teamMembers = getCachedWorkingEmployees();\r\n  const rows = [];\r\n  \r\n  for (const member of teamMembers) {\r\n    // Get tasks that were due today\r\n    const tasksDueToday = getTasksDueForUser(member.email, 'today');\r\n    \r\n    // Get today's actions from BigQuery\r\n    const todayActions = getUserTodayTaskActions(member.email);\r\n    \r\n    let completed = 0;\r\n    let moved = 0;\r\n    let inProgress = 0;\r\n    \r\n    todayActions.forEach(action => {\r\n      if (action.action_type === 'COMPLETE') completed = parseInt(action.count);\r\n      if (action.action_type === 'TOMORROW') moved = parseInt(action.count);\r\n      if (action.action_type === 'IN_PROGRESS') inProgress = parseInt(action.count);\r\n    });\r\n    \r\n    const overdue = tasksDueToday.filter(t => t.isOverdue).length;\r\n    const totalDue = tasksDueToday.length;\r\n    \r\n    rows.push({\r\n      snapshot_date: Utilities.formatDate(today, 'America/Chicago', 'yyyy-MM-dd'),\r\n      user_email: member.email,\r\n      tasks_due_today: totalDue,\r\n      tasks_overdue: overdue,\r\n      tasks_due_this_week: getTasksDueForUser(member.email, 'week').length,\r\n      tasks_completed_today: completed,\r\n      tasks_moved_tomorrow: moved,\r\n      completion_rate: totalDue > 0 ? (completed / totalDue) : 1.0\r\n    });\r\n  }\r\n  \r\n  // Insert into BigQuery\r\n  logClickUpDailySnapshot(rows);\r\n  \r\n  logSystemEvent('CLICKUP_SNAPSHOT', 'SUCCESS', { members: rows.length });\r\n  console.log(`Snapshot saved for ${rows.length} team members`);\r\n}\r\n\r\n/**\r\n * Get team task stats for channel summary\r\n */\r\nfunction getTeamTaskStats() {\r\n  const teamMembers = getCachedWorkingEmployees();\r\n  \r\n  let completed = 0;\r\n  let delayed = 0;\r\n  let stillOverdue = 0;\r\n  const delayReasons = {};\r\n  const newlyOverdue = [];\r\n  \r\n  for (const member of teamMembers) {\r\n    const actions = getUserTodayTaskActions(member.email);\r\n    \r\n    actions.forEach(action => {\r\n      if (action.action_type === 'COMPLETE') completed += parseInt(action.count);\r\n      if (action.action_type === 'TOMORROW') delayed += parseInt(action.count);\r\n    });\r\n    \r\n    // Check for still overdue\r\n    const tasks = getTasksDueForUser(member.email, 'today');\r\n    const overdue = tasks.filter(t => t.isOverdue);\r\n    stillOverdue += overdue.length;\r\n  }\r\n  \r\n  // Get delay reasons from BigQuery\r\n  const reasons = getWeeklyDelayReasons();\r\n  reasons.forEach(r => {\r\n    delayReasons[r.delay_reason] = parseInt(r.count);\r\n  });\r\n  \r\n  return {\r\n    completed,\r\n    delayed,\r\n    stillOverdue,\r\n    delayReasons,\r\n    newlyOverdue\r\n  };\r\n}\r\n\r\n/**\r\n * Get team overdue stats for morning summary\r\n */\r\nfunction getTeamOverdueStats() {\r\n  const summary = getTeamOverdueSummary();\r\n  \r\n  if (!summary || summary.length === 0) {\r\n    return null;\r\n  }\r\n  \r\n  let totalOverdue = 0;\r\n  let chronicCount = 0;\r\n  const topOffenders = [];\r\n  \r\n  summary.forEach(row => {\r\n    const count = parseInt(row.total_overdue);\r\n    totalOverdue += count;\r\n    chronicCount += parseInt(row.chronic_count || 0);\r\n    \r\n    // Get name from email\r\n    const name = row.user_email.split('@')[0];\r\n    \r\n    topOffenders.push({\r\n      email: row.user_email,\r\n      name: name,\r\n      count: count,\r\n      maxDays: parseInt(row.max_days_overdue)\r\n    });\r\n  });\r\n  \r\n  // Sort by count descending\r\n  topOffenders.sort((a, b) => b.count - a.count);\r\n  \r\n  return {\r\n    totalOverdue,\r\n    peopleWithOverdue: summary.length,\r\n    chronicCount,\r\n    topOffenders: topOffenders.slice(0, 5)\r\n  };\r\n}\r\n\r\n/**\r\n * Get weekly team task load for Monday kickoff\r\n */\r\nfunction getWeeklyTeamTaskLoad() {\r\n  const teamMembers = getCachedWorkingEmployees();\r\n  const stats = {\r\n    monday: 0,\r\n    tuesday: 0,\r\n    wednesday: 0,\r\n    thursday: 0,\r\n    friday: 0,\r\n    overdue: 0\r\n  };\r\n  \r\n  const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];\r\n  const today = new Date();\r\n  \r\n  for (const member of teamMembers) {\r\n    const tasks = getTasksDueForUser(member.email, 'week');\r\n    \r\n    tasks.forEach(task => {\r\n      if (task.isOverdue) {\r\n        stats.overdue++;\r\n      } else if (task.dueDate) {\r\n        const dayIndex = task.dueDate.getDay() - 1;\r\n        if (dayIndex >= 0 && dayIndex < 5) {\r\n          stats[days[dayIndex]]++;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  \r\n  return stats;\r\n}\r\n\r\n/**\r\n * Get per-person task completion data for EOD summary\r\n * Returns array sorted by completed count descending\r\n */\r\nfunction getPerPersonCompletions(teamMembers) {\r\n  var config = getConfig();\r\n  if (!config.clickup_config.enabled) return [];\r\n\r\n  var results = [];\r\n  for (var i = 0; i < teamMembers.length; i++) {\r\n    var member = teamMembers[i];\r\n    try {\r\n      var actions = getUserTodayTaskActions(member.email);\r\n      var completed = 0;\r\n      var delayed = 0;\r\n\r\n      actions.forEach(function(action) {\r\n        if (action.action_type === 'COMPLETE') completed = parseInt(action.count) || 0;\r\n        if (action.action_type === 'TOMORROW') delayed = parseInt(action.count) || 0;\r\n      });\r\n\r\n      if (completed > 0 || delayed > 0) {\r\n        results.push({\r\n          name: member.name || member.email.split('@')[0],\r\n          email: member.email,\r\n          completed: completed,\r\n          delayed: delayed\r\n        });\r\n      }\r\n    } catch (err) {\r\n      console.error('Error getting completions for ' + member.email + ':', err.message);\r\n    }\r\n  }\r\n\r\n  // Sort by completed descending\r\n  results.sort(function(a, b) { return b.completed - a.completed; });\r\n  return results;\r\n}\r\n\r\n/**\r\n * Check for chronic overdue and send alerts\r\n */\r\nfunction checkChronicOverdueAlerts() {\r\n  const config = getConfig();\r\n  \r\n  if (!config.settings.escalate_chronic_overdue) {\r\n    return;\r\n  }\r\n  \r\n  const escalateDays = config.settings.overdue_escalate_days || 5;\r\n  const overdueTasks = getAllOverdueTasks();\r\n  \r\n  const chronicTasks = overdueTasks.filter(t => t.daysOverdue >= escalateDays);\r\n  \r\n  if (chronicTasks.length === 0) {\r\n    return;\r\n  }\r\n  \r\n  // Group by assignee\r\n  const byAssignee = {};\r\n  chronicTasks.forEach(task => {\r\n    if (!task.assigneeEmail) return;\r\n    if (!byAssignee[task.assigneeEmail]) {\r\n      byAssignee[task.assigneeEmail] = [];\r\n    }\r\n    byAssignee[task.assigneeEmail].push(task);\r\n  });\r\n  \r\n  // Send alerts\r\n  const recipients = getReportRecipients('escalation');\r\n  \r\n  for (const [email, tasks] of Object.entries(byAssignee)) {\r\n    const taskList = tasks.slice(0, 5).map(t => \r\n      `‚Ä¢ \"${t.name}\" - ${t.daysOverdue} days overdue\\n  ${t.url || ''}`\r\n    ).join('\\n');\r\n    \r\n    const message = `üö® **Chronic Overdue Alert**\\n\\n` +\r\n      `${tasks.length} task(s) for ${email} have been overdue for ${escalateDays}+ days:\\n\\n` +\r\n      taskList + \r\n      (tasks.length > 5 ? `\\n\\n...and ${tasks.length - 5} more` : '') +\r\n      `\\n\\nPlease review and take action.`;\r\n    \r\n    // Send to escalation recipients\r\n    recipients.forEach(recipient => {\r\n      sendDirectMessage(recipient, message);\r\n    });\r\n  }\r\n  \r\n  logSystemEvent('CHRONIC_OVERDUE_ALERTS', 'SUCCESS', { \r\n    tasksAlerted: chronicTasks.length,\r\n    peopleAlerted: Object.keys(byAssignee).length \r\n  });\r\n}\r\n\r\n/**\r\n * Check team overdue threshold and alert\r\n */\r\nfunction checkTeamOverdueThreshold() {\r\n  const config = getConfig();\r\n  const threshold = config.settings.team_overdue_threshold || 20;\r\n  \r\n  const overdueTasks = getAllOverdueTasks();\r\n  \r\n  if (overdueTasks.length >= threshold) {\r\n    const message = `‚ö†Ô∏è **Team Overdue Threshold Alert**\\n\\n` +\r\n      `Total overdue tasks: **${overdueTasks.length}** (threshold: ${threshold})\\n\\n` +\r\n      `This indicates a systemic backlog that may need attention.`;\r\n    \r\n    sendDirectMessage(config.settings.manager_email, message);\r\n    \r\n    logSystemEvent('TEAM_OVERDUE_THRESHOLD', 'ALERT', { \r\n      count: overdueTasks.length, \r\n      threshold: threshold \r\n    });\r\n  }\r\n}\r\n"
    },
    {
      "name": "Code.gs",
      "type": "server_js",
      "source": "/**\r\n * Code.gs - Main Entry Points & Triggers\r\n * Primary bot logic and scheduled trigger handlers\r\n *\r\n * This file uses Google Chat Add-on style event handlers.\r\n * Event structure: https://developers.google.com/chat/api/guides/message-formats/events\r\n */\r\n\r\nconst TEST_MODE = false; // Set to true only for development testing\r\n\r\n// ============================================\r\n// USER STATE MANAGEMENT (BUG #4 fix)\r\n// ============================================\r\n\r\n/**\r\n * Set conversation state for a user\r\n * States: AWAITING_CHECKIN, AWAITING_EOD, IDLE\r\n * Uses PropertiesService for persistence across execution contexts\r\n */\r\nfunction setUserState(email, state) {\r\n  var props = PropertiesService.getScriptProperties();\r\n  var value = state + '|' + new Date().toISOString();\r\n  props.setProperty('USER_STATE_' + email.replace(/[^a-zA-Z0-9]/g, '_'), value);\r\n}\r\n\r\n/**\r\n * Get conversation state for a user\r\n * Returns IDLE if state is missing or expired (4 hour TTL)\r\n */\r\nfunction getUserState(email) {\r\n  var props = PropertiesService.getScriptProperties();\r\n  var key = 'USER_STATE_' + email.replace(/[^a-zA-Z0-9]/g, '_');\r\n  var raw = props.getProperty(key);\r\n  if (!raw) return 'IDLE';\r\n\r\n  var parts = raw.split('|');\r\n  var state = parts[0];\r\n  var timestamp = parts[1] ? new Date(parts[1]) : null;\r\n\r\n  // Expire after 4 hours\r\n  if (timestamp && (Date.now() - timestamp.getTime() > 4 * 3600 * 1000)) {\r\n    props.deleteProperty(key);\r\n    return 'IDLE';\r\n  }\r\n  return state;\r\n}\r\n\r\n/**\r\n * Clear conversation state for a user\r\n */\r\nfunction clearUserState(email) {\r\n  var props = PropertiesService.getScriptProperties();\r\n  props.deleteProperty('USER_STATE_' + email.replace(/[^a-zA-Z0-9]/g, '_'));\r\n}\r\n\r\n// ============================================\r\n// CHAT EVENT HANDLERS\r\n// ============================================\r\n\r\n/**\r\n * Responds to a MESSAGE event triggered\r\n * in Google Chat.\r\n * Handle incoming messages from Google Chat (Add-on style)\r\n * BUG #2, #3, #4 fix: Routes messages based on user state\r\n * @param event the event object from Google Chat\r\n * @return JSON-formatted response\r\n */\r\nfunction onMessage(event) {\r\n  console.log(\"onMessage triggered at\", new Date().toISOString());\r\n  console.log(\"Event:\", JSON.stringify(event));\r\n\r\n  try {\r\n    var message = event.chat.messagePayload.message || {};\r\n    var sender = event.chat.user || {};\r\n    var space = event.chat.messagePayload.space || {};\r\n\r\n    var text = message.argumentText || message.text || '';\r\n\r\n    console.log(\"User:\", sender.displayName, \"Text:\", text);\r\n\r\n    // Store DM space for future proactive messaging\r\n    if (space.type === 'DM' && space.name && sender.email) {\r\n      storeDMSpace(sender.email, space.name);\r\n    }\r\n\r\n    var lowerText = text.toLowerCase().trim();\r\n\r\n    // Weekend/after-hours guard: acknowledge but don't process as check-in/EOD\r\n    if (!isWorkday()) {\r\n      if (!['help', '?', 'ping', 'hi', 'hello'].includes(lowerText)) {\r\n        return createChatResponse('üìÖ It\\'s outside work hours. I\\'ll be available on the next workday. If this is urgent, contact your manager directly.');\r\n      }\r\n    }\r\n\r\n    // === Simple commands (always handled regardless of state) ===\r\n    if (lowerText === 'hi' || lowerText === 'hello') {\r\n      return createChatResponse(\"üëã Hi \" + (sender.displayName || \"there\") + \"! I'm the Daily Check-in Bot. Type \\\"help\\\" for available commands.\");\r\n    }\r\n\r\n    if (lowerText === 'ping') {\r\n      return createChatResponse(\"üèì Pong! Bot is working.\");\r\n    }\r\n\r\n    if (lowerText === 'help' || lowerText === '?') {\r\n      return createChatResponse(\r\n        \"üìã *Daily Check-in Bot Help*\\n\\n\" +\r\n        \"*Commands:*\\n\" +\r\n        \"‚Ä¢ `help` - Show this message\\n\" +\r\n        \"‚Ä¢ `ping` - Check if bot is responding\\n\" +\r\n        \"‚Ä¢ `refresh` - Refresh ClickUp data\\n\\n\" +\r\n        \"*How it works:*\\n\" +\r\n        \"‚Ä¢ Morning: I'll send you your tasks for the day\\n\" +\r\n        \"‚Ä¢ Reply \\\"here\\\" or share your priority to check in\\n\" +\r\n        \"‚Ä¢ EOD: I'll ask you to update task progress\\n\" +\r\n        \"‚Ä¢ Reply with your EOD summary when prompted\"\r\n      );\r\n    }\r\n\r\n    if (lowerText === 'refresh' || lowerText === 'refresh lists') {\r\n      clearClickUpCache();\r\n      return createChatResponse(\"üîÑ ClickUp data refreshed!\");\r\n    }\r\n\r\n    // Test commands (for development)\r\n    if (lowerText === 'test eod' || lowerText === 'testeod') {\r\n      var testTasks = getTasksForUser(sender.email, 'today');\r\n      var testEodMessage = getEodRequestMessage({ email: sender.email, name: sender.displayName }, testTasks);\r\n      if (testEodMessage.cardsV2) {\r\n        return createChatResponse({\r\n          text: testEodMessage.text,\r\n          cardsV2: testEodMessage.cardsV2\r\n        });\r\n      }\r\n      return createChatResponse(testEodMessage.text);\r\n    }\r\n\r\n    if (lowerText === 'test checkin' || lowerText === 'testcheckin') {\r\n      var testCheckInTasks = getTasksForUser(sender.email, 'today');\r\n      var testMsg = getMorningCheckInMessage({ email: sender.email, name: sender.displayName }, testCheckInTasks, false);\r\n      return createChatResponse(testMsg);\r\n    }\r\n\r\n    // 1-on-1 prep command\r\n    if (lowerText.startsWith('prep ') || lowerText.startsWith('/prep ')) {\r\n      var targetName = text.replace(/^\\/?prep\\s+/i, '').trim();\r\n      return handlePrepCommand(sender.email, targetName);\r\n    }\r\n\r\n    // === State-based routing (BUG #2, #3, #4 fix) ===\r\n    var userState = getUserState(sender.email);\r\n    console.log(\"User state for \" + sender.email + \": \" + userState);\r\n\r\n    if (userState === 'AWAITING_CHECKIN') {\r\n      // Any reply during check-in window is treated as check-in\r\n      clearUserState(sender.email);\r\n      return handleCheckInResponse(sender.email, sender.displayName, text);\r\n    }\r\n\r\n    if (userState === 'AWAITING_EOD' || (TEST_MODE && lowerText === 'completed testing tasks. no blockers. tomorrow: continue testing.')) {\r\n      // Any reply during EOD window is treated as EOD report\r\n      clearUserState(sender.email);\r\n      return handleEodResponse(sender.email, sender.displayName, text);\r\n    }\r\n\r\n    // Hours follow-up: bare number updates today's EOD hours\r\n    var bareNum = text.trim().match(/^(\\d+\\.?\\d*)$/);\r\n    if (bareNum) {\r\n      var hrs = parseFloat(bareNum[1]);\r\n      if (hrs >= 0 && hrs <= 24) {\r\n        updateTodayEodHours(sender.email, hrs);\r\n        return createChatResponse('‚úÖ Logged ' + hrs + ' hours for today. Thanks!');\r\n      } else if (hrs > 24) {\r\n        return createChatResponse('‚ö†Ô∏è ' + hrs + ' hours seems too high (max 24). Please reply with your actual hours worked today (e.g. \"8\").');\r\n      }\r\n    }\r\n\r\n    // === Fallback: check if \"here\" even without state (BUG #2 fix) ===\r\n    if (['here', 'i\\'m here', 'im here', 'present'].includes(lowerText) ||\r\n      (TEST_MODE && ['here - testing check-in flow', 'here - late test'].includes(lowerText))) {\r\n      return handleCheckInResponse(sender.email, sender.displayName, text);\r\n    }\r\n\r\n    // Default response\r\n    return createChatResponse(\"‚úÖ Got your message: \\\"\" + text + \"\\\"\\n\\nIf you're checking in, reply \\\"here\\\". For help, type \\\"help\\\".\");\r\n\r\n  } catch (error) {\r\n    console.error(\"Error in onMessage:\", error.message, error.stack);\r\n    return createChatResponse(\"Sorry, something went wrong. Please try again.\");\r\n  }\r\n}\r\n\r\n/**\r\n * Responds to an ADDED_TO_SPACE event in Google Chat.\r\n * @param {object} event the event object from Google Chat\r\n * @return {object} JSON-formatted response\r\n * @see https://developers.google.com/workspace/chat/receive-respond-interactions\r\n */\r\nfunction onAddToSpace(event) {\r\n  console.log(\"onAddToSpace triggered at\", new Date().toISOString());\r\n  console.log(\"Event:\", JSON.stringify(event));\r\n\r\n  try {\r\n    var space = event.chat.addedToSpacePayload.space || {};\r\n    var user = event.chat.user || {};\r\n\r\n    console.log(\"Space:\", JSON.stringify(space));\r\n    console.log(\"User:\", JSON.stringify(user));\r\n\r\n    var welcomeMessage = \"\";\r\n\r\n    var isDM = space.singleUserBotDm || space.type === 'DM' || space.spaceType === 'DIRECT_MESSAGE';\r\n\r\n    if (isDM) {\r\n      welcomeMessage = \"üëã Hi! I'm the Daily Check-in Bot.\\n\\n\" +\r\n        \"I'll send you:\\n\" +\r\n        \"‚Ä¢ Morning check-ins with your ClickUp tasks\\n\" +\r\n        \"‚Ä¢ EOD requests to update task progress\\n\\n\" +\r\n        \"Commands:\\n\" +\r\n        \"‚Ä¢ `help` - Show help message\\n\" +\r\n        \"‚Ä¢ `ping` - Check if bot is working\";\r\n\r\n      if (space.name && user.email) {\r\n        storeDMSpace(user.email, space.name);\r\n      }\r\n    } else {\r\n      welcomeMessage = \"üëã Thanks for adding me to \" + (space.displayName || \"this chat\") + \"!\\n\\n\" +\r\n        \"I'll post team summaries and updates here.\";\r\n    }\r\n\r\n    console.log(\"Welcome message:\", welcomeMessage);\r\n\r\n    return createChatResponse(welcomeMessage);\r\n\r\n  } catch (error) {\r\n    console.error(\"Error in onAddToSpace:\", error.message, error.stack);\r\n    return createChatResponse(\"üëã Hi! I'm the Daily Check-in Bot. Type 'help' for commands.\");\r\n  }\r\n}\r\n\r\n/**\r\n * Responds to a REMOVED_FROM_SPACE event in Google Chat.\r\n * @param {object} event the event object from Google Chat\r\n * @see https://developers.google.com/workspace/chat/receive-respond-interactions\r\n */\r\nfunction onRemoveFromSpace(event) {\r\n  console.log(\"onRemoveFromSpace triggered at\", new Date().toISOString());\r\n  console.log(\"Event:\", JSON.stringify(event));\r\n  var space = event.chat.removedFromSpacePayload.space;\r\n  console.log(\"Bot removed from space:\", space ? space.name : \"unknown\");\r\n}\r\n\r\n/**\r\n * Handle card action clicks (Add-on style)\r\n */\r\nfunction onCardClick(event) {\r\n  console.log(\"onCardClick triggered at\", new Date().toISOString());\r\n  console.log(\"Event:\", JSON.stringify(event));\r\n\r\n  var action = event.action || {};\r\n  var common = event.common || {};\r\n  var actionName = action.actionMethodName || common.invokedFunction || '';\r\n\r\n  switch (actionName) {\r\n    case 'handleTaskAction':\r\n      return handleTaskAction(event);\r\n    case 'handleDelayAction':\r\n      return handleDelayAction(event);\r\n    case 'handleDelayReasonSelected':\r\n      return handleDelayReasonSelected(event);\r\n    default:\r\n      console.warn('Unknown action: ' + actionName);\r\n      return createChatResponse('Unknown action');\r\n  }\r\n}\r\n\r\n/**\r\n * Handle check-in response\r\n */\r\nfunction handleCheckInResponse(email, name, text) {\r\n  // Log prompt response for adoption tracking\r\n  logPromptResponse(email, 'CHECKIN');\r\n\r\n  // Use per-user schedule for late threshold\r\n  var schedule = getUserWorkSchedule(email);\r\n  var now = new Date();\r\n\r\n  var parts = schedule.blocks[0].start.split(':');\r\n  var startHour = parseInt(parts[0]);\r\n  var startMin = parseInt(parts[1]);\r\n  var graceMinutes = getLateThresholdMin();\r\n  var totalGraceMin = startMin + graceMinutes;\r\n  var lateThreshold = new Date(now);\r\n  lateThreshold.setHours(startHour + Math.floor(totalGraceMin / 60), totalGraceMin % 60, 0, 0);\r\n  var lowerText = text.toLowerCase();\r\n\r\n  var isLate = TEST_MODE && lowerText === 'here - late test' ? true : (TEST_MODE && lowerText === 'here - testing check-in flow' ? false : now > lateThreshold);\r\n\r\n  logCheckIn(email, now, text, isLate);\r\n\r\n  return createChatResponse(getCheckInConfirmation(isLate));\r\n}\r\n\r\n/**\r\n * Handle EOD response\r\n */\r\nfunction handleEodResponse(email, name, text) {\r\n  // Log prompt response for adoption tracking\r\n  logPromptResponse(email, 'EOD');\r\n\r\n  var now = new Date();\r\n  var isFriday = now.getDay() === 5;\r\n  var config = getConfig();\r\n\r\n  // Try AI parsing first if enabled, fall back to regex\r\n  var parsed = null;\r\n  if (config.settings.enable_ai_eod_parsing !== false) {\r\n    try {\r\n      parsed = parseEodWithAI(text);\r\n    } catch (e) {\r\n      console.error('AI EOD parsing failed, using regex fallback:', e.message);\r\n    }\r\n  }\r\n\r\n  var tasksCompleted = parsed ? parsed.tasks_completed : text;\r\n  var blockers = parsed ? parsed.blockers : extractBlockers(text);\r\n  var tomorrowPriority = parsed ? parsed.tomorrow_priority : extractTomorrowPriority(text);\r\n  var hoursWorked = parsed ? parsed.hours_worked : extractHoursWorked(text);\r\n\r\n  logEodReport(email, now, tasksCompleted, blockers, tomorrowPriority, text, hoursWorked);\r\n\r\n  var response = isFriday ? getFridayEodConfirmation() : getEodConfirmation();\r\n\r\n  if (hoursWorked === null) {\r\n    response += '\\n\\n‚è∞ I didn\\'t catch your hours worked today. Reply with just a number (e.g. \"6.5\") to log your hours.';\r\n  }\r\n\r\n  return createChatResponse(response);\r\n}\r\n\r\n/**\r\n * Extract blockers from text\r\n */\r\nfunction extractBlockers(text) {\r\n  var blockerPatterns = [\r\n    /blocker[s]?:?\\s*(.+?)(?:\\n|$)/i,\r\n    /blocked\\s+(?:by|on):?\\s*(.+?)(?:\\n|$)/i,\r\n    /waiting\\s+(?:for|on):?\\s*(.+?)(?:\\n|$)/i\r\n  ];\r\n\r\n  for (var i = 0; i < blockerPatterns.length; i++) {\r\n    var match = text.match(blockerPatterns[i]);\r\n    if (match) return match[1].trim();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Extract tomorrow's priority from text\r\n */\r\nfunction extractTomorrowPriority(text) {\r\n  var patterns = [\r\n    /tomorrow['s]?\\s+(?:priority|focus|plan):?\\s*(.+?)(?:\\n|$)/i,\r\n    /(?:next|tomorrow)\\s*:?\\s*(.+?)$/i\r\n  ];\r\n\r\n  for (var i = 0; i < patterns.length; i++) {\r\n    var match = text.match(patterns[i]);\r\n    if (match) return match[1].trim();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Extract hours worked from EOD text\r\n * Matches patterns like: \"6.5 hours\", \"Worked 7h\", \"hours: 8\", \"6hrs\", bare \"6.5\"\r\n */\r\nfunction extractHoursWorked(text) {\r\n  var patterns = [\r\n    /hours?\\s*(?:worked|today)?\\s*:?\\s*(\\d+\\.?\\d*)/i,\r\n    /(\\d+\\.?\\d*)\\s*(?:hours?|hrs?|h)\\b/i,\r\n    /worked\\s+(\\d+\\.?\\d*)\\s*(?:hours?|hrs?|h)?/i,\r\n    /^\\s*(\\d+\\.?\\d*)\\s*$/  // bare number (for follow-up)\r\n  ];\r\n\r\n  for (var i = 0; i < patterns.length; i++) {\r\n    var match = text.match(patterns[i]);\r\n    if (match) {\r\n      var hours = parseFloat(match[1]);\r\n      if (hours >= 0 && hours <= 24) return hours;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Get help message\r\n */\r\nfunction getHelpMessage() {\r\n  return 'üëã **Daily Check-in Bot Help**\\n\\n' +\r\n    '**Morning Check-in:**\\n' +\r\n    'Reply \"here\" or share your #1 priority to confirm you\\'re online.\\n\\n' +\r\n    '**EOD Report:**\\n' +\r\n    'Share what you accomplished, blockers, and tomorrow\\'s plan.\\n\\n' +\r\n    '**Task Buttons:**\\n' +\r\n    '‚Ä¢ ‚úÖ Done - Mark task complete in ClickUp\\n' +\r\n    '‚Ä¢ üîÑ In Progress - Update task status\\n' +\r\n    '‚Ä¢ ‚û°Ô∏è Tomorrow - Move due date to tomorrow\\n\\n' +\r\n    '**Commands:**\\n' +\r\n    '‚Ä¢ `help` - Show this message\\n' +\r\n    '‚Ä¢ `refresh` - Refresh ClickUp data';\r\n}\r\n\r\n// ============================================\r\n// SHARED TRIGGER HELPERS (BUG #1, #11 fix)\r\n// ============================================\r\n\r\n/**\r\n * Send morning check-ins to all team members\r\n * Shared by Mon-Thu and Friday triggers\r\n */\r\nfunction _sendMorningCheckIns(isMonday) {\r\n  console.log('Sending morning check-ins...');\r\n\r\n  var teamMembers = getCachedWorkingEmployees();\r\n  var config = getConfig();\r\n  var splitSpecialActive = hasActiveSplitSpecialPeriod();\r\n\r\n  // Filter to tracked users on default schedule (dispatcher handles custom/split)\r\n  var defaultMembers = teamMembers.filter(function (m) {\r\n    var fullMember = config.team_members.find(function (tm) { return tm.email === m.email; });\r\n    if (!fullMember) return true;\r\n    if (fullMember.tracking_mode === 'not_tracked') return false;\r\n    if (splitSpecialActive) return false; // Dispatcher handles everyone during split special periods\r\n    return !fullMember.custom_start_time; // Skip custom-schedule users (dispatcher handles them)\r\n  });\r\n\r\n  // Post Monday kickoff if applicable (uses all working employees for team-wide message)\r\n  if (isMonday) {\r\n    try {\r\n      var weekStats = getWeeklyTeamTaskLoad();\r\n\r\n      // Get last week's wins\r\n      var lastWeekWins = null;\r\n      try {\r\n        lastWeekWins = getLastWeekWins();\r\n      } catch (err) {\r\n        console.error('Error getting last week wins:', err.message);\r\n      }\r\n\r\n      // Get active streaks\r\n      var activeStreaks = [];\r\n      try {\r\n        activeStreaks = getActiveStreaks();\r\n      } catch (err) {\r\n        console.error('Error getting active streaks:', err.message);\r\n      }\r\n\r\n      postMondayKickoff(weekStats, lastWeekWins, activeStreaks);\r\n    } catch (err) {\r\n      console.error('Error posting Monday kickoff:', err.message);\r\n    }\r\n  }\r\n\r\n  // Send individual DMs with per-user error handling (BUG #11)\r\n  for (var i = 0; i < defaultMembers.length; i++) {\r\n    var member = defaultMembers[i];\r\n    try {\r\n      var tasks = [];\r\n      if (config.clickup_config.enabled) {\r\n        tasks = isMonday\r\n          ? getTasksForUser(member.email, 'week')\r\n          : getTasksForUser(member.email, 'today');\r\n      }\r\n\r\n      var msg = getMorningCheckInMessage(member, tasks, isMonday);\r\n      sendDirectMessage(member.email, msg);\r\n      logPromptSent(member.email, 'CHECKIN');\r\n\r\n      // Set user state to AWAITING_CHECKIN (BUG #4)\r\n      setUserState(member.email, 'AWAITING_CHECKIN');\r\n    } catch (err) {\r\n      console.error('Error sending check-in to ' + member.email + ':', err.message);\r\n    }\r\n  }\r\n\r\n  logSystemEvent('MORNING_CHECKINS', 'SENT', { count: defaultMembers.length });\r\n  console.log('Sent morning check-ins to ' + defaultMembers.length + ' team members (default schedule)');\r\n}\r\n\r\n/**\r\n * Send check-in follow-ups to those who haven't responded\r\n * Shared by Mon-Thu and Friday triggers\r\n */\r\nfunction _sendCheckInFollowUps() {\r\n  console.log('Sending check-in follow-ups...');\r\n\r\n  var teamMembers = getCachedWorkingEmployees();\r\n  var config = getConfig();\r\n  var splitSpecialActive = hasActiveSplitSpecialPeriod();\r\n  var todayCheckIns = getTodayCheckIns();\r\n  var checkedInEmails = {};\r\n  for (var i = 0; i < todayCheckIns.length; i++) {\r\n    checkedInEmails[todayCheckIns[i].user_email] = true;\r\n  }\r\n\r\n  // Filter: not checked in, tracked, default schedule\r\n  var notCheckedIn = teamMembers.filter(function (m) {\r\n    if (checkedInEmails[m.email]) return false;\r\n    var fullMember = config.team_members.find(function (tm) { return tm.email === m.email; });\r\n    if (fullMember && fullMember.tracking_mode === 'not_tracked') return false;\r\n    if (splitSpecialActive) return false;\r\n    if (fullMember && fullMember.custom_start_time) return false;\r\n    return true;\r\n  });\r\n\r\n  for (var j = 0; j < notCheckedIn.length; j++) {\r\n    try {\r\n      sendDirectMessage(notCheckedIn[j].email, getCheckInFollowUpMessage());\r\n      logPromptSent(notCheckedIn[j].email, 'CHECKIN_FOLLOWUP');\r\n    } catch (err) {\r\n      console.error('Error sending follow-up to ' + notCheckedIn[j].email + ':', err.message);\r\n    }\r\n  }\r\n\r\n  console.log('Sent follow-ups to ' + notCheckedIn.length + ' team members');\r\n}\r\n\r\n/**\r\n * Post morning summary and send escalations\r\n * Shared by Mon-Thu and Friday triggers\r\n */\r\nfunction _postMorningSummary() {\r\n  console.log('Posting morning summary...');\r\n\r\n  var teamMembers = getCachedWorkingEmployees();\r\n  var config = getConfig();\r\n  var todayCheckIns = getTodayCheckIns();\r\n  var checkedInEmails = {};\r\n  for (var i = 0; i < todayCheckIns.length; i++) {\r\n    checkedInEmails[todayCheckIns[i].user_email] = true;\r\n  }\r\n\r\n  var checkedIn = teamMembers.filter(function (m) { return checkedInEmails[m.email]; });\r\n  // BigQuery returns is_late as string 'true'/'false', not boolean\r\n  var late = todayCheckIns.filter(function (c) { return c.is_late === true || c.is_late === 'true'; }).map(function (c) {\r\n    var member = teamMembers.find(function (m) { return m.email === c.user_email; });\r\n    return { email: c.user_email, name: member ? (member.name || member.full_name) : null };\r\n  });\r\n  // Missing = not checked in AND tracked (not-tracked users aren't expected to check in)\r\n  var missing = teamMembers.filter(function (m) {\r\n    if (checkedInEmails[m.email]) return false;\r\n    var fullMember = config.team_members.find(function (tm) { return tm.email === m.email; });\r\n    if (fullMember && fullMember.tracking_mode === 'not_tracked') return false;\r\n    return true;\r\n  });\r\n\r\n  // Get not-tracked team members for summary visibility\r\n  var notTracked = getNotTrackedTeamMembers();\r\n\r\n  var overdueStats = null;\r\n  try {\r\n    overdueStats = getTeamOverdueStats();\r\n  } catch (err) {\r\n    console.error('Error getting overdue stats:', err.message);\r\n  }\r\n\r\n  // Get PTO/Out Today data\r\n  var onLeaveToday = [];\r\n  try {\r\n    onLeaveToday = getEmployeesOnLeaveToday();\r\n  } catch (err) {\r\n    console.error('Error getting employees on leave:', err.message);\r\n  }\r\n\r\n  // Get today's birthdays\r\n  var todayBirthdays = [];\r\n  try {\r\n    todayBirthdays = getTodayBirthdays();\r\n  } catch (err) {\r\n    console.error('Error getting today birthdays:', err.message);\r\n  }\r\n\r\n  postMorningSummary(checkedIn, late, missing, overdueStats, onLeaveToday, todayBirthdays, notTracked);\r\n\r\n  // Post standup digest to team channel\r\n  try {\r\n    var config2 = getConfig();\r\n    var teamChannelId = config2.settings.team_channel_id;\r\n    if (teamChannelId && config2.settings.enable_standup_digest !== false) {\r\n      var digest = buildStandupDigest(todayCheckIns, teamMembers);\r\n      sendChannelMessage(teamChannelId, digest);\r\n    }\r\n  } catch (err) {\r\n    console.error('Error posting standup digest:', err.message);\r\n  }\r\n\r\n  try {\r\n    checkMorningEscalations();\r\n  } catch (err) {\r\n    console.error('Error checking morning escalations:', err.message);\r\n  }\r\n\r\n  console.log('Morning summary posted');\r\n}\r\n\r\n/**\r\n * Send EOD requests to all team members\r\n * Shared by Mon-Thu and Friday triggers\r\n */\r\nfunction _sendEodRequests() {\r\n  console.log('Sending EOD requests...');\r\n\r\n  var teamMembers = getCachedWorkingEmployees();\r\n  var config = getConfig();\r\n  var splitSpecialActive = hasActiveSplitSpecialPeriod();\r\n\r\n  // Filter to tracked users on default schedule\r\n  var defaultMembers = teamMembers.filter(function (m) {\r\n    var fullMember = config.team_members.find(function (tm) { return tm.email === m.email; });\r\n    if (!fullMember) return true;\r\n    if (fullMember.tracking_mode === 'not_tracked') return false;\r\n    if (splitSpecialActive) return false;\r\n    return !fullMember.custom_start_time;\r\n  });\r\n\r\n  for (var i = 0; i < defaultMembers.length; i++) {\r\n    var member = defaultMembers[i];\r\n    try {\r\n      var tasks = [];\r\n      if (config.clickup_config.enabled) {\r\n        tasks = getTasksForUser(member.email, 'today');\r\n      }\r\n\r\n      var eodMessage = getEodRequestMessage(member, tasks);\r\n\r\n      if (eodMessage.cardsV2) {\r\n        sendDirectMessage(member.email, eodMessage.text, eodMessage.cardsV2);\r\n        if (eodMessage.followUpText) {\r\n          sendDirectMessage(member.email, eodMessage.followUpText);\r\n        }\r\n      } else {\r\n        sendDirectMessage(member.email, eodMessage.text);\r\n      }\r\n\r\n      logPromptSent(member.email, 'EOD');\r\n\r\n      // Set user state to AWAITING_EOD (BUG #4)\r\n      setUserState(member.email, 'AWAITING_EOD');\r\n    } catch (err) {\r\n      console.error('Error sending EOD to ' + member.email + ':', err.message);\r\n    }\r\n  }\r\n\r\n  logSystemEvent('EOD_REQUESTS', 'SENT', { count: defaultMembers.length });\r\n  console.log('Sent EOD requests to ' + defaultMembers.length + ' team members (default schedule)');\r\n}\r\n\r\n/**\r\n * Send EOD follow-ups to those who haven't submitted\r\n * Shared by Mon-Thu and Friday triggers\r\n */\r\nfunction _sendEodFollowUps() {\r\n  console.log('Sending EOD follow-ups...');\r\n\r\n  var teamMembers = getCachedWorkingEmployees();\r\n  var config = getConfig();\r\n  var splitSpecialActive = hasActiveSplitSpecialPeriod();\r\n  var todayEods = getTodayEodReports();\r\n  var submittedEmails = {};\r\n  for (var i = 0; i < todayEods.length; i++) {\r\n    submittedEmails[todayEods[i].user_email] = true;\r\n  }\r\n\r\n  // Filter: not submitted, tracked, default schedule\r\n  var notSubmitted = teamMembers.filter(function (m) {\r\n    if (submittedEmails[m.email]) return false;\r\n    var fullMember = config.team_members.find(function (tm) { return tm.email === m.email; });\r\n    if (fullMember && fullMember.tracking_mode === 'not_tracked') return false;\r\n    if (splitSpecialActive) return false;\r\n    if (fullMember && fullMember.custom_start_time) return false;\r\n    return true;\r\n  });\r\n\r\n  for (var j = 0; j < notSubmitted.length; j++) {\r\n    try {\r\n      sendDirectMessage(notSubmitted[j].email, getEodFollowUpMessage());\r\n      logPromptSent(notSubmitted[j].email, 'EOD_FOLLOWUP');\r\n    } catch (err) {\r\n      console.error('Error sending EOD follow-up to ' + notSubmitted[j].email + ':', err.message);\r\n    }\r\n  }\r\n\r\n  console.log('Sent EOD follow-ups to ' + notSubmitted.length + ' team members');\r\n}\r\n\r\n/**\r\n * Post EOD summary and send escalations\r\n * Shared by Mon-Thu and Friday triggers\r\n */\r\nfunction _postEodSummary() {\r\n  console.log('Posting EOD summary...');\r\n\r\n  var teamMembers = getCachedWorkingEmployees();\r\n  var config = getConfig();\r\n  var todayEods = getTodayEodReports();\r\n  var submittedEmails = {};\r\n  for (var i = 0; i < todayEods.length; i++) {\r\n    submittedEmails[todayEods[i].user_email] = true;\r\n  }\r\n\r\n  var submitted = teamMembers.filter(function (m) { return submittedEmails[m.email]; });\r\n  // Missing = not submitted AND tracked\r\n  var missing = teamMembers.filter(function (m) {\r\n    if (submittedEmails[m.email]) return false;\r\n    var fullMember = config.team_members.find(function (tm) { return tm.email === m.email; });\r\n    if (fullMember && fullMember.tracking_mode === 'not_tracked') return false;\r\n    return true;\r\n  });\r\n  var notTracked = getNotTrackedTeamMembers();\r\n\r\n  var taskStats = null;\r\n  try {\r\n    taskStats = getTeamTaskStats();\r\n  } catch (err) {\r\n    console.error('Error getting task stats:', err.message);\r\n  }\r\n\r\n  // Gather per-person completion data\r\n  var perPersonCompletions = [];\r\n  try {\r\n    perPersonCompletions = getPerPersonCompletions(teamMembers);\r\n  } catch (err) {\r\n    console.error('Error getting per-person completions:', err.message);\r\n  }\r\n\r\n  // Gather blockers from today's EOD reports\r\n  var todayBlockers = [];\r\n  try {\r\n    todayEods.forEach(function (eod) {\r\n      if (eod.blockers && eod.blockers.trim()) {\r\n        var member = teamMembers.find(function (m) { return m.email === eod.user_email; });\r\n        todayBlockers.push({\r\n          name: member ? (member.name || eod.user_email.split('@')[0]) : eod.user_email.split('@')[0],\r\n          blocker: eod.blockers\r\n        });\r\n      }\r\n    });\r\n  } catch (err) {\r\n    console.error('Error gathering blockers:', err.message);\r\n  }\r\n\r\n  postEodSummary(submitted, missing, taskStats, perPersonCompletions, todayBlockers, notTracked);\r\n\r\n  // Post EOD digest to team channel\r\n  try {\r\n    var config2 = getConfig();\r\n    var teamChannelId = config2.settings.team_channel_id;\r\n    if (teamChannelId && config2.settings.enable_standup_digest !== false) {\r\n      var eodDigest = buildEodDigest(todayEods, teamMembers);\r\n      sendChannelMessage(teamChannelId, eodDigest);\r\n    }\r\n  } catch (err) {\r\n    console.error('Error posting EOD digest:', err.message);\r\n  }\r\n\r\n  try {\r\n    checkEodEscalations();\r\n  } catch (err) {\r\n    console.error('Error checking EOD escalations:', err.message);\r\n  }\r\n\r\n  // Check for capacity warnings (5+ \"no time\" delays this week)\r\n  try {\r\n    checkCapacityWarnings();\r\n  } catch (err) {\r\n    console.error('Error checking capacity warnings:', err.message);\r\n  }\r\n\r\n  console.log('EOD summary posted');\r\n}\r\n\r\n// ============================================\r\n// SCHEDULED TRIGGERS (Mon-Thu)\r\n// ============================================\r\n\r\n/**\r\n * 6:00 AM - Sage HR Sync\r\n */\r\nfunction triggerSageHRSync() {\r\n  if (!isWorkday()) return;\r\n  safeExecute('SageHR Daily Sync', function () { dailySageHRSync(); });\r\n}\r\n\r\n/**\r\n * 6:15 AM - ClickUp Sync\r\n */\r\nfunction triggerClickUpSync() {\r\n  if (!isWorkday()) return;\r\n  safeExecute('ClickUp Daily Sync', function () { dailyClickUpSync(); });\r\n}\r\n\r\n/**\r\n * 8:00 AM (Mon-Thu) - Send Morning Check-ins\r\n */\r\nfunction triggerMorningCheckIns() {\r\n  if (!isWorkday()) return;\r\n  var today = new Date();\r\n  if (today.getDay() === 5) return; // Friday handled by separate trigger\r\n\r\n  var isMonday = today.getDay() === 1;\r\n  _sendMorningCheckIns(isMonday);\r\n}\r\n\r\n/**\r\n * 8:20 AM (Mon-Thu) - Check-in Follow-ups\r\n */\r\nfunction triggerCheckInFollowUp() {\r\n  if (!isWorkday()) return;\r\n  var today = new Date();\r\n  if (today.getDay() === 5) return;\r\n\r\n  _sendCheckInFollowUps();\r\n}\r\n\r\n/**\r\n * 8:35 AM (Mon-Thu) - Morning Summary + Escalations\r\n */\r\nfunction triggerMorningSummary() {\r\n  if (!isWorkday()) return;\r\n  var today = new Date();\r\n  if (today.getDay() === 5) return;\r\n\r\n  _postMorningSummary();\r\n}\r\n\r\n/**\r\n * 4:30 PM (Mon-Thu) - Send EOD Requests\r\n * Skips on half_pm holidays (afternoon off)\r\n */\r\nfunction triggerEodRequests() {\r\n  if (!isEodWorkday()) return;\r\n  var today = new Date();\r\n  if (today.getDay() === 5) return; // Friday handled by separate trigger\r\n\r\n  _sendEodRequests();\r\n}\r\n\r\n/**\r\n * 4:50 PM (Mon-Thu) - EOD Follow-ups\r\n */\r\nfunction triggerEodFollowUp() {\r\n  if (!isEodWorkday()) return;\r\n  var today = new Date();\r\n  if (today.getDay() === 5) return;\r\n\r\n  _sendEodFollowUps();\r\n}\r\n\r\n/**\r\n * 5:00 PM (Mon-Thu) - EOD Summary + Escalations\r\n */\r\nfunction triggerEodSummary() {\r\n  if (!isEodWorkday()) return;\r\n  var today = new Date();\r\n  if (today.getDay() === 5) return;\r\n\r\n  _postEodSummary();\r\n}\r\n\r\n/**\r\n * 5:15 PM - ClickUp Daily Snapshot\r\n */\r\nfunction triggerClickUpSnapshot() {\r\n  if (!isEodWorkday()) return;\r\n  dailyClickUpSnapshot();\r\n}\r\n\r\n/**\r\n * 5:30 PM (Mon-Thu) - AI Evaluation\r\n */\r\nfunction triggerAiEvaluation() {\r\n  if (!isEodWorkday()) return;\r\n  var today = new Date();\r\n  if (today.getDay() === 5) return;\r\n\r\n  generateDailyAiEvaluation();\r\n}\r\n\r\n/**\r\n * 10:15 AM Friday - Weekly Gamification\r\n */\r\nfunction triggerWeeklyGamification() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 5) return;\r\n  if (!isWorkday()) return;\r\n\r\n  postWeeklyGamification();\r\n}\r\n\r\n// ============================================\r\n// FRIDAY-SPECIFIC TRIGGERS (BUG #1 fix)\r\n// These now call shared helpers directly\r\n// instead of delegating to Mon-Thu functions\r\n// ============================================\r\n\r\n/**\r\n * 7:00 AM Friday - Morning Check-ins (Friday only)\r\n */\r\nfunction triggerMorningCheckInsFriday() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 5) return;\r\n  if (!isWorkday()) return;\r\n\r\n  console.log('Sending Friday morning check-ins...');\r\n  _sendMorningCheckIns(false); // Friday is never Monday\r\n}\r\n\r\n/**\r\n * 7:20 AM Friday - Check-in Follow-ups (Friday only)\r\n */\r\nfunction triggerCheckInFollowUpFriday() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 5) return;\r\n  if (!isWorkday()) return;\r\n\r\n  console.log('Sending Friday check-in follow-ups...');\r\n  _sendCheckInFollowUps();\r\n}\r\n\r\n/**\r\n * 7:35 AM Friday - Morning Summary (Friday only)\r\n */\r\nfunction triggerMorningSummaryFriday() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 5) return;\r\n  if (!isWorkday()) return;\r\n\r\n  console.log('Posting Friday morning summary...');\r\n  _postMorningSummary();\r\n}\r\n\r\n/**\r\n * 10:30 AM Friday - EOD Requests (Friday only)\r\n * BUG #1 fix: Calls shared helper directly instead of triggerEodRequests()\r\n */\r\nfunction triggerEodRequestsFriday() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 5) return;\r\n  if (!isWorkday()) return;\r\n\r\n  console.log('Sending Friday EOD requests...');\r\n  _sendEodRequests();\r\n}\r\n\r\n/**\r\n * 10:50 AM Friday - EOD Follow-ups (Friday only)\r\n * BUG #1 fix: Calls shared helper directly instead of triggerEodFollowUp()\r\n */\r\nfunction triggerEodFollowUpFriday() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 5) return;\r\n  if (!isWorkday()) return;\r\n\r\n  console.log('Sending Friday EOD follow-ups...');\r\n  _sendEodFollowUps();\r\n}\r\n\r\n/**\r\n * 11:00 AM Friday - EOD Summary (Friday only)\r\n * BUG #1 fix: Calls shared helper directly instead of triggerEodSummary()\r\n */\r\nfunction triggerEodSummaryFriday() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 5) return;\r\n  if (!isWorkday()) return;\r\n\r\n  console.log('Posting Friday EOD summary...');\r\n  _postEodSummary();\r\n}\r\n\r\n/**\r\n * 11:30 AM Friday - AI Evaluation + Weekly Summary (Friday only)\r\n */\r\nfunction triggerAiEvaluationFriday() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 5) return;\r\n  if (!isWorkday()) return;\r\n\r\n  generateDailyAiEvaluation();\r\n  generateWeeklySummary();\r\n}\r\n\r\n// ============================================\r\n// V2 TRIGGERS - Adoption & Compliance\r\n// ============================================\r\n\r\n/**\r\n * 5:20 PM (Mon-Thu) - Compute daily adoption metrics\r\n * Must run AFTER EOD summary (5:00 PM)\r\n */\r\nfunction triggerDailyAdoptionMetrics() {\r\n  if (!isEodWorkday()) return;\r\n  safeExecute('Daily Adoption Metrics', function () { computeDailyAdoptionMetrics(); });\r\n}\r\n\r\n/**\r\n * 10:30 AM Friday - Weekly adoption report\r\n * Must run AFTER weekly gamification (10:15 AM)\r\n */\r\nfunction triggerWeeklyAdoptionReport() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 5) return;\r\n  if (!isWorkday()) return;\r\n\r\n  safeExecute('Weekly Adoption Report', function () {\r\n    computeDailyAdoptionMetrics(); // compute Friday's metrics first\r\n    generateWeeklyAdoptionReport();\r\n  });\r\n}\r\n\r\n/**\r\n * 10:00 AM Wednesday - Midweek compliance check\r\n */\r\nfunction triggerMidweekCompliance() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 3) return; // Wednesday only\r\n  if (!isWorkday()) return;\r\n\r\n  safeExecute('Midweek Compliance', function () { midweekComplianceCheck(); });\r\n}\r\n\r\n/**\r\n * Friday EOD adoption metrics\r\n */\r\nfunction triggerDailyAdoptionMetricsFriday() {\r\n  var today = new Date();\r\n  if (today.getDay() !== 5) return;\r\n  if (!isWorkday()) return;\r\n\r\n  safeExecute('Friday Adoption Metrics', function () { computeDailyAdoptionMetrics(); });\r\n}\r\n\r\n// ============================================\r\n// SCHEDULE DISPATCHER (Custom/Split Shifts)\r\n// ============================================\r\n\r\n/**\r\n * Dispatcher trigger - runs every 30 minutes.\r\n * Handles users with custom schedules or during split special periods.\r\n * Default-schedule users are handled by the existing global triggers.\r\n */\r\nfunction triggerScheduleDispatcher() {\r\n  if (!isWorkday()) return;\r\n\r\n  var config = getConfig();\r\n  var workingEmployees = getCachedWorkingEmployees();\r\n  var splitSpecialActive = hasActiveSplitSpecialPeriod();\r\n\r\n  // Determine which users the dispatcher should handle\r\n  var dispatchUsers = workingEmployees.filter(function (m) {\r\n    var fullMember = config.team_members.find(function (tm) { return tm.email === m.email; });\r\n    if (!fullMember) return false;\r\n    if ((fullMember.tracking_mode || 'tracked') !== 'tracked') return false;\r\n    // During split special periods, dispatcher handles everyone\r\n    if (splitSpecialActive) return true;\r\n    // Otherwise only custom-schedule users\r\n    return !!fullMember.custom_start_time;\r\n  });\r\n\r\n  if (dispatchUsers.length === 0) return;\r\n\r\n  var promptTypes = ['CHECKIN', 'CHECKIN_FOLLOWUP', 'EOD', 'EOD_FOLLOWUP'];\r\n  var cache = CacheService.getScriptCache();\r\n  var todayStr = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  for (var i = 0; i < dispatchUsers.length; i++) {\r\n    var member = dispatchUsers[i];\r\n    for (var j = 0; j < promptTypes.length; j++) {\r\n      var promptType = promptTypes[j];\r\n      if (isTimeForPrompt(member.email, promptType)) {\r\n        // Dedup: don't send same prompt type twice in one day\r\n        var dedupKey = 'DISPATCH_' + promptType + '_' + member.email + '_' + todayStr;\r\n        if (cache.get(dedupKey)) continue;\r\n\r\n        try {\r\n          dispatchPrompt(member, promptType, config);\r\n          cache.put(dedupKey, 'sent', 21600);\r\n        } catch (err) {\r\n          console.error('Dispatcher error for ' + member.email + ' ' + promptType + ':', err.message);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Check if NOW is the right time to send a prompt to this user.\r\n * Uses a 15-minute window after the target time.\r\n */\r\nfunction isTimeForPrompt(email, promptType) {\r\n  var schedule = getUserWorkSchedule(email);\r\n  var now = new Date();\r\n  var nowMinutes = now.getHours() * 60 + now.getMinutes();\r\n  var WINDOW = 15;\r\n\r\n  var block1Start = timeToMinutes(schedule.blocks[0].start);\r\n  var lastBlockEnd = timeToMinutes(schedule.blocks[schedule.blocks.length - 1].end);\r\n\r\n  switch (promptType) {\r\n    case 'CHECKIN':\r\n      return nowMinutes >= block1Start && nowMinutes <= block1Start + WINDOW;\r\n    case 'CHECKIN_FOLLOWUP':\r\n      return nowMinutes >= block1Start + 20 && nowMinutes <= block1Start + 35;\r\n    case 'EOD':\r\n      return nowMinutes >= lastBlockEnd - 30 && nowMinutes <= lastBlockEnd - 15;\r\n    case 'EOD_FOLLOWUP':\r\n      return nowMinutes >= lastBlockEnd - 10 && nowMinutes <= lastBlockEnd + 5;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Send the appropriate prompt to a user based on type.\r\n */\r\nfunction dispatchPrompt(member, promptType, config) {\r\n  switch (promptType) {\r\n    case 'CHECKIN':\r\n      var tasks = config.clickup_config && config.clickup_config.enabled ? getTasksForUser(member.email, 'today') : [];\r\n      var msg = getMorningCheckInMessage(member, tasks, new Date().getDay() === 1);\r\n      sendDirectMessage(member.email, msg);\r\n      logPromptSent(member.email, 'CHECKIN');\r\n      setUserState(member.email, 'AWAITING_CHECKIN');\r\n      break;\r\n    case 'CHECKIN_FOLLOWUP':\r\n      var todayCheckIns = getTodayCheckIns();\r\n      var alreadyCheckedIn = todayCheckIns.some(function (c) { return c.user_email === member.email; });\r\n      if (!alreadyCheckedIn) {\r\n        sendDirectMessage(member.email, getCheckInFollowUpMessage());\r\n        logPromptSent(member.email, 'CHECKIN_FOLLOWUP');\r\n      }\r\n      break;\r\n    case 'EOD':\r\n      var eodTasks = config.clickup_config && config.clickup_config.enabled ? getTasksForUser(member.email, 'today') : [];\r\n      var eodMessage = getEodRequestMessage(member, eodTasks);\r\n      if (eodMessage.cardsV2) {\r\n        sendDirectMessage(member.email, eodMessage.text, eodMessage.cardsV2);\r\n        if (eodMessage.followUpText) sendDirectMessage(member.email, eodMessage.followUpText);\r\n      } else {\r\n        sendDirectMessage(member.email, eodMessage.text);\r\n      }\r\n      logPromptSent(member.email, 'EOD');\r\n      setUserState(member.email, 'AWAITING_EOD');\r\n      break;\r\n    case 'EOD_FOLLOWUP':\r\n      var todayEods = getTodayEodReports();\r\n      var alreadySubmitted = todayEods.some(function (e) { return e.user_email === member.email; });\r\n      if (!alreadySubmitted) {\r\n        sendDirectMessage(member.email, getEodFollowUpMessage());\r\n        logPromptSent(member.email, 'EOD_FOLLOWUP');\r\n      }\r\n      break;\r\n  }\r\n}\r\n\r\n// ============================================\r\n// PREP COMMAND HANDLER\r\n// ============================================\r\n\r\n/**\r\n * Handle /prep command - generate 1-on-1 prep report for a team member\r\n */\r\nfunction handlePrepCommand(requesterEmail, targetName) {\r\n  var config = getConfig();\r\n\r\n  // Only allow managers to use this\r\n  var managerEmails = [config.settings.manager_email];\r\n  if (config.settings.escalation_emails) {\r\n    managerEmails = managerEmails.concat(\r\n      Array.isArray(config.settings.escalation_emails) ? config.settings.escalation_emails : [config.settings.escalation_emails]\r\n    );\r\n  }\r\n\r\n  if (managerEmails.indexOf(requesterEmail) === -1) {\r\n    return createChatResponse('This command is only available to managers.');\r\n  }\r\n\r\n  // Find team member by name (fuzzy match)\r\n  var teamMembers = getCachedWorkingEmployees();\r\n  var target = teamMembers.find(function (m) {\r\n    var name = (m.name || '').toLowerCase();\r\n    var emailPrefix = m.email.split('@')[0].toLowerCase();\r\n    return name.includes(targetName.toLowerCase()) || emailPrefix.includes(targetName.toLowerCase());\r\n  });\r\n\r\n  if (!target) {\r\n    return createChatResponse('Could not find team member matching \"' + targetName + '\". Try their first name or email prefix.');\r\n  }\r\n\r\n  var targetEmail = target.email;\r\n  var targetDisplayName = target.name || targetEmail.split('@')[0];\r\n  var projectId = getProjectId();\r\n\r\n  // Last 14 days of data\r\n  var twoWeeksAgo = new Date();\r\n  twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);\r\n  var startStr = Utilities.formatDate(twoWeeksAgo, 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  // Attendance\r\n  var attendanceQuery = 'SELECT ' +\r\n    'COUNTIF(checkin_responded) as checkins, ' +\r\n    'COUNTIF(checkin_is_late) as late, ' +\r\n    'COUNTIF(eod_responded) as eods, ' +\r\n    'COUNT(*) as workdays, ' +\r\n    'AVG(checkin_latency_minutes) as avg_latency, ' +\r\n    'AVG(eod_word_count) as avg_eod_words ' +\r\n    'FROM `' + projectId + '.' + DATASET_ID + '.daily_adoption_metrics` ' +\r\n    'WHERE user_email = \"' + targetEmail + '\" AND metric_date >= \"' + startStr + '\"';\r\n  var attendance = runBigQueryQuery(attendanceQuery);\r\n  var att = attendance.length > 0 ? attendance[0] : {};\r\n\r\n  // Recent blockers\r\n  var blockerQuery = 'SELECT blockers, eod_date FROM `' + projectId + '.' + DATASET_ID + '.v_eod_reports` ' +\r\n    'WHERE user_email = \"' + targetEmail + '\" AND eod_date >= \"' + startStr + '\" AND blockers IS NOT NULL AND blockers != \"\" ' +\r\n    'ORDER BY eod_date DESC LIMIT 5';\r\n  var blockers = runBigQueryQuery(blockerQuery);\r\n\r\n  // Task stats\r\n  var taskQuery = 'SELECT action_type, COUNT(*) as cnt FROM (' +\r\n    '  SELECT task_id, action_type FROM (' +\r\n    '    SELECT task_id, action_type, ROW_NUMBER() OVER (PARTITION BY task_id ORDER BY timestamp DESC) as rn' +\r\n    '    FROM `' + projectId + '.' + DATASET_ID + '.clickup_task_actions`' +\r\n    '    WHERE user_email = \"' + targetEmail + '\" AND DATE(timestamp) >= \"' + startStr + '\"' +\r\n    '  ) WHERE rn = 1' +\r\n    ') GROUP BY action_type';\r\n  var taskActions = runBigQueryQuery(taskQuery);\r\n  var taskMap = {};\r\n  taskActions.forEach(function (a) { taskMap[a.action_type] = parseInt(a.cnt); });\r\n\r\n  // Chronically delayed tasks\r\n  var delayedTasks = getChronicallyDelayedTasks().filter(function (t) { return t.user_email === targetEmail; });\r\n\r\n  // Hours trend\r\n  var hoursQuery = 'SELECT eod_date, hours_worked FROM `' + projectId + '.' + DATASET_ID + '.v_eod_reports` ' +\r\n    'WHERE user_email = \"' + targetEmail + '\" AND eod_date >= \"' + startStr + '\" AND hours_worked IS NOT NULL ' +\r\n    'ORDER BY eod_date';\r\n  var hourEntries = runBigQueryQuery(hoursQuery);\r\n\r\n  // Build report\r\n  var report = 'üìã *1-on-1 Prep: ' + targetDisplayName + '*\\n';\r\n  report += '_(Last 14 days)_\\n\\n';\r\n\r\n  // Attendance\r\n  var workdays = parseInt(att.workdays) || 0;\r\n  var checkins = parseInt(att.checkins) || 0;\r\n  var eods = parseInt(att.eods) || 0;\r\n  var late = parseInt(att.late) || 0;\r\n  report += '*Attendance:* ' + checkins + '/' + workdays + ' check-ins, ' + eods + '/' + workdays + ' EODs';\r\n  if (late > 0) report += ', ' + late + ' late';\r\n  var avgLatency = parseFloat(att.avg_latency);\r\n  if (!isNaN(avgLatency)) report += ', avg response: ' + Math.round(avgLatency) + ' min';\r\n  report += '\\n';\r\n\r\n  // Tasks\r\n  var completed = taskMap['COMPLETE'] || 0;\r\n  var delayed = taskMap['TOMORROW'] || 0;\r\n  var inProgress = taskMap['IN_PROGRESS'] || 0;\r\n  report += '*Tasks:* ' + completed + ' completed, ' + delayed + ' delayed, ' + inProgress + ' in-progress\\n';\r\n\r\n  if (delayedTasks.length > 0) {\r\n    report += '*Chronically Delayed (' + delayedTasks.length + '):*\\n';\r\n    delayedTasks.slice(0, 5).forEach(function (t) {\r\n      report += '  \"' + t.task_name + '\" pushed ' + t.push_count + 'x\\n';\r\n    });\r\n  }\r\n\r\n  // Hours\r\n  if (hourEntries.length > 0) {\r\n    var totalHours = 0;\r\n    hourEntries.forEach(function (h) { totalHours += parseFloat(h.hours_worked) || 0; });\r\n    var avgHours = Math.round(totalHours / hourEntries.length * 10) / 10;\r\n    report += '*Hours:* Avg ' + avgHours + '/day over ' + hourEntries.length + ' days reported\\n';\r\n  }\r\n\r\n  // Blockers\r\n  if (blockers.length > 0) {\r\n    report += '\\n*Recent Blockers:*\\n';\r\n    blockers.forEach(function (b) {\r\n      report += '  ' + b.eod_date + ': ' + b.blockers + '\\n';\r\n    });\r\n  }\r\n\r\n  // EOD quality\r\n  var avgWords = parseFloat(att.avg_eod_words);\r\n  if (!isNaN(avgWords)) {\r\n    report += '\\n*EOD Quality:* Avg ' + Math.round(avgWords) + ' words/report';\r\n    if (avgWords < 15) report += ' ‚ö†Ô∏è (very thin)';\r\n    else if (avgWords < 30) report += ' (brief)';\r\n    report += '\\n';\r\n  }\r\n\r\n  return createChatResponse(report);\r\n}\r\n\r\n// ============================================\r\n// TEST HELPER (kept for development)\r\n// ============================================\r\n\r\nfunction __testAllTriggers() {\r\n  console.log('==============================');\r\n  console.log('üöÄ STARTING FULL TRIGGER TEST');\r\n  console.log('TEST_MODE:', TEST_MODE);\r\n  console.log('Timestamp:', new Date().toISOString());\r\n  console.log('==============================');\r\n\r\n  var steps = [\r\n    { name: 'Sage HR Sync', fn: triggerSageHRSync },\r\n    { name: 'ClickUp Sync', fn: triggerClickUpSync },\r\n\r\n    { name: 'Morning Check-ins (Mon‚ÄìThu)', fn: triggerMorningCheckIns },\r\n    { name: 'Check-in Follow-up', fn: triggerCheckInFollowUp },\r\n    { name: 'Morning Summary', fn: triggerMorningSummary },\r\n\r\n    { name: 'EOD Requests', fn: triggerEodRequests },\r\n    { name: 'EOD Follow-up', fn: triggerEodFollowUp },\r\n    { name: 'EOD Summary', fn: triggerEodSummary },\r\n\r\n    { name: 'ClickUp Snapshot', fn: triggerClickUpSnapshot },\r\n    { name: 'AI Evaluation', fn: triggerAiEvaluation },\r\n\r\n    { name: 'Friday Morning Check-ins', fn: triggerMorningCheckInsFriday },\r\n    { name: 'Friday Check-in Follow-up', fn: triggerCheckInFollowUpFriday },\r\n    { name: 'Friday Morning Summary', fn: triggerMorningSummaryFriday },\r\n\r\n    { name: 'Friday EOD Requests', fn: triggerEodRequestsFriday },\r\n    { name: 'Friday EOD Follow-up', fn: triggerEodFollowUpFriday },\r\n    { name: 'Friday EOD Summary', fn: triggerEodSummaryFriday },\r\n\r\n    { name: 'Weekly Gamification', fn: triggerWeeklyGamification },\r\n    { name: 'Friday AI + Weekly Summary', fn: triggerAiEvaluationFriday },\r\n\r\n    { name: 'Daily Adoption Metrics', fn: triggerDailyAdoptionMetrics },\r\n    { name: 'Midweek Compliance', fn: triggerMidweekCompliance },\r\n    { name: 'Weekly Adoption Report', fn: triggerWeeklyAdoptionReport },\r\n  ];\r\n\r\n  var results = [];\r\n\r\n  for (var i = 0; i < steps.length; i++) {\r\n    var step = steps[i];\r\n    console.log('\\n‚ñ∂Ô∏è Running: ' + step.name);\r\n    try {\r\n      step.fn();\r\n      console.log('‚úÖ SUCCESS: ' + step.name);\r\n      results.push({ step: step.name, status: 'OK' });\r\n    } catch (err) {\r\n      console.error('‚ùå FAILED: ' + step.name);\r\n      console.error(err.message, err.stack);\r\n      results.push({ step: step.name, status: 'ERROR', error: err.message });\r\n    }\r\n  }\r\n\r\n  console.log('\\n==============================');\r\n  console.log('üèÅ TRIGGER TEST COMPLETE');\r\n  console.log('Results:', JSON.stringify(results));\r\n  console.log('==============================');\r\n\r\n  return results;\r\n}\r\n"
    },
    {
      "name": "Config.gs",
      "type": "server_js",
      "source": "/**\r\n * Config.gs - Configuration Management\r\n * Loads settings from Google Sheet and Script Properties\r\n *\r\n * ============================================\r\n * ODOO INTEGRATION POINTS:\r\n * ============================================\r\n *\r\n * 1. Add ODOO_API_KEY to Script Properties (line ~33)\r\n *\r\n * 2. Add odoo_config tab loading function (after loadClickUpConfigTab)\r\n *    - enabled: boolean\r\n *    - include_in_morning: boolean\r\n *    - include_in_eod: boolean\r\n *\r\n * 3. Add odoo_user_map tab for email ‚Üí Odoo user mapping\r\n *    - Columns: email, odoo_user_id, odoo_username\r\n *\r\n * 4. Add task_source column to team_members tab:\r\n *    - 'clickup' - tasks from ClickUp only\r\n *    - 'odoo' - tasks from Odoo only\r\n *    - 'both' - tasks from both systems\r\n *    - Modify loadTeamMembersTab() to include this field\r\n *\r\n * 5. Create getTasksForUser(email, period) function that:\r\n *    - Checks member's task_source setting\r\n *    - Calls ClickUp and/or Odoo based on setting\r\n *    - Merges results if 'both'\r\n *\r\n * ============================================\r\n */\r\n\r\n/**\r\n * Get all configuration\r\n * Uses CacheService for persistence across execution contexts\r\n */\r\nfunction getConfig() {\r\n  // Check CacheService first\r\n  var cache = CacheService.getScriptCache();\r\n  var cached = cache.get('CONFIG_JSON');\r\n  if (cached) {\r\n    try {\r\n      return JSON.parse(cached);\r\n    } catch (e) {\r\n      // corrupted cache, fall through to sheet read\r\n    }\r\n  }\r\n\r\n  const props = PropertiesService.getScriptProperties();\r\n  const sheetId = props.getProperty('CONFIG_SHEET_ID');\r\n\r\n  if (!sheetId) {\r\n    throw new Error('CONFIG_SHEET_ID not set in Script Properties');\r\n  }\r\n\r\n  const ss = SpreadsheetApp.openById(sheetId);\r\n  const config = {\r\n    // Script Properties (sensitive)\r\n    sage_hr_api_key: props.getProperty('SAGE_HR_API_KEY'),\r\n    openai_api_key: props.getProperty('OPENAI_API_KEY'),\r\n    clickup_api_token: props.getProperty('CLICKUP_API_TOKEN'),\r\n    bigquery_project_id: props.getProperty('BIGQUERY_PROJECT_ID'),\r\n    odoo_api_key: props.getProperty('ODOO_API_KEY'),\r\n\r\n    // From settings tab\r\n    settings: loadSettingsTab(ss),\r\n\r\n    // From team_members tab\r\n    team_members: loadTeamMembersTab(ss),\r\n\r\n    // From work_hours tab\r\n    work_hours: loadWorkHoursTab(ss),\r\n\r\n    // From holidays tab\r\n    holidays: loadHolidaysTab(ss),\r\n\r\n    // From clickup_config tab\r\n    clickup_config: loadClickUpConfigTab(ss),\r\n\r\n    // From clickup_user_map tab\r\n    clickup_user_map: loadClickUpUserMapTab(ss),\r\n\r\n    // From odoo_config tab\r\n    odoo_config: loadOdooConfigTab(ss),\r\n\r\n    // From odoo_user_map tab\r\n    odoo_user_map: loadOdooUserMapTab(ss),\r\n\r\n    // From special_hours tab (Ramadan, etc.)\r\n    special_hours: loadSpecialHoursTab(ss),\r\n\r\n    // From email_mapping tab (Sage HR ‚Üí Google email)\r\n    email_mapping: loadEmailMappingTab(ss)\r\n  };\r\n\r\n  // Cache it (CacheService, not in-memory)\r\n  try {\r\n    cache.put('CONFIG_JSON', JSON.stringify(config), 300);\r\n  } catch (e) {\r\n    console.log('Config too large for cache, skipping');\r\n  }\r\n\r\n  return config;\r\n}\r\n\r\n/**\r\n * Clear config cache (call after sheet updates)\r\n */\r\nfunction clearConfigCache() {\r\n  var cache = CacheService.getScriptCache();\r\n  cache.remove('CONFIG_JSON');\r\n}\r\n\r\n/**\r\n * Load settings tab (key-value pairs)\r\n */\r\nfunction loadSettingsTab(ss) {\r\n  const sheet = ss.getSheetByName('settings');\r\n  if (!sheet) return {};\r\n\r\n  const data = sheet.getDataRange().getValues();\r\n  const settings = {};\r\n\r\n  // Skip header row\r\n  for (let i = 1; i < data.length; i++) {\r\n    const key = data[i][0];\r\n    let value = data[i][1];\r\n\r\n    if (key) {\r\n      // Parse booleans\r\n      if (value === 'TRUE' || value === true) value = true;\r\n      else if (value === 'FALSE' || value === false) value = false;\r\n      // Parse numbers\r\n      else if (!isNaN(value) && value !== '') value = Number(value);\r\n      // Parse comma-separated lists\r\n      else if (typeof value === 'string' && value.includes(',') && value.includes('@')) {\r\n        value = value.split(',').map(v => v.trim());\r\n      }\r\n\r\n      settings[key] = value;\r\n    }\r\n  }\r\n\r\n  return settings;\r\n}\r\n\r\n/**\r\n * Load team members tab\r\n */\r\nfunction loadTeamMembersTab(ss) {\r\n  const sheet = ss.getSheetByName('team_members');\r\n  if (!sheet) return [];\r\n\r\n  const data = sheet.getDataRange().getValues();\r\n  const members = [];\r\n\r\n  // Skip header row\r\n  for (let i = 1; i < data.length; i++) {\r\n    if (data[i][0]) { // Has email\r\n      members.push({\r\n        email: data[i][0],\r\n        name: data[i][1],\r\n        department: data[i][2],\r\n        manager_email: data[i][3],\r\n        active: data[i][4] !== false && data[i][4] !== 'FALSE',\r\n        custom_start_time: data[i][5] || null,\r\n        custom_end_time: data[i][6] || null,\r\n        timezone: data[i][7] || 'America/Chicago',\r\n        task_source: data[i][8] || 'clickup',\r\n        tracking_mode: data[i][9] || 'tracked',\r\n        custom_block2_start: data[i][10] || null,\r\n        custom_block2_end: data[i][11] || null\r\n      });\r\n    }\r\n  }\r\n\r\n  return members;\r\n}\r\n\r\n/**\r\n * Load work hours tab\r\n */\r\nfunction loadWorkHoursTab(ss) {\r\n  const sheet = ss.getSheetByName('work_hours');\r\n  if (!sheet) {\r\n    // Return defaults\r\n    return {\r\n      default_start: '08:00',\r\n      default_end: '17:00',\r\n      friday_start: '07:00',\r\n      friday_end: '11:00',\r\n      default_hours_per_day: 8,\r\n      friday_hours_per_day: 4,\r\n      timezone: 'America/Chicago'\r\n    };\r\n  }\r\n\r\n  const data = sheet.getDataRange().getValues();\r\n  const hours = {};\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    if (data[i][0]) {\r\n      hours[data[i][0]] = data[i][1];\r\n    }\r\n  }\r\n\r\n  // Ensure hours defaults exist\r\n  if (!hours.default_hours_per_day) hours.default_hours_per_day = 8;\r\n  if (!hours.friday_hours_per_day) hours.friday_hours_per_day = 4;\r\n\r\n  return hours;\r\n}\r\n\r\n/**\r\n * Get expected working hours for today\r\n * Returns 4 on Fridays, 8 on Mon-Thu (configurable via work_hours sheet)\r\n */\r\nfunction getTodayExpectedHours(email) {\r\n  if (email) {\r\n    var schedule = getUserWorkSchedule(email);\r\n    return schedule.totalExpectedHours;\r\n  }\r\n  var config = getConfig();\r\n  var day = new Date().getDay();\r\n  if (day === 5) {\r\n    return parseFloat(config.work_hours.friday_hours_per_day) || 4;\r\n  }\r\n  return parseFloat(config.work_hours.default_hours_per_day) || 8;\r\n}\r\n\r\n/**\r\n * Load holidays tab\r\n */\r\nfunction loadHolidaysTab(ss) {\r\n  const sheet = ss.getSheetByName('holidays');\r\n  if (!sheet) return [];\r\n\r\n  const data = sheet.getDataRange().getValues();\r\n  const holidays = [];\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    if (data[i][0]) {\r\n      holidays.push({\r\n        date: data[i][0],\r\n        name: data[i][1],\r\n        type: data[i][2] || 'full' // full, half_am, half_pm\r\n      });\r\n    }\r\n  }\r\n\r\n  return holidays;\r\n}\r\n\r\n/**\r\n * Load ClickUp config tab\r\n */\r\nfunction loadClickUpConfigTab(ss) {\r\n  const sheet = ss.getSheetByName('clickup_config');\r\n  if (!sheet) {\r\n    return {\r\n      enabled: true,\r\n      include_in_morning: true,\r\n      include_in_eod: true,\r\n      auto_update: true,\r\n      add_comments: true,\r\n      show_weekly_monday: true,\r\n      overdue_warning: true,\r\n      use_clickup_time_estimates: false\r\n    };\r\n  }\r\n\r\n  const data = sheet.getDataRange().getValues();\r\n  const config = {};\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const key = data[i][0];\r\n    let value = data[i][1];\r\n\r\n    if (key) {\r\n      if (value === 'TRUE' || value === true) value = true;\r\n      else if (value === 'FALSE' || value === false) value = false;\r\n      else if (!isNaN(value) && value !== '') value = Number(value);\r\n\r\n      config[key] = value;\r\n    }\r\n  }\r\n\r\n  // Ensure use_clickup_time_estimates defaults to false\r\n  if (config.use_clickup_time_estimates === undefined) {\r\n    config.use_clickup_time_estimates = false;\r\n  }\r\n\r\n  return config;\r\n}\r\n\r\n/**\r\n * Load ClickUp user mapping tab\r\n */\r\nfunction loadClickUpUserMapTab(ss) {\r\n  const sheet = ss.getSheetByName('clickup_user_map');\r\n  if (!sheet) return {};\r\n\r\n  const data = sheet.getDataRange().getValues();\r\n  const map = {};\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    if (data[i][0] && data[i][1]) {\r\n      map[data[i][0]] = {\r\n        clickup_user_id: String(data[i][1]),\r\n        clickup_username: data[i][2] || ''\r\n      };\r\n    }\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\n/**\r\n * Load Odoo config tab\r\n */\r\nfunction loadOdooConfigTab(ss) {\r\n  const sheet = ss.getSheetByName('odoo_config');\r\n  if (!sheet) {\r\n    return { enabled: false, include_in_morning: false, include_in_eod: false };\r\n  }\r\n\r\n  const data = sheet.getDataRange().getValues();\r\n  const config = {};\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const key = data[i][0];\r\n    let value = data[i][1];\r\n\r\n    if (key) {\r\n      if (value === 'TRUE' || value === true) value = true;\r\n      else if (value === 'FALSE' || value === false) value = false;\r\n      else if (!isNaN(value) && value !== '') value = Number(value);\r\n\r\n      config[key] = value;\r\n    }\r\n  }\r\n\r\n  return config;\r\n}\r\n\r\n/**\r\n * Load Odoo user mapping tab\r\n * Maps Google email ‚Üí {odoo_user_id, odoo_username}\r\n */\r\nfunction loadOdooUserMapTab(ss) {\r\n  const sheet = ss.getSheetByName('odoo_user_map');\r\n  if (!sheet) return {};\r\n\r\n  const data = sheet.getDataRange().getValues();\r\n  const map = {};\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    if (data[i][0] && data[i][1]) {\r\n      map[data[i][0]] = {\r\n        odoo_user_id: String(data[i][1]),\r\n        odoo_username: data[i][2] || ''\r\n      };\r\n    }\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\n/**\r\n * Unified task fetcher ‚Äî gets tasks from ClickUp, Odoo, or both\r\n * based on the team member's task_source setting.\r\n * Returns normalized task array in the standard ClickUp-compatible shape.\r\n */\r\nfunction getTasksForUser(email, period) {\r\n  var config = getConfig();\r\n  var member = config.team_members.find(function (m) { return m.email === email; });\r\n  var taskSource = member ? member.task_source : 'clickup';\r\n  var tasks = [];\r\n\r\n  // ClickUp tasks\r\n  if ((taskSource === 'clickup' || taskSource === 'both') && config.clickup_config.enabled) {\r\n    try {\r\n      var clickupTasks = getTasksDueForUser(email, period);\r\n      clickupTasks.forEach(function (t) { t.source = 'clickup'; });\r\n      tasks = tasks.concat(clickupTasks);\r\n    } catch (err) {\r\n      console.error('ClickUp task fetch error for ' + email + ':', err.message);\r\n    }\r\n  }\r\n\r\n  // Odoo tasks\r\n  if ((taskSource === 'odoo' || taskSource === 'both') && config.odoo_config && config.odoo_config.enabled) {\r\n    try {\r\n      var odooRawTasks = getOdooTasksForUser(email, period);\r\n      var normalizedOdoo = normalizeOdooTasks(odooRawTasks);\r\n      tasks = tasks.concat(normalizedOdoo);\r\n    } catch (err) {\r\n      console.error('Odoo task fetch error for ' + email + ':', err.message);\r\n    }\r\n  }\r\n\r\n  // Re-sort merged list: overdue first, then by due date\r\n  tasks.sort(function (a, b) {\r\n    if (a.isOverdue && !b.isOverdue) return -1;\r\n    if (!a.isOverdue && b.isOverdue) return 1;\r\n    if (a.isOverdue && b.isOverdue) return b.daysOverdue - a.daysOverdue;\r\n    if (a.dueDate && b.dueDate) return a.dueDate - b.dueDate;\r\n    return 0;\r\n  });\r\n\r\n  return tasks;\r\n}\r\n\r\n/**\r\n * Check if today is a holiday and return the holiday object (or null)\r\n */\r\nfunction getHolidayInfo(date = new Date()) {\r\n  const config = getConfig();\r\n  const dateStr = Utilities.formatDate(date, config.work_hours.timezone || 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  for (var i = 0; i < config.holidays.length; i++) {\r\n    var h = config.holidays[i];\r\n    var holidayDate;\r\n    if (h.date instanceof Date) {\r\n      holidayDate = Utilities.formatDate(h.date, 'America/Chicago', 'yyyy-MM-dd');\r\n    } else if (typeof h.date === 'string' && h.date.indexOf('T') > -1) {\r\n      holidayDate = Utilities.formatDate(new Date(h.date), 'America/Chicago', 'yyyy-MM-dd');\r\n    } else {\r\n      holidayDate = String(h.date).substring(0, 10);\r\n    }\r\n    if (holidayDate === dateStr) return h;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Check if today is a holiday (any type)\r\n */\r\nfunction isHoliday(date = new Date()) {\r\n  return getHolidayInfo(date) !== null;\r\n}\r\n\r\n/**\r\n * Check if today is a full-day off (type=full or no type specified)\r\n * half_pm and half_am holidays are NOT full days off\r\n */\r\nfunction isFullDayOff(date = new Date()) {\r\n  var holiday = getHolidayInfo(date);\r\n  if (!holiday) return false;\r\n  return !holiday.type || holiday.type === 'full';\r\n}\r\n\r\n/**\r\n * Check if today is a half_pm holiday (morning triggers run, EOD triggers skip)\r\n */\r\nfunction isHalfPmHoliday(date = new Date()) {\r\n  var holiday = getHolidayInfo(date);\r\n  return holiday && holiday.type === 'half_pm';\r\n}\r\n\r\n/**\r\n * Check if today is a workday (at least partial)\r\n */\r\nfunction isWorkday(date = new Date()) {\r\n  const day = date.getDay();\r\n  // Sunday = 0, Saturday = 6\r\n  if (day === 0 || day === 6) return false;\r\n  // Full day off = not a workday. Half-day holidays ARE workdays.\r\n  if (isFullDayOff(date)) return false;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Check if afternoon/EOD triggers should run today\r\n * Returns false on half_pm holidays (morning only) and full holidays\r\n */\r\nfunction isEodWorkday(date = new Date()) {\r\n  if (!isWorkday(date)) return false;\r\n  if (isHalfPmHoliday(date)) return false;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Get work hours for today, with special period override (Ramadan, etc.)\r\n */\r\nfunction getTodayWorkHours() {\r\n  const config = getConfig();\r\n  const today = new Date();\r\n  const dayOfWeek = today.getDay();\r\n\r\n  // Ensure we always return strings in HH:MM format\r\n  const formatTime = (val, defaultVal) => {\r\n    if (!val) return defaultVal;\r\n    if (typeof val === 'string') {\r\n      if (val.indexOf('T') > -1) {\r\n        return Utilities.formatDate(new Date(val), 'America/Chicago', 'HH:mm');\r\n      }\r\n      return val;\r\n    }\r\n    if (val instanceof Date) {\r\n      return Utilities.formatDate(val, 'America/Chicago', 'HH:mm');\r\n    }\r\n    if (typeof val === 'number') {\r\n      const hours = Math.floor(val);\r\n      const mins = Math.round((val - hours) * 60);\r\n      return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;\r\n    }\r\n    return defaultVal;\r\n  };\r\n\r\n  // Check for active special hours period (Ramadan, etc.)\r\n  var specialPeriod = getActiveSpecialPeriod(today);\r\n  if (specialPeriod) {\r\n    if (dayOfWeek === 5) {\r\n      return {\r\n        start: formatTime(specialPeriod.fri_start, '10:00'),\r\n        end: formatTime(specialPeriod.fri_end, '14:00')\r\n      };\r\n    }\r\n    return {\r\n      start: formatTime(specialPeriod.mt_start, '10:00'),\r\n      end: formatTime(specialPeriod.mt_end, '17:00')\r\n    };\r\n  }\r\n\r\n  if (dayOfWeek === 5) { // Friday\r\n    return {\r\n      start: formatTime(config.work_hours.friday_start, '07:00'),\r\n      end: formatTime(config.work_hours.friday_end, '11:00')\r\n    };\r\n  }\r\n\r\n  return {\r\n    start: formatTime(config.work_hours.default_start, '08:00'),\r\n    end: formatTime(config.work_hours.default_end, '17:00')\r\n  };\r\n}\r\n\r\n/**\r\n * Get active team members (all, including not-tracked)\r\n */\r\nfunction getActiveTeamMembers() {\r\n  const config = getConfig();\r\n  return config.team_members.filter(m => m.active);\r\n}\r\n\r\n/**\r\n * Get active team members who should receive prompts (tracked only)\r\n */\r\nfunction getTrackedTeamMembers() {\r\n  const config = getConfig();\r\n  return config.team_members.filter(function (m) {\r\n    return m.active && (m.tracking_mode || 'tracked') === 'tracked';\r\n  });\r\n}\r\n\r\n/**\r\n * Get active team members excluded from tracking\r\n */\r\nfunction getNotTrackedTeamMembers() {\r\n  const config = getConfig();\r\n  return config.team_members.filter(function (m) {\r\n    return m.active && m.tracking_mode === 'not_tracked';\r\n  });\r\n}\r\n\r\n/**\r\n * Get BigQuery project ID\r\n */\r\nfunction getProjectId() {\r\n  const config = getConfig();\r\n  return config.bigquery_project_id || PropertiesService.getScriptProperties().getProperty('BIGQUERY_PROJECT_ID');\r\n}\r\n\r\n/**\r\n * Get recipients for a specific report type\r\n */\r\nfunction getReportRecipients(reportType) {\r\n  const config = getConfig();\r\n  const settings = config.settings;\r\n\r\n  switch (reportType) {\r\n    case 'ai_evaluation':\r\n      return settings.ai_eval_recipients || [settings.manager_email];\r\n    case 'weekly_summary':\r\n      return settings.weekly_summary_recipients || [settings.manager_email];\r\n    case 'escalation':\r\n      return settings.escalation_recipients || [settings.manager_email, settings.ops_leader_email];\r\n    case 'adoption_report':\r\n      var adoptionRecipients = settings.adoption_report_recipients;\r\n      if (adoptionRecipients) {\r\n        return Array.isArray(adoptionRecipients) ? adoptionRecipients : [adoptionRecipients];\r\n      }\r\n      return [settings.manager_email];\r\n    default:\r\n      return [settings.manager_email];\r\n  }\r\n}\r\n\r\n/**\r\n * Load special hours tab (Ramadan, Q4 crunch, etc.)\r\n * Columns: period_name, start_date, end_date, mt_start, mt_end, fri_start, fri_end\r\n */\r\nfunction loadSpecialHoursTab(ss) {\r\n  const sheet = ss.getSheetByName('special_hours');\r\n  if (!sheet) return [];\r\n\r\n  const data = sheet.getDataRange().getValues();\r\n  const periods = [];\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    if (data[i][0]) {\r\n      periods.push({\r\n        name: data[i][0],\r\n        start_date: data[i][1],\r\n        end_date: data[i][2],\r\n        mt_start: data[i][3] || null,\r\n        mt_end: data[i][4] || null,\r\n        fri_start: data[i][5] || null,\r\n        fri_end: data[i][6] || null,\r\n        mt_block2_start: data[i][7] || null,\r\n        mt_block2_end: data[i][8] || null,\r\n        fri_block2_start: data[i][9] || null,\r\n        fri_block2_end: data[i][10] || null\r\n      });\r\n    }\r\n  }\r\n\r\n  return periods;\r\n}\r\n\r\n/**\r\n * Get active special period for a given date (e.g. Ramadan)\r\n * Returns the period object if today falls within it, null otherwise\r\n */\r\nfunction getActiveSpecialPeriod(date) {\r\n  var config = getConfig();\r\n  if (!config.special_hours || config.special_hours.length === 0) return null;\r\n\r\n  var dateStr = Utilities.formatDate(date || new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  for (var i = 0; i < config.special_hours.length; i++) {\r\n    var period = config.special_hours[i];\r\n    var startStr, endStr;\r\n    if (period.start_date instanceof Date) {\r\n      startStr = Utilities.formatDate(period.start_date, 'America/Chicago', 'yyyy-MM-dd');\r\n    } else if (typeof period.start_date === 'string' && period.start_date.indexOf('T') > -1) {\r\n      startStr = Utilities.formatDate(new Date(period.start_date), 'America/Chicago', 'yyyy-MM-dd');\r\n    } else {\r\n      startStr = String(period.start_date).substring(0, 10);\r\n    }\r\n    if (period.end_date instanceof Date) {\r\n      endStr = Utilities.formatDate(period.end_date, 'America/Chicago', 'yyyy-MM-dd');\r\n    } else if (typeof period.end_date === 'string' && period.end_date.indexOf('T') > -1) {\r\n      endStr = Utilities.formatDate(new Date(period.end_date), 'America/Chicago', 'yyyy-MM-dd');\r\n    } else {\r\n      endStr = String(period.end_date).substring(0, 10);\r\n    }\r\n\r\n    if (dateStr >= startStr && dateStr <= endStr) return period;\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Load email mapping tab (Sage HR email ‚Üí Google email)\r\n * Columns: sage_hr_email, google_email, notes\r\n */\r\nfunction loadEmailMappingTab(ss) {\r\n  const sheet = ss.getSheetByName('email_mapping');\r\n  if (!sheet) return {};\r\n\r\n  const data = sheet.getDataRange().getValues();\r\n  const map = {};\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    if (data[i][0] && data[i][1]) {\r\n      map[data[i][0].toLowerCase()] = data[i][1].toLowerCase();\r\n    }\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\n/**\r\n * Resolve email using email mapping (Sage HR ‚Üí Google)\r\n * If no mapping found, returns the original email\r\n */\r\nfunction resolveEmail(sageHrEmail) {\r\n  var config = getConfig();\r\n  var mapped = config.email_mapping[sageHrEmail.toLowerCase()];\r\n  return mapped || sageHrEmail;\r\n}\r\n\r\n/**\r\n * Get OpenAI model from settings (configurable)\r\n */\r\nfunction getOpenAIModel() {\r\n  var config = getConfig();\r\n  return config.settings.openai_model || 'gpt-4o-mini';\r\n}\r\n\r\n/**\r\n * Get late threshold in minutes from settings (configurable)\r\n */\r\nfunction getLateThresholdMin() {\r\n  var config = getConfig();\r\n  return parseInt(config.settings.late_threshold_min) || 15;\r\n}\r\n\r\n// ============================================\r\n// PER-USER WORK SCHEDULE\r\n// ============================================\r\n\r\n/**\r\n * Get the work schedule for a specific user today.\r\n * Returns: { blocks: [{start: 'HH:MM', end: 'HH:MM'}, ...], totalExpectedHours: N, source: string }\r\n * Priority: per-user custom ‚Üí active special period ‚Üí global work_hours\r\n */\r\nfunction getUserWorkSchedule(email) {\r\n  var config = getConfig();\r\n  var member = config.team_members.find(function (m) { return m.email === email; });\r\n  var today = new Date();\r\n  var isFriday = today.getDay() === 5;\r\n\r\n  var formatTime = function (val, defaultVal) {\r\n    if (!val) return defaultVal;\r\n    if (typeof val === 'string') {\r\n      if (val.indexOf('T') > -1) {\r\n        return Utilities.formatDate(new Date(val), 'America/Chicago', 'HH:mm');\r\n      }\r\n      return val;\r\n    }\r\n    if (val instanceof Date) {\r\n      return Utilities.formatDate(val, 'America/Chicago', 'HH:mm');\r\n    }\r\n    if (typeof val === 'number') {\r\n      var hours = Math.floor(val);\r\n      var mins = Math.round((val - hours) * 60);\r\n      return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');\r\n    }\r\n    return defaultVal;\r\n  };\r\n\r\n  // Priority 1: Per-user custom times\r\n  if (member && member.custom_start_time && member.custom_end_time) {\r\n    var blocks = [{\r\n      start: formatTime(member.custom_start_time, '08:00'),\r\n      end: formatTime(member.custom_end_time, '17:00')\r\n    }];\r\n    if (member.custom_block2_start && member.custom_block2_end) {\r\n      blocks.push({\r\n        start: formatTime(member.custom_block2_start, '20:00'),\r\n        end: formatTime(member.custom_block2_end, '23:00')\r\n      });\r\n    }\r\n    return { blocks: blocks, totalExpectedHours: computeTotalHours(blocks), source: 'custom' };\r\n  }\r\n\r\n  // Priority 2: Active special period (global, e.g. Ramadan)\r\n  var specialPeriod = getActiveSpecialPeriod(today);\r\n  if (specialPeriod) {\r\n    var blocks = [];\r\n    if (isFriday) {\r\n      blocks.push({\r\n        start: formatTime(specialPeriod.fri_start, '10:00'),\r\n        end: formatTime(specialPeriod.fri_end, '14:00')\r\n      });\r\n      if (specialPeriod.fri_block2_start && specialPeriod.fri_block2_end) {\r\n        blocks.push({\r\n          start: formatTime(specialPeriod.fri_block2_start, '20:00'),\r\n          end: formatTime(specialPeriod.fri_block2_end, '23:00')\r\n        });\r\n      }\r\n    } else {\r\n      blocks.push({\r\n        start: formatTime(specialPeriod.mt_start, '10:00'),\r\n        end: formatTime(specialPeriod.mt_end, '17:00')\r\n      });\r\n      if (specialPeriod.mt_block2_start && specialPeriod.mt_block2_end) {\r\n        blocks.push({\r\n          start: formatTime(specialPeriod.mt_block2_start, '20:00'),\r\n          end: formatTime(specialPeriod.mt_block2_end, '23:00')\r\n        });\r\n      }\r\n    }\r\n    return { blocks: blocks, totalExpectedHours: computeTotalHours(blocks), source: 'special_period' };\r\n  }\r\n\r\n  // Priority 3: Default global work hours\r\n  if (isFriday) {\r\n    var friBlocks = [{\r\n      start: formatTime(config.work_hours.friday_start, '07:00'),\r\n      end: formatTime(config.work_hours.friday_end, '11:00')\r\n    }];\r\n    return { blocks: friBlocks, totalExpectedHours: parseFloat(config.work_hours.friday_hours_per_day) || computeTotalHours(friBlocks), source: 'default' };\r\n  }\r\n  var defaultBlocks = [{\r\n    start: formatTime(config.work_hours.default_start, '08:00'),\r\n    end: formatTime(config.work_hours.default_end, '17:00')\r\n  }];\r\n  return { blocks: defaultBlocks, totalExpectedHours: parseFloat(config.work_hours.default_hours_per_day) || computeTotalHours(defaultBlocks), source: 'default' };\r\n}\r\n\r\n/**\r\n * Compute total hours across all work blocks.\r\n */\r\nfunction computeTotalHours(blocks) {\r\n  var total = 0;\r\n  for (var i = 0; i < blocks.length; i++) {\r\n    var sParts = blocks[i].start.split(':');\r\n    var eParts = blocks[i].end.split(':');\r\n    var startMin = parseInt(sParts[0]) * 60 + parseInt(sParts[1]);\r\n    var endMin = parseInt(eParts[0]) * 60 + parseInt(eParts[1]);\r\n    if (endMin <= startMin) endMin += 24 * 60; // Handle overnight blocks\r\n    total += (endMin - startMin) / 60;\r\n  }\r\n  return Math.round(total * 10) / 10;\r\n}\r\n\r\n/**\r\n * Convert \"HH:MM\" string to minutes since midnight.\r\n */\r\nfunction timeToMinutes(timeStr) {\r\n  var parts = timeStr.split(':');\r\n  return parseInt(parts[0]) * 60 + parseInt(parts[1]);\r\n}\r\n\r\n/**\r\n * Check if a user has a custom (non-default) schedule.\r\n */\r\nfunction hasCustomSchedule(email) {\r\n  var config = getConfig();\r\n  var member = config.team_members.find(function (m) { return m.email === email; });\r\n  if (!member) return false;\r\n  return !!member.custom_start_time;\r\n}\r\n\r\n/**\r\n * Check if the current special period has split shifts.\r\n */\r\nfunction hasActiveSplitSpecialPeriod() {\r\n  var specialPeriod = getActiveSpecialPeriod(new Date());\r\n  if (!specialPeriod) return false;\r\n  return !!(specialPeriod.mt_block2_start || specialPeriod.fri_block2_start);\r\n}\r\n"
    },
    {
      "name": "Escalation.gs",
      "type": "server_js",
      "source": "/**\r\n * Escalation.gs - Escalation Handling\r\n * Manages alerts and escalations for missed check-ins, overdue tasks, etc.\r\n */\r\n\r\n/**\r\n * Send escalation for missed check-in\r\n */\r\nfunction escalateMissedCheckIn(memberEmail, memberName) {\r\n  const config = getConfig();\r\n  const recipients = getReportRecipients('escalation');\r\n\r\n  // Send individual DMs to employee and managers (BUG #5 fix)\r\n  const allRecipients = [memberEmail, ...recipients.filter(r => r !== memberEmail)];\r\n\r\n  const message = getMissedCheckInEscalation(memberEmail, memberName);\r\n\r\n  sendEscalationToRecipients(allRecipients, message);\r\n\r\n  // Log escalation\r\n  insertIntoBigQuery('escalations', [{\r\n    escalation_id: Utilities.getUuid(),\r\n    escalation_type: 'MISSED_CHECKIN',\r\n    user_email: memberEmail,\r\n    recipients: JSON.stringify(recipients),\r\n    created_at: new Date().toISOString()\r\n  }]);\r\n\r\n  logSystemEvent('ESCALATION', 'MISSED_CHECKIN', { user: memberEmail });\r\n}\r\n\r\n/**\r\n * Send escalation for missed EOD\r\n */\r\nfunction escalateMissedEod(memberEmail, memberName) {\r\n  const config = getConfig();\r\n  const recipients = getReportRecipients('escalation');\r\n\r\n  const allRecipients = [memberEmail, ...recipients.filter(r => r !== memberEmail)];\r\n\r\n  const message = getMissedEodEscalation(memberEmail, memberName);\r\n\r\n  sendEscalationToRecipients(allRecipients, message);\r\n\r\n  insertIntoBigQuery('escalations', [{\r\n    escalation_id: Utilities.getUuid(),\r\n    escalation_type: 'MISSED_EOD',\r\n    user_email: memberEmail,\r\n    recipients: JSON.stringify(recipients),\r\n    created_at: new Date().toISOString()\r\n  }]);\r\n\r\n  logSystemEvent('ESCALATION', 'MISSED_EOD', { user: memberEmail });\r\n}\r\n\r\n/**\r\n * Send overdue task escalation\r\n */\r\nfunction escalateOverdueTask(taskId, taskName, assigneeEmail, daysOverdue) {\r\n  const config = getConfig();\r\n  const recipients = getReportRecipients('escalation');\r\n\r\n  const task = getTaskById(taskId);\r\n  const taskUrl = task ? task.url : '';\r\n\r\n  const message = `üö® **Overdue Task Alert**\\n\\n` +\r\n    `Task: \"${taskName}\"\\n` +\r\n    `Assigned to: ${assigneeEmail}\\n` +\r\n    `Days overdue: ${daysOverdue}\\n\\n` +\r\n    `This task has been overdue for ${daysOverdue} days.\\n` +\r\n    `Please review and take action.\\n\\n` +\r\n    (taskUrl ? `[View in ClickUp](${taskUrl})` : '');\r\n\r\n  recipients.forEach(recipient => {\r\n    sendDirectMessage(recipient, message);\r\n  });\r\n\r\n  insertIntoBigQuery('escalations', [{\r\n    escalation_id: Utilities.getUuid(),\r\n    escalation_type: 'OVERDUE_TASK',\r\n    user_email: assigneeEmail,\r\n    task_id: taskId,\r\n    task_name: taskName,\r\n    days_overdue: daysOverdue,\r\n    recipients: JSON.stringify(recipients),\r\n    created_at: new Date().toISOString()\r\n  }]);\r\n\r\n  logSystemEvent('ESCALATION', 'OVERDUE_TASK', {\r\n    user: assigneeEmail,\r\n    task: taskName,\r\n    days: daysOverdue\r\n  });\r\n}\r\n\r\n/**\r\n * Check and send morning escalations\r\n */\r\nfunction checkMorningEscalations() {\r\n  const teamMembers = getCachedWorkingEmployees();\r\n  const config = getConfig();\r\n  const todayCheckIns = getTodayCheckIns();\r\n  const checkedInEmails = new Set(todayCheckIns.map(c => c.user_email));\r\n\r\n  // Skip not-tracked users from escalation\r\n  const missing = teamMembers.filter(function (m) {\r\n    if (checkedInEmails.has(m.email)) return false;\r\n    var fullMember = config.team_members.find(function (tm) { return tm.email === m.email; });\r\n    if (fullMember && fullMember.tracking_mode === 'not_tracked') return false;\r\n    return true;\r\n  });\r\n\r\n  for (const member of missing) {\r\n    // Log missed check-in\r\n    logMissedCheckIn(member.email, new Date(), 'CHECKIN');\r\n\r\n    // Send escalation\r\n    escalateMissedCheckIn(member.email, member.name);\r\n  }\r\n\r\n  // Also check for chronic overdue\r\n  checkChronicOverdueAlerts();\r\n\r\n  // Check team threshold\r\n  checkTeamOverdueThreshold();\r\n\r\n  // Check for persistent blockers\r\n  checkPersistentBlockers();\r\n\r\n  return {\r\n    escalated: missing.length,\r\n    members: missing.map(m => m.email)\r\n  };\r\n}\r\n\r\n/**\r\n * Check and send EOD escalations\r\n */\r\nfunction checkEodEscalations() {\r\n  const teamMembers = getCachedWorkingEmployees();\r\n  const config = getConfig();\r\n  const todayEods = getTodayEodReports();\r\n  const submittedEmails = new Set(todayEods.map(e => e.user_email));\r\n\r\n  // Skip not-tracked users from escalation\r\n  const missing = teamMembers.filter(function (m) {\r\n    if (submittedEmails.has(m.email)) return false;\r\n    var fullMember = config.team_members.find(function (tm) { return tm.email === m.email; });\r\n    if (fullMember && fullMember.tracking_mode === 'not_tracked') return false;\r\n    return true;\r\n  });\r\n\r\n  for (const member of missing) {\r\n    // Log missed EOD\r\n    logMissedCheckIn(member.email, new Date(), 'EOD');\r\n\r\n    // Send escalation\r\n    escalateMissedEod(member.email, member.name);\r\n  }\r\n\r\n  return {\r\n    escalated: missing.length,\r\n    members: missing.map(m => m.email)\r\n  };\r\n}\r\n\r\n/**\r\n * Daily check for capacity warnings\r\n * Alerts if someone has \"no time\" delay reason too many times\r\n */\r\nfunction checkCapacityWarnings() {\r\n  const config = getConfig();\r\n  const projectId = getProjectId();\r\n  const threshold = 5; // 5+ \"no time\" delays in a week\r\n\r\n  const query = `\r\n    SELECT \r\n      user_email,\r\n      COUNT(*) as no_time_count\r\n    FROM \\`${projectId}.checkin_bot.task_delays\\`\r\n    WHERE delay_reason = 'NO_TIME'\r\n      AND timestamp >= TIMESTAMP_TRUNC(CURRENT_TIMESTAMP(), WEEK(MONDAY))\r\n    GROUP BY user_email\r\n    HAVING COUNT(*) >= ${threshold}\r\n  `;\r\n\r\n  const results = runBigQueryQuery(query);\r\n\r\n  if (results && results.length > 0) {\r\n    const recipients = getReportRecipients('escalation');\r\n\r\n    results.forEach(row => {\r\n      const message = `‚ö†Ô∏è **Capacity Warning**\\n\\n` +\r\n        `${row.user_email} has used \"No time today\" as a delay reason **${row.no_time_count} times** this week.\\n\\n` +\r\n        `This may indicate workload issues. Consider reviewing their task assignments.`;\r\n\r\n      recipients.forEach(recipient => {\r\n        sendDirectMessage(recipient, message);\r\n      });\r\n    });\r\n\r\n    logSystemEvent('CAPACITY_WARNING', 'SENT', {\r\n      peopleWarned: results.length\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Check for persistent blockers (same blocker 2+ consecutive days)\r\n * Called as part of morning escalations\r\n */\r\nfunction checkPersistentBlockers() {\r\n  var projectId = getProjectId();\r\n  var today = new Date();\r\n  var config = getConfig();\r\n  var blockerDays = parseInt(config.settings.blocker_escalation_days) || 2;\r\n  var lookback = new Date(today);\r\n  lookback.setDate(today.getDate() - (blockerDays + 1));\r\n  var startStr = Utilities.formatDate(lookback, 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  var query = 'SELECT user_email, blockers, eod_date ' +\r\n    'FROM `' + projectId + '.' + DATASET_ID + '.v_eod_reports` ' +\r\n    'WHERE eod_date >= \"' + startStr + '\" AND blockers IS NOT NULL AND blockers != \"\" ' +\r\n    'ORDER BY user_email, eod_date';\r\n\r\n  var results = runBigQueryQuery(query);\r\n\r\n  // Group by user\r\n  var userBlockers = {};\r\n  results.forEach(function (r) {\r\n    if (!userBlockers[r.user_email]) userBlockers[r.user_email] = [];\r\n    userBlockers[r.user_email].push({ date: r.eod_date, blocker: r.blockers });\r\n  });\r\n\r\n  var teamMembers = getCachedWorkingEmployees();\r\n  var nameMap = {};\r\n  teamMembers.forEach(function (m) { nameMap[m.email] = m.name || m.email.split('@')[0]; });\r\n\r\n  // Check for consecutive days with blockers\r\n  Object.keys(userBlockers).forEach(function (email) {\r\n    var entries = userBlockers[email];\r\n    if (entries.length >= blockerDays) {\r\n      var name = nameMap[email] || email;\r\n      var blockerTexts = entries.map(function (e) { return e.date + ': ' + e.blocker; }).join('\\n');\r\n\r\n      var message = 'üî¥ *Persistent Blocker Alert*\\n\\n' +\r\n        name + ' has reported blockers for ' + entries.length + ' consecutive days:\\n\\n' +\r\n        blockerTexts + '\\n\\n' +\r\n        'This may need manager intervention.';\r\n\r\n      sendDirectMessage(config.settings.manager_email, message);\r\n\r\n      insertIntoBigQuery('escalations', [{\r\n        escalation_id: Utilities.getUuid(),\r\n        escalation_type: 'PERSISTENT_BLOCKER',\r\n        user_email: email,\r\n        recipients: JSON.stringify([config.settings.manager_email]),\r\n        created_at: new Date().toISOString()\r\n      }]);\r\n    }\r\n  });\r\n}\r\n"
    },
    {
      "name": "Gamification.gs",
      "type": "server_js",
      "source": "/**\r\n * Gamification.gs - Badges, Streaks & Leaderboards\r\n * Handles gamification features\r\n */\r\n\r\n/**\r\n * Badge definitions\r\n */\r\nconst BADGES = {\r\n  // Attendance badges\r\n  EARLY_BIRD: { emoji: 'üåÖ', name: 'Early Bird', description: 'Checked in before start time every day this week' },\r\n  IRONMAN: { emoji: 'ü¶æ', name: 'Ironman', description: '20+ consecutive workdays with check-in and EOD' },\r\n  PUNCTUAL: { emoji: '‚è∞', name: 'Punctual Pro', description: '100% on-time check-ins this week' },\r\n\r\n  // Task badges\r\n  TASK_CRUSHER: { emoji: 'üéØ', name: 'Task Crusher', description: '100% completion rate for the week' },\r\n  ZERO_OVERDUE: { emoji: '‚ö°', name: 'Zero Overdue', description: 'No overdue tasks all week' },\r\n  BACKLOG_BUSTER: { emoji: 'üìâ', name: 'Backlog Buster', description: 'Cleared 5+ overdue tasks in one day' },\r\n  NO_DELAYS: { emoji: 'üî•', name: 'No Delays', description: 'Didn\\'t move any tasks all week' },\r\n  PRODUCTIVITY_STAR: { emoji: 'üöÄ', name: 'Productivity Star', description: 'Most tasks completed this week (Top 1)' },\r\n  ON_TIME_CHAMPION: { emoji: 'üèÖ', name: 'On-Time Champion', description: '100% tasks completed by due date this week' },\r\n\r\n  // Consistency badges\r\n  CONSISTENCY_KING: { emoji: 'üëë', name: 'Consistency King', description: '100% monthly check-in rate' },\r\n  BLOCKER_BUSTER: { emoji: 'üí™', name: 'Blocker Buster', description: '0 blockers reported for 2+ consecutive weeks' },\r\n\r\n  // Streak badges\r\n  STREAK_5: { emoji: 'üî•', name: '5-Day Streak', description: '5 consecutive on-time check-ins' },\r\n  STREAK_10: { emoji: 'üî•üî•', name: '10-Day Streak', description: '10 consecutive on-time check-ins' },\r\n  STREAK_20: { emoji: 'üî•üî•üî•', name: '20-Day Streak', description: '20 consecutive on-time check-ins' }\r\n};\r\n\r\n/**\r\n * Calculate badges earned this week\r\n */\r\nfunction calculateWeeklyBadges() {\r\n  const teamMembers = getCachedWorkingEmployees();\r\n  const config = getConfig();\r\n  const badges = [];\r\n\r\n  // We need task leaderboard to determine Productivity Star (top 1)\r\n  var topCompleter = null;\r\n  if (config.clickup_config.enabled) {\r\n    try {\r\n      var taskLb = buildTaskCompletionLeaderboard();\r\n      if (taskLb.length > 0 && taskLb[0].completed > 0) {\r\n        topCompleter = taskLb[0].email;\r\n      }\r\n    } catch (err) {\r\n      console.error('Error building task leaderboard for badges:', err.message);\r\n    }\r\n  }\r\n\r\n  for (const member of teamMembers) {\r\n    const memberBadges = [];\r\n    const name = member.name || member.email.split('@')[0];\r\n\r\n    // Get weekly stats\r\n    const weeklyStats = getUserWeeklyStats(member.email);\r\n    const streak = getUserStreak(member.email);\r\n\r\n    // ‚îÄ‚îÄ Attendance badges ‚îÄ‚îÄ\r\n\r\n    // Punctual Pro: 100% on-time check-ins this week (5/5 on-time, full week)\r\n    if (parseInt(weeklyStats.checkin_days) >= 5 && parseInt(weeklyStats.late_days) === 0) {\r\n      memberBadges.push(BADGES.PUNCTUAL);\r\n    }\r\n\r\n    // Early Bird: Checked in on-time every day checked in (at least 3 days, 0 late)\r\n    // Different from Punctual ‚Äî can earn with partial week if always on-time\r\n    var checkinDays = parseInt(weeklyStats.checkin_days) || 0;\r\n    var lateDays = parseInt(weeklyStats.late_days) || 0;\r\n    if (checkinDays >= 3 && checkinDays < 5 && lateDays === 0) {\r\n      memberBadges.push(BADGES.EARLY_BIRD);\r\n    }\r\n\r\n    // Ironman: 20+ consecutive workdays with both check-in AND EOD\r\n    // Use streak (on-time check-ins) as proxy; also verify EODs\r\n    if (streak >= 20 && parseInt(weeklyStats.eod_days) >= 5) {\r\n      memberBadges.push(BADGES.IRONMAN);\r\n    }\r\n\r\n    // ‚îÄ‚îÄ Streak badges ‚îÄ‚îÄ\r\n    if (streak >= 20) {\r\n      memberBadges.push(BADGES.STREAK_20);\r\n    } else if (streak >= 10) {\r\n      memberBadges.push(BADGES.STREAK_10);\r\n    } else if (streak >= 5) {\r\n      memberBadges.push(BADGES.STREAK_5);\r\n    }\r\n\r\n    // ‚îÄ‚îÄ Task badges (if ClickUp/Odoo enabled) ‚îÄ‚îÄ\r\n    if (config.clickup_config.enabled) {\r\n      const taskStats = getUserTaskStats(member.email);\r\n\r\n      if (taskStats) {\r\n        const completionRate = parseFloat(taskStats.avg_completion_rate) || 0;\r\n        const totalOverdue = parseInt(taskStats.total_overdue) || 0;\r\n        const totalMoved = parseInt(taskStats.total_moved) || 0;\r\n        const totalCompleted = parseInt(taskStats.total_completed) || 0;\r\n        const totalDue = parseInt(taskStats.total_due) || 0;\r\n\r\n        // Task Crusher: 100% completion rate\r\n        if (completionRate >= 1.0 && totalDue > 0) {\r\n          memberBadges.push(BADGES.TASK_CRUSHER);\r\n        }\r\n\r\n        // Zero Overdue: no overdue tasks all week (must have had tasks due)\r\n        if (totalOverdue === 0 && totalDue > 0) {\r\n          memberBadges.push(BADGES.ZERO_OVERDUE);\r\n        }\r\n\r\n        // No Delays: didn't move any tasks all week\r\n        if (totalMoved === 0 && totalDue > 0) {\r\n          memberBadges.push(BADGES.NO_DELAYS);\r\n        }\r\n\r\n        // On-Time Champion: 100% tasks completed by due date (completion rate = 1.0 AND zero overdue)\r\n        if (completionRate >= 1.0 && totalOverdue === 0 && totalDue > 0) {\r\n          memberBadges.push(BADGES.ON_TIME_CHAMPION);\r\n        }\r\n\r\n        // Productivity Star: Most tasks completed this week (Top 1)\r\n        if (topCompleter && member.email === topCompleter && totalCompleted > 0) {\r\n          memberBadges.push(BADGES.PRODUCTIVITY_STAR);\r\n        }\r\n\r\n        // Backlog Buster: Check if cleared 5+ overdue tasks in a single day this week\r\n        try {\r\n          var backlogBusted = checkBacklogBuster(member.email);\r\n          if (backlogBusted) {\r\n            memberBadges.push(BADGES.BACKLOG_BUSTER);\r\n          }\r\n        } catch (err) {\r\n          // Silently skip\r\n        }\r\n      }\r\n    }\r\n\r\n    // ‚îÄ‚îÄ Consistency badges ‚îÄ‚îÄ\r\n\r\n    // Consistency King: 100% monthly check-in rate\r\n    try {\r\n      var monthlyRate = getMonthlyCheckinRate(member.email);\r\n      if (monthlyRate >= 100) {\r\n        memberBadges.push(BADGES.CONSISTENCY_KING);\r\n      }\r\n    } catch (err) {\r\n      // Silently skip\r\n    }\r\n\r\n    // Blocker Buster: 0 blockers for 2+ consecutive weeks\r\n    try {\r\n      var noBlockerWeeks = getConsecutiveNoBlockerWeeks(member.email);\r\n      if (noBlockerWeeks >= 2) {\r\n        memberBadges.push(BADGES.BLOCKER_BUSTER);\r\n      }\r\n    } catch (err) {\r\n      // Silently skip\r\n    }\r\n\r\n    // Add to badges list\r\n    memberBadges.forEach(badge => {\r\n      badges.push({\r\n        email: member.email,\r\n        name: name,\r\n        badge: badge.emoji,\r\n        badgeName: badge.name,\r\n        description: badge.description\r\n      });\r\n    });\r\n  }\r\n\r\n  return badges;\r\n}\r\n\r\n/**\r\n * Check if user cleared 5+ overdue tasks in a single day this week\r\n * Cross-references completed tasks with overdue snapshots to count only overdue completions\r\n */\r\nfunction checkBacklogBuster(email) {\r\n  var projectId = getProjectId();\r\n  var safeEmail = sanitizeForBQ(email);\r\n\r\n  // Get latest action per task, then join with overdue_snapshots to count only tasks whose final action is COMPLETE\r\n  var result = runBigQueryQuery(\r\n    'SELECT DATE(a.timestamp) as action_date, COUNT(*) as completed_overdue'\r\n    + ' FROM ('\r\n    + '   SELECT task_id, user_email, action_type, timestamp FROM ('\r\n    + '     SELECT task_id, user_email, action_type, timestamp,'\r\n    + '       ROW_NUMBER() OVER (PARTITION BY task_id ORDER BY timestamp DESC) as rn'\r\n    + '     FROM `' + projectId + '.checkin_bot.clickup_task_actions`'\r\n    + '     WHERE user_email = \\'' + safeEmail + '\\''\r\n    + '       AND timestamp >= TIMESTAMP_TRUNC(CURRENT_TIMESTAMP(), WEEK(MONDAY))'\r\n    + '   ) WHERE rn = 1 AND action_type = \\'COMPLETE\\''\r\n    + ' ) a'\r\n    + ' INNER JOIN `' + projectId + '.checkin_bot.overdue_snapshots` o'\r\n    + '   ON a.task_id = o.task_id AND a.user_email = o.user_email'\r\n    + ' GROUP BY DATE(a.timestamp)'\r\n    + ' HAVING COUNT(*) >= 5'\r\n    + ' LIMIT 1'\r\n  );\r\n\r\n  return result && result.length > 0;\r\n}\r\n\r\n/**\r\n * Get monthly check-in rate for a user (current month)\r\n */\r\nfunction getMonthlyCheckinRate(email) {\r\n  var projectId = getProjectId();\r\n  var safeEmail = sanitizeForBQ(email);\r\n\r\n  var result = runBigQueryQuery(\r\n    'SELECT COUNT(DISTINCT checkin_date) as checkin_days'\r\n    + ' FROM `' + projectId + '.checkin_bot.check_ins`'\r\n    + ' WHERE user_email = \\'' + safeEmail + '\\''\r\n    + '   AND checkin_date >= DATE_TRUNC(CURRENT_DATE(), MONTH)'\r\n  );\r\n\r\n  if (!result || result.length === 0) return 0;\r\n\r\n  var checkinDays = parseInt(result[0].checkin_days) || 0;\r\n  // Calculate workdays elapsed this month\r\n  var today = new Date();\r\n  var firstOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);\r\n  var workdaysElapsed = 0;\r\n  var d = new Date(firstOfMonth);\r\n  while (d <= today) {\r\n    var dow = d.getDay();\r\n    if (dow !== 0 && dow !== 6) workdaysElapsed++;\r\n    d.setDate(d.getDate() + 1);\r\n  }\r\n\r\n  return workdaysElapsed > 0 ? Math.round(checkinDays / workdaysElapsed * 100) : 0;\r\n}\r\n\r\n/**\r\n * Get number of consecutive weeks with 0 blockers reported\r\n */\r\nfunction getConsecutiveNoBlockerWeeks(email) {\r\n  var projectId = getProjectId();\r\n  var safeEmail = sanitizeForBQ(email);\r\n\r\n  // Check last 4 weeks for blocker reports\r\n  var result = runBigQueryQuery(\r\n    'SELECT EXTRACT(ISOWEEK FROM eod_date) as week_num,'\r\n    + ' SUM(CASE WHEN blockers IS NOT NULL AND blockers != \\'\\' THEN 1 ELSE 0 END) as blocker_count'\r\n    + ' FROM `' + projectId + '.checkin_bot.v_eod_reports`'\r\n    + ' WHERE user_email = \\'' + safeEmail + '\\''\r\n    + '   AND eod_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 28 DAY)'\r\n    + ' GROUP BY week_num'\r\n    + ' ORDER BY week_num DESC'\r\n  );\r\n\r\n  if (!result || result.length === 0) return 0;\r\n\r\n  var consecutive = 0;\r\n  for (var i = 0; i < result.length; i++) {\r\n    if (parseInt(result[i].blocker_count) === 0) {\r\n      consecutive++;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return consecutive;\r\n}\r\n\r\n/**\r\n * Build attendance leaderboard\r\n */\r\nfunction buildAttendanceLeaderboard() {\r\n  const teamMembers = getCachedWorkingEmployees();\r\n  const leaderboard = [];\r\n\r\n  for (const member of teamMembers) {\r\n    const weeklyStats = getUserWeeklyStats(member.email);\r\n    const name = member.name || member.email.split('@')[0];\r\n\r\n    const totalCheckIns = parseInt(weeklyStats.checkin_days) || 0;\r\n    const lateDays = parseInt(weeklyStats.late_days) || 0;\r\n    const onTimeRate = totalCheckIns > 0\r\n      ? Math.round((totalCheckIns - lateDays) / totalCheckIns * 100)\r\n      : 0;\r\n\r\n    leaderboard.push({\r\n      email: member.email,\r\n      name: name,\r\n      checkIns: totalCheckIns,\r\n      onTimeRate: onTimeRate,\r\n      streak: getUserStreak(member.email)\r\n    });\r\n  }\r\n\r\n  // Sort by on-time rate, then by check-ins\r\n  leaderboard.sort((a, b) => {\r\n    if (b.onTimeRate !== a.onTimeRate) return b.onTimeRate - a.onTimeRate;\r\n    return b.checkIns - a.checkIns;\r\n  });\r\n\r\n  return leaderboard;\r\n}\r\n\r\n/**\r\n * Build task completion leaderboard\r\n */\r\nfunction buildTaskCompletionLeaderboard() {\r\n  const config = getConfig();\r\n  if (!config.clickup_config.enabled) return [];\r\n\r\n  const teamMembers = getCachedWorkingEmployees();\r\n  const leaderboard = [];\r\n\r\n  for (const member of teamMembers) {\r\n    const taskStats = getUserTaskStats(member.email);\r\n    const name = member.name || member.email.split('@')[0];\r\n\r\n    if (taskStats) {\r\n      const total = parseInt(taskStats.total_due) || 0;\r\n      const completed = parseInt(taskStats.total_completed) || 0;\r\n      const completionRate = total > 0 ? Math.round(completed / total * 100) : 100;\r\n\r\n      leaderboard.push({\r\n        email: member.email,\r\n        name: name,\r\n        total: total,\r\n        completed: completed,\r\n        completionRate: completionRate\r\n      });\r\n    }\r\n  }\r\n\r\n  // Sort by completion rate (if both have total_completed > 0), then by total completed\r\n  leaderboard.sort((a, b) => {\r\n    if (b.completed > 0 && a.completed > 0) {\r\n      if (b.completionRate !== a.completionRate) return b.completionRate - a.completionRate;\r\n      return b.completed - a.completed;\r\n    }\r\n    return b.completed - a.completed;\r\n  });\r\n\r\n  return leaderboard;\r\n}\r\n\r\n/**\r\n * Get people with zero overdue tasks\r\n */\r\nfunction getZeroOverdueList() {\r\n  const config = getConfig();\r\n  if (!config.clickup_config.enabled) return [];\r\n\r\n  const teamMembers = getCachedWorkingEmployees();\r\n  const zeroOverdue = [];\r\n\r\n  for (const member of teamMembers) {\r\n    const tasks = getTasksForUser(member.email, 'today');\r\n    const overdue = tasks.filter(t => t.isOverdue);\r\n\r\n    if (overdue.length === 0) {\r\n      zeroOverdue.push({\r\n        email: member.email,\r\n        name: member.name || member.email.split('@')[0]\r\n      });\r\n    }\r\n  }\r\n\r\n  return zeroOverdue;\r\n}\r\n\r\n/**\r\n * Post weekly gamification to channel\r\n */\r\nfunction postWeeklyGamification() {\r\n  console.log('Posting weekly gamification...');\r\n\r\n  if (!isWorkday()) {\r\n    console.log('Not a workday, skipping gamification');\r\n    return;\r\n  }\r\n\r\n  const attendanceLeaderboard = buildAttendanceLeaderboard();\r\n  const taskLeaderboard = buildTaskCompletionLeaderboard();\r\n  const zeroOverdue = getZeroOverdueList();\r\n  const badges = calculateWeeklyBadges();\r\n\r\n  const leaderboard = {\r\n    attendance: attendanceLeaderboard.slice(0, 5),\r\n    taskCompletion: taskLeaderboard.slice(0, 5),\r\n    zeroOverdue: zeroOverdue\r\n  };\r\n\r\n  const message = buildWeeklyGamificationMessage(leaderboard, badges);\r\n\r\n  const spaceId = getTeamUpdatesChannel();\r\n  if (spaceId) {\r\n    sendChannelMessage(spaceId, message);\r\n  }\r\n\r\n  // BUG #15 fix: Actually award badges (log to BigQuery + notify users)\r\n  if (badges && badges.length > 0) {\r\n    for (var i = 0; i < badges.length; i++) {\r\n      try {\r\n        // Find the badge key from BADGES constant\r\n        var badgeKey = null;\r\n        for (var key in BADGES) {\r\n          if (BADGES[key].name === badges[i].badgeName) {\r\n            badgeKey = key;\r\n            break;\r\n          }\r\n        }\r\n        if (badgeKey) {\r\n          awardBadge(badges[i].email, badgeKey);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error awarding badge to ' + badges[i].email + ':', err.message);\r\n      }\r\n    }\r\n  }\r\n\r\n  logSystemEvent('WEEKLY_GAMIFICATION', 'SUCCESS', {\r\n    badgesAwarded: badges.length\r\n  });\r\n\r\n  console.log('Weekly gamification posted');\r\n}\r\n\r\n/**\r\n * Award badge to user\r\n */\r\nfunction awardBadge(userEmail, badgeKey) {\r\n  const badge = BADGES[badgeKey];\r\n  if (!badge) return;\r\n\r\n  // Log to BigQuery\r\n  insertIntoBigQuery('badges_awarded', [{\r\n    badge_id: Utilities.getUuid(),\r\n    user_email: userEmail,\r\n    badge_key: badgeKey,\r\n    badge_emoji: badge.emoji,\r\n    badge_name: badge.name,\r\n    awarded_at: new Date().toISOString()\r\n  }]);\r\n\r\n  // Optionally notify user\r\n  const message = `üéâ **Badge Earned!**\\n\\n${badge.emoji} **${badge.name}**\\n${badge.description}`;\r\n  sendDirectMessage(userEmail, message);\r\n}\r\n"
    },
    {
      "name": "OdooService.gs",
      "type": "server_js",
      "source": "/**\r\n * OdooService.gs - Odoo 18 Task Integration\r\n *\r\n * Connects to Odoo via JSON-RPC to fetch project tasks\r\n * for the daily check-in bot.\r\n *\r\n * Odoo Instance: https://k-brands.odoo.com\r\n * Database: k-brands\r\n *\r\n * Required Script Properties:\r\n *   - ODOO_API_KEY\r\n *   - ODOO_DB (database name - find via database selector or admin)\r\n *\r\n * ============================================\r\n * SETUP INSTRUCTIONS:\r\n * ============================================\r\n *\r\n * 1. Find your Odoo Database Name:\r\n *    - Go to https://k-brands.odoo.com/web/database/selector\r\n *    - Or check with your Odoo administrator\r\n *    - Common patterns: subdomain, subdomain-main, subdomain-production\r\n *\r\n * 2. Generate Odoo API Key:\r\n *    - Log into https://k-brands.odoo.com as tools@k-brands.com\r\n *    - Go to user profile (top right) ‚Üí Preferences\r\n *    - Account Security tab ‚Üí Developer API Keys\r\n *    - Click \"New API Key\", name it \"Check-in Bot\"\r\n *    - Copy the key immediately (shown only once)\r\n *\r\n * 3. Add Script Properties:\r\n *    - In Apps Script, go to Project Settings (gear icon)\r\n *    - Scroll to Script Properties\r\n *    - Add: ODOO_API_KEY = [your key]\r\n *    - Add: ODOO_DB = [your database name]\r\n *\r\n * 4. Test the connection:\r\n *    - Run testOdooConnection() function\r\n *    - Check logs for success message\r\n *\r\n * 5. Verify task access:\r\n *    - Run testGetTasks() to see sample tasks\r\n *    - Run testGetUserTasks() with a real email\r\n *\r\n * ============================================\r\n * API DOCUMENTATION REFERENCES:\r\n * ============================================\r\n * - Odoo 18 External API: https://www.odoo.com/documentation/18.0/developer/reference/external_api.html\r\n * - JSON-RPC Guide: https://www.cybrosys.com/odoo/odoo-books/odoo-16-development/rpc/json-rpc/\r\n * - API Key Auth: https://www.odoo.com/forum/help-1/odoo-17-json-rpc-and-api-key-263158\r\n */\r\n\r\n// ===========================================\r\n// CONFIGURATION\r\n// ===========================================\r\n\r\nconst ODOO_URL = 'https://k-brands.odoo.com';\r\nconst ODOO_USERNAME = 'tools@k-brands.com';\r\nconst ODOO_JSONRPC_ENDPOINT = ODOO_URL + '/jsonrpc';\r\n\r\n// Cache keys\r\nconst ODOO_UID_CACHE_KEY = 'odoo_uid';\r\nconst ODOO_CACHE_DURATION = 1800; // 30 minutes in seconds\r\n\r\n// ===========================================\r\n// CORE API METHODS\r\n// ===========================================\r\n\r\n/**\r\n * Get Odoo database name from Script Properties\r\n * @returns {string|null} - Database name or null if not found\r\n */\r\nfunction getOdooDatabase() {\r\n  const props = PropertiesService.getScriptProperties();\r\n  const db = props.getProperty('ODOO_DB');\r\n\r\n  if (!db) {\r\n    console.error('ODOO_DB not found in Script Properties. Please add your Odoo database name.');\r\n    console.error('To find your database name, go to: https://k-brands.odoo.com/web/database/selector');\r\n    return null;\r\n  }\r\n\r\n  return db;\r\n}\r\n\r\n/**\r\n * Get API key from Script Properties\r\n * @returns {string|null} - API key or null if not found\r\n */\r\nfunction getOdooApiKey() {\r\n  const props = PropertiesService.getScriptProperties();\r\n  const apiKey = props.getProperty('ODOO_API_KEY');\r\n\r\n  if (!apiKey) {\r\n    console.error('ODOO_API_KEY not found in Script Properties');\r\n    return null;\r\n  }\r\n\r\n  return apiKey;\r\n}\r\n\r\n/**\r\n * Authenticate with Odoo and get user ID (uid)\r\n * Uses JSON-RPC call to /jsonrpc with common service\r\n * @returns {number|null} - Odoo user ID or null on failure\r\n */\r\nfunction odooAuthenticate() {\r\n  console.log('Authenticating with Odoo...');\r\n\r\n  const apiKey = getOdooApiKey();\r\n  const db = getOdooDatabase();\r\n\r\n  if (!apiKey || !db) {\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    const result = odooJsonRpc('common', 'login', [db, ODOO_USERNAME, apiKey]);\r\n\r\n    if (result && typeof result === 'number') {\r\n      console.log('Successfully authenticated with Odoo. UID:', result);\r\n      return result;\r\n    } else {\r\n      console.error('Authentication failed. Response:', result);\r\n      return null;\r\n    }\r\n  } catch (error) {\r\n    console.error('Odoo authentication error:', error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Generic JSON-RPC call to Odoo\r\n * @param {string} service - 'common' or 'object'\r\n * @param {string} method - RPC method name\r\n * @param {Array} args - Method arguments\r\n * @returns {*} - Response from Odoo or null on error\r\n */\r\nfunction odooJsonRpc(service, method, args) {\r\n  const payload = {\r\n    jsonrpc: '2.0',\r\n    method: 'call',\r\n    params: {\r\n      service: service,\r\n      method: method,\r\n      args: args\r\n    },\r\n    id: Math.floor(Math.random() * 1000000000)\r\n  };\r\n\r\n  const options = {\r\n    method: 'post',\r\n    contentType: 'application/json',\r\n    payload: JSON.stringify(payload),\r\n    muteHttpExceptions: true,\r\n    timeout: 30000 // 30 second timeout\r\n  };\r\n\r\n  try {\r\n    console.log(`Odoo RPC: ${service}.${method}`);\r\n    const response = UrlFetchApp.fetch(ODOO_JSONRPC_ENDPOINT, options);\r\n    const responseCode = response.getResponseCode();\r\n    const responseText = response.getContentText();\r\n\r\n    if (responseCode !== 200) {\r\n      console.error(`Odoo HTTP error ${responseCode}:`, responseText);\r\n      return null;\r\n    }\r\n\r\n    const jsonResponse = JSON.parse(responseText);\r\n\r\n    if (jsonResponse.error) {\r\n      console.error('Odoo RPC error:', JSON.stringify(jsonResponse.error));\r\n      return null;\r\n    }\r\n\r\n    return jsonResponse.result;\r\n\r\n  } catch (error) {\r\n    console.error('Odoo RPC request failed:', error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Execute Odoo model method (search_read, create, write, etc.)\r\n * @param {string} model - Odoo model name (e.g., 'project.task')\r\n * @param {string} method - Method name (e.g., 'search_read')\r\n * @param {Array} args - Positional arguments (domain, etc.)\r\n * @param {Object} kwargs - Keyword arguments (fields, limit, etc.)\r\n * @returns {*} - Result from Odoo or null on error\r\n */\r\nfunction odooExecute(model, method, args = [], kwargs = {}) {\r\n  const uid = getCachedUid();\r\n  if (!uid) {\r\n    console.error('Cannot execute: No valid Odoo UID');\r\n    return null;\r\n  }\r\n\r\n  const apiKey = getOdooApiKey();\r\n  const db = getOdooDatabase();\r\n\r\n  if (!apiKey || !db) {\r\n    return null;\r\n  }\r\n\r\n  // execute_kw signature: [db, uid, password, model, method, args, kwargs]\r\n  const executeArgs = [db, uid, apiKey, model, method, args, kwargs];\r\n\r\n  console.log(`Odoo execute: ${model}.${method}`);\r\n  return odooJsonRpc('object', 'execute_kw', executeArgs);\r\n}\r\n\r\n// ===========================================\r\n// CACHING\r\n// ===========================================\r\n\r\n/**\r\n * Get cached Odoo UID or authenticate and cache\r\n * @returns {number|null} - User ID or null\r\n */\r\nfunction getCachedUid() {\r\n  const cache = CacheService.getScriptCache();\r\n  const cachedUid = cache.get(ODOO_UID_CACHE_KEY);\r\n\r\n  if (cachedUid) {\r\n    return parseInt(cachedUid, 10);\r\n  }\r\n\r\n  // Not cached, authenticate\r\n  const uid = odooAuthenticate();\r\n\r\n  if (uid) {\r\n    cache.put(ODOO_UID_CACHE_KEY, uid.toString(), ODOO_CACHE_DURATION);\r\n  }\r\n\r\n  return uid;\r\n}\r\n\r\n/**\r\n * Clear Odoo cache (UID and any other cached data)\r\n */\r\nfunction clearOdooCache() {\r\n  const cache = CacheService.getScriptCache();\r\n  cache.remove(ODOO_UID_CACHE_KEY);\r\n  console.log('Odoo cache cleared');\r\n}\r\n\r\n// ===========================================\r\n// USER METHODS\r\n// ===========================================\r\n\r\n/**\r\n * Get Odoo user ID from email address\r\n * @param {string} email - User's email\r\n * @returns {number|null} - Odoo user ID or null if not found\r\n */\r\nfunction getOdooUserIdByEmail(email) {\r\n  if (!email) {\r\n    console.error('getOdooUserIdByEmail: No email provided');\r\n    return null;\r\n  }\r\n\r\n  console.log('Looking up Odoo user by email:', email);\r\n\r\n  // Search res.users by login (email) field\r\n  const result = odooExecute(\r\n    'res.users',\r\n    'search_read',\r\n    [[['login', '=', email]]],\r\n    { fields: ['id', 'name', 'login'], limit: 1 }\r\n  );\r\n\r\n  if (result && result.length > 0) {\r\n    console.log('Found Odoo user:', result[0].name, 'ID:', result[0].id);\r\n    return result[0].id;\r\n  }\r\n\r\n  console.log('No Odoo user found for email:', email);\r\n  return null;\r\n}\r\n\r\n/**\r\n * Get all Odoo users (for mapping purposes)\r\n * @returns {Array} - Array of user objects {id, name, login}\r\n */\r\nfunction getAllOdooUsers() {\r\n  const result = odooExecute(\r\n    'res.users',\r\n    'search_read',\r\n    [[['active', '=', true]]],\r\n    { fields: ['id', 'name', 'login'] }\r\n  );\r\n\r\n  return result || [];\r\n}\r\n\r\n// ===========================================\r\n// TASK-SPECIFIC METHODS\r\n// ===========================================\r\n\r\n/**\r\n * Get all tasks assigned to a user\r\n * @param {string} email - User's email address\r\n * @param {Object} options - Optional filters\r\n * @param {boolean} options.includeCompleted - Include done tasks (default: false)\r\n * @param {number} options.projectId - Filter by project ID\r\n * @param {number} options.limit - Max tasks to return (default: 100)\r\n * @returns {Array} - Array of task objects\r\n */\r\nfunction getTasksByUserEmail(email, options = {}) {\r\n  const userId = getOdooUserIdByEmail(email);\r\n  if (!userId) {\r\n    console.log('Cannot get tasks: User not found for email:', email);\r\n    return [];\r\n  }\r\n\r\n  return getTasksByUserId(userId, options);\r\n}\r\n\r\n/**\r\n * Get all tasks assigned to a user by Odoo user ID\r\n * @param {number} userId - Odoo user ID\r\n * @param {Object} options - Optional filters\r\n * @returns {Array} - Array of task objects\r\n */\r\nfunction getTasksByUserId(userId, options = {}) {\r\n  const includeCompleted = options.includeCompleted || false;\r\n  const projectId = options.projectId || null;\r\n  const limit = options.limit || 100;\r\n\r\n  // Build domain filter\r\n  // user_ids is a many2many field, use 'in' operator\r\n  const domain = [['user_ids', 'in', [userId]]];\r\n\r\n  // Filter by project if specified\r\n  if (projectId) {\r\n    domain.push(['project_id', '=', projectId]);\r\n  }\r\n\r\n  // Exclude completed tasks unless specified\r\n  // In Odoo, completed tasks are typically in stages marked as 'fold' or specific stage names\r\n  // We'll filter by checking if the task has a date_deadline or is active\r\n  if (!includeCompleted) {\r\n    domain.push(['active', '=', true]);\r\n  }\r\n\r\n  console.log('Fetching tasks for user ID:', userId, 'Domain:', JSON.stringify(domain));\r\n\r\n  const result = odooExecute(\r\n    'project.task',\r\n    'search_read',\r\n    [domain],\r\n    {\r\n      fields: [\r\n        'id',\r\n        'name',\r\n        'user_ids',\r\n        'date_deadline',\r\n        'stage_id',\r\n        'project_id',\r\n        'priority',\r\n        'tag_ids',\r\n        'description',\r\n        'create_date',\r\n        'write_date',\r\n        'date_last_stage_update'\r\n      ],\r\n      limit: limit,\r\n      order: 'date_deadline asc, priority desc'\r\n    }\r\n  );\r\n\r\n  if (!result) {\r\n    console.log('No tasks returned from Odoo');\r\n    return [];\r\n  }\r\n\r\n  console.log(`Found ${result.length} tasks for user ID ${userId}`);\r\n  return result;\r\n}\r\n\r\n/**\r\n * Get tasks due today for a user\r\n * @param {string} email - User's email\r\n * @returns {Array} - Tasks due today\r\n */\r\nfunction getTodaysTasks(email) {\r\n  const userId = getOdooUserIdByEmail(email);\r\n  if (!userId) {\r\n    return [];\r\n  }\r\n\r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  const domain = [\r\n    ['user_ids', 'in', [userId]],\r\n    ['date_deadline', '=', today],\r\n    ['active', '=', true]\r\n  ];\r\n\r\n  console.log('Fetching today\\'s tasks for:', email, 'Date:', today);\r\n\r\n  const result = odooExecute(\r\n    'project.task',\r\n    'search_read',\r\n    [domain],\r\n    {\r\n      fields: [\r\n        'id', 'name', 'date_deadline', 'stage_id', 'project_id', 'priority'\r\n      ],\r\n      order: 'priority desc, name asc'\r\n    }\r\n  );\r\n\r\n  return result || [];\r\n}\r\n\r\n/**\r\n * Get overdue tasks for a user\r\n * @param {string} email - User's email\r\n * @returns {Array} - Overdue tasks\r\n */\r\nfunction getOverdueTasks(email) {\r\n  const userId = getOdooUserIdByEmail(email);\r\n  if (!userId) {\r\n    return [];\r\n  }\r\n\r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  const domain = [\r\n    ['user_ids', 'in', [userId]],\r\n    ['date_deadline', '<', today],\r\n    ['date_deadline', '!=', false],\r\n    ['active', '=', true]\r\n  ];\r\n\r\n  console.log('Fetching overdue tasks for:', email);\r\n\r\n  const result = odooExecute(\r\n    'project.task',\r\n    'search_read',\r\n    [domain],\r\n    {\r\n      fields: [\r\n        'id', 'name', 'date_deadline', 'stage_id', 'project_id', 'priority'\r\n      ],\r\n      order: 'date_deadline asc'\r\n    }\r\n  );\r\n\r\n  return result || [];\r\n}\r\n\r\n/**\r\n * Get upcoming tasks for a user (next 7 days)\r\n * @param {string} email - User's email\r\n * @param {number} days - Number of days ahead (default: 7)\r\n * @returns {Array} - Upcoming tasks\r\n */\r\nfunction getUpcomingTasks(email, days = 7) {\r\n  const userId = getOdooUserIdByEmail(email);\r\n  if (!userId) {\r\n    return [];\r\n  }\r\n\r\n  const today = new Date();\r\n  const futureDate = new Date(today);\r\n  futureDate.setDate(today.getDate() + days);\r\n\r\n  const todayStr = Utilities.formatDate(today, 'America/Chicago', 'yyyy-MM-dd');\r\n  const futureDateStr = Utilities.formatDate(futureDate, 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  const domain = [\r\n    ['user_ids', 'in', [userId]],\r\n    ['date_deadline', '>', todayStr],\r\n    ['date_deadline', '<=', futureDateStr],\r\n    ['active', '=', true]\r\n  ];\r\n\r\n  console.log('Fetching upcoming tasks for:', email, 'Until:', futureDateStr);\r\n\r\n  const result = odooExecute(\r\n    'project.task',\r\n    'search_read',\r\n    [domain],\r\n    {\r\n      fields: [\r\n        'id', 'name', 'date_deadline', 'stage_id', 'project_id', 'priority'\r\n      ],\r\n      order: 'date_deadline asc'\r\n    }\r\n  );\r\n\r\n  return result || [];\r\n}\r\n\r\n// ===========================================\r\n// PROJECT/DEPARTMENT METHODS\r\n// ===========================================\r\n\r\n/**\r\n * Get project ID by name\r\n * @param {string} projectName - Project name\r\n * @returns {number|null} - Project ID or null\r\n */\r\nfunction getProjectIdByName(projectName) {\r\n  const result = odooExecute(\r\n    'project.project',\r\n    'search_read',\r\n    [[['name', 'ilike', projectName]]],\r\n    { fields: ['id', 'name'], limit: 1 }\r\n  );\r\n\r\n  if (result && result.length > 0) {\r\n    console.log('Found project:', result[0].name, 'ID:', result[0].id);\r\n    return result[0].id;\r\n  }\r\n\r\n  console.log('Project not found:', projectName);\r\n  return null;\r\n}\r\n\r\n/**\r\n * Get all projects\r\n * @returns {Array} - Array of project objects\r\n */\r\nfunction getAllProjects() {\r\n  const result = odooExecute(\r\n    'project.project',\r\n    'search_read',\r\n    [[['active', '=', true]]],\r\n    { fields: ['id', 'name', 'user_id', 'partner_id'] }\r\n  );\r\n\r\n  return result || [];\r\n}\r\n\r\n/**\r\n * Get tasks by project name\r\n * @param {string} projectName - Project name (e.g., 'Finance', 'Supply Chain')\r\n * @param {Object} options - Optional filters\r\n * @returns {Array} - Tasks in that project\r\n */\r\nfunction getTasksByProject(projectName, options = {}) {\r\n  const projectId = getProjectIdByName(projectName);\r\n  if (!projectId) {\r\n    return [];\r\n  }\r\n\r\n  const includeCompleted = options.includeCompleted || false;\r\n  const limit = options.limit || 100;\r\n\r\n  const domain = [['project_id', '=', projectId]];\r\n\r\n  if (!includeCompleted) {\r\n    domain.push(['active', '=', true]);\r\n  }\r\n\r\n  console.log('Fetching tasks for project:', projectName);\r\n\r\n  const result = odooExecute(\r\n    'project.task',\r\n    'search_read',\r\n    [domain],\r\n    {\r\n      fields: [\r\n        'id', 'name', 'user_ids', 'date_deadline', 'stage_id',\r\n        'project_id', 'priority', 'create_date'\r\n      ],\r\n      limit: limit,\r\n      order: 'date_deadline asc, priority desc'\r\n    }\r\n  );\r\n\r\n  return result || [];\r\n}\r\n\r\n/**\r\n * Get all active tasks for finance team\r\n * @returns {Array} - Finance project tasks\r\n */\r\nfunction getFinanceTasks() {\r\n  // Try common finance project names\r\n  const financeNames = ['Finance', 'Accounting', 'Finance Team'];\r\n\r\n  for (const name of financeNames) {\r\n    const tasks = getTasksByProject(name);\r\n    if (tasks.length > 0) {\r\n      return tasks;\r\n    }\r\n  }\r\n\r\n  console.log('No Finance project found');\r\n  return [];\r\n}\r\n\r\n/**\r\n * Get all active tasks for supply chain team\r\n * @returns {Array} - Supply chain project tasks\r\n */\r\nfunction getSupplyChainTasks() {\r\n  // Try common supply chain project names\r\n  const scNames = ['Supply Chain', 'Logistics', 'Procurement', 'Inventory'];\r\n\r\n  for (const name of scNames) {\r\n    const tasks = getTasksByProject(name);\r\n    if (tasks.length > 0) {\r\n      return tasks;\r\n    }\r\n  }\r\n\r\n  console.log('No Supply Chain project found');\r\n  return [];\r\n}\r\n\r\n// ===========================================\r\n// TASK STATUS UPDATES\r\n// ===========================================\r\n\r\n/**\r\n * Get all task stages for a project\r\n * @param {number} projectId - Project ID\r\n * @returns {Array} - Array of stage objects\r\n */\r\nfunction getTaskStages(projectId) {\r\n  const domain = projectId\r\n    ? [['project_ids', 'in', [projectId]]]\r\n    : [];\r\n\r\n  const result = odooExecute(\r\n    'project.task.type',\r\n    'search_read',\r\n    [domain],\r\n    { fields: ['id', 'name', 'fold', 'sequence'] }\r\n  );\r\n\r\n  return result || [];\r\n}\r\n\r\n/**\r\n * Update task stage\r\n * @param {number} taskId - Task ID\r\n * @param {number} stageId - New stage ID\r\n * @returns {boolean} - Success status\r\n */\r\nfunction updateTaskStage(taskId, stageId) {\r\n  console.log('Updating task', taskId, 'to stage', stageId);\r\n\r\n  const result = odooExecute(\r\n    'project.task',\r\n    'write',\r\n    [[taskId], { stage_id: stageId }]\r\n  );\r\n\r\n  return result === true;\r\n}\r\n\r\n/**\r\n * Update task deadline\r\n * @param {number} taskId - Task ID\r\n * @param {string} newDeadline - New deadline in 'yyyy-MM-dd' format\r\n * @returns {boolean} - Success status\r\n */\r\nfunction updateTaskDeadline(taskId, newDeadline) {\r\n  console.log('Updating task', taskId, 'deadline to', newDeadline);\r\n\r\n  const result = odooExecute(\r\n    'project.task',\r\n    'write',\r\n    [[taskId], { date_deadline: newDeadline }]\r\n  );\r\n\r\n  return result === true;\r\n}\r\n\r\n// ===========================================\r\n// FORMATTING METHODS\r\n// ===========================================\r\n\r\n/**\r\n * Format task for display in Google Chat message\r\n * @param {Object} task - Odoo task object\r\n * @returns {string} - Formatted string for chat\r\n */\r\nfunction formatTaskForChat(task) {\r\n  const priorityIcons = {\r\n    '0': '',\r\n    '1': '!',\r\n    '2': '!!',\r\n    false: ''\r\n  };\r\n\r\n  const priority = priorityIcons[task.priority] || '';\r\n  const priorityPrefix = priority ? `[${priority}] ` : '';\r\n\r\n  // Format deadline\r\n  let deadlineStr = '';\r\n  if (task.date_deadline) {\r\n    const deadline = new Date(task.date_deadline);\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n\r\n    if (deadline < today) {\r\n      deadlineStr = ` (OVERDUE: ${task.date_deadline})`;\r\n    } else if (deadline.getTime() === today.getTime()) {\r\n      deadlineStr = ' (Due: Today)';\r\n    } else {\r\n      deadlineStr = ` (Due: ${task.date_deadline})`;\r\n    }\r\n  }\r\n\r\n  // Get stage name (stage_id is a tuple [id, name])\r\n  const stageName = task.stage_id ? task.stage_id[1] : 'No Stage';\r\n\r\n  // Get project name (project_id is a tuple [id, name])\r\n  const projectName = task.project_id ? task.project_id[1] : '';\r\n  const projectStr = projectName ? ` [${projectName}]` : '';\r\n\r\n  return `${priorityPrefix}${task.name}${deadlineStr} - ${stageName}${projectStr}`;\r\n}\r\n\r\n/**\r\n * Format multiple tasks as a bulleted list for chat\r\n * @param {Array} tasks - Array of tasks\r\n * @param {Object} options - Formatting options\r\n * @param {boolean} options.groupByProject - Group tasks by project\r\n * @param {number} options.maxTasks - Max tasks to show\r\n * @returns {string} - Formatted task list\r\n */\r\nfunction formatTaskListForChat(tasks, options = {}) {\r\n  if (!tasks || tasks.length === 0) {\r\n    return 'No tasks found.';\r\n  }\r\n\r\n  const groupByProject = options.groupByProject || false;\r\n  const maxTasks = options.maxTasks || 20;\r\n\r\n  // Limit tasks\r\n  const displayTasks = tasks.slice(0, maxTasks);\r\n  const hasMore = tasks.length > maxTasks;\r\n\r\n  if (groupByProject) {\r\n    // Group by project\r\n    const projectGroups = {};\r\n\r\n    for (const task of displayTasks) {\r\n      const projectName = task.project_id ? task.project_id[1] : 'No Project';\r\n      if (!projectGroups[projectName]) {\r\n        projectGroups[projectName] = [];\r\n      }\r\n      projectGroups[projectName].push(task);\r\n    }\r\n\r\n    let result = '';\r\n    for (const [project, projectTasks] of Object.entries(projectGroups)) {\r\n      result += `*${project}:*\\n`;\r\n      for (const task of projectTasks) {\r\n        result += `  ‚Ä¢ ${formatTaskForChat(task)}\\n`;\r\n      }\r\n    }\r\n\r\n    if (hasMore) {\r\n      result += `\\n_...and ${tasks.length - maxTasks} more tasks_`;\r\n    }\r\n\r\n    return result.trim();\r\n  } else {\r\n    // Simple bulleted list\r\n    let result = '';\r\n    for (const task of displayTasks) {\r\n      result += `‚Ä¢ ${formatTaskForChat(task)}\\n`;\r\n    }\r\n\r\n    if (hasMore) {\r\n      result += `_...and ${tasks.length - maxTasks} more tasks_`;\r\n    }\r\n\r\n    return result.trim();\r\n  }\r\n}\r\n\r\n/**\r\n * Get task summary for a user (for check-in message)\r\n * @param {string} email - User's email\r\n * @returns {Object} - Summary object with counts and formatted text\r\n */\r\nfunction getOdooTaskSummary(email) {\r\n  const todayTasks = getTodaysTasks(email);\r\n  const overdueTasks = getOverdueTasks(email);\r\n  const upcomingTasks = getUpcomingTasks(email, 7);\r\n\r\n  const summary = {\r\n    todayCount: todayTasks.length,\r\n    overdueCount: overdueTasks.length,\r\n    upcomingCount: upcomingTasks.length,\r\n    todayTasks: todayTasks,\r\n    overdueTasks: overdueTasks,\r\n    upcomingTasks: upcomingTasks,\r\n    formattedText: ''\r\n  };\r\n\r\n  // Build formatted text\r\n  let text = '';\r\n\r\n  if (overdueTasks.length > 0) {\r\n    text += `*OVERDUE (${overdueTasks.length}):*\\n`;\r\n    text += formatTaskListForChat(overdueTasks, { maxTasks: 5 });\r\n    text += '\\n\\n';\r\n  }\r\n\r\n  if (todayTasks.length > 0) {\r\n    text += `*Due Today (${todayTasks.length}):*\\n`;\r\n    text += formatTaskListForChat(todayTasks, { maxTasks: 10 });\r\n    text += '\\n\\n';\r\n  }\r\n\r\n  if (upcomingTasks.length > 0) {\r\n    text += `*Upcoming (${upcomingTasks.length}):*\\n`;\r\n    text += formatTaskListForChat(upcomingTasks, { maxTasks: 5 });\r\n  }\r\n\r\n  if (!text) {\r\n    text = 'No Odoo tasks found.';\r\n  }\r\n\r\n  summary.formattedText = text.trim();\r\n  return summary;\r\n}\r\n\r\n// ===========================================\r\n// TASK NORMALIZATION\r\n// ===========================================\r\n\r\n/**\r\n * Normalize an Odoo task to match the ClickUp task shape\r\n * so the rest of the bot can handle both identically.\r\n * @param {Object} task - Raw Odoo task from search_read\r\n * @returns {Object} - Normalized task matching ClickUp shape\r\n */\r\nfunction normalizeOdooTask(task) {\r\n  var today = new Date();\r\n  today.setHours(0, 0, 0, 0);\r\n  var dueDate = task.date_deadline ? new Date(task.date_deadline + 'T00:00:00') : null;\r\n  var isOverdue = dueDate && dueDate < today;\r\n  var daysOverdue = isOverdue ? Math.floor((today - dueDate) / (1000 * 60 * 60 * 24)) : 0;\r\n\r\n  return {\r\n    id: String(task.id),\r\n    name: task.name,\r\n    description: task.description || '',\r\n    status: task.stage_id ? task.stage_id[1] : 'unknown',\r\n    statusType: 'open',\r\n    dueDate: dueDate,\r\n    dueDateStr: dueDate ? Utilities.formatDate(dueDate, 'America/Chicago', 'EEE, MMM d') : null,\r\n    listId: task.project_id ? String(task.project_id[0]) : '',\r\n    listName: task.project_id ? task.project_id[1] : 'No Project',\r\n    folderName: null,\r\n    spaceName: null,\r\n    url: ODOO_URL + '/web#id=' + task.id + '&model=project.task&view_type=form',\r\n    isOverdue: isOverdue,\r\n    daysOverdue: daysOverdue,\r\n    priority: task.priority === '2' ? 'urgent' : (task.priority === '1' ? 'high' : null),\r\n    timeEstimateMs: null,\r\n    timeEstimateHrs: null,\r\n    source: 'odoo',\r\n    odooStageId: task.stage_id ? task.stage_id[0] : null,\r\n    odooProjectId: task.project_id ? task.project_id[0] : null\r\n  };\r\n}\r\n\r\n/**\r\n * Normalize an array of Odoo tasks and sort by overdue-first, then due date\r\n * @param {Array} tasks - Raw Odoo tasks\r\n * @returns {Array} - Sorted normalized tasks\r\n */\r\nfunction normalizeOdooTasks(tasks) {\r\n  return (tasks || []).map(normalizeOdooTask).sort(function(a, b) {\r\n    if (a.isOverdue && !b.isOverdue) return -1;\r\n    if (!a.isOverdue && b.isOverdue) return 1;\r\n    if (a.isOverdue && b.isOverdue) return b.daysOverdue - a.daysOverdue;\r\n    if (a.dueDate && b.dueDate) return a.dueDate - b.dueDate;\r\n    return 0;\r\n  });\r\n}\r\n\r\n// ===========================================\r\n// INTEGRATION HELPERS\r\n// ===========================================\r\n\r\n/**\r\n * Get tasks for a user, combining with any configured source\r\n * This is the main method to call from the check-in bot\r\n * @param {string} email - User's email\r\n * @param {string} period - 'today', 'overdue', 'week', or 'all'\r\n * @returns {Array} - Array of task objects\r\n */\r\nfunction getOdooTasksForUser(email, period = 'today') {\r\n  switch (period) {\r\n    case 'today':\r\n      return getTodaysTasks(email);\r\n    case 'overdue':\r\n      return getOverdueTasks(email);\r\n    case 'week':\r\n      return getUpcomingTasks(email, 7);\r\n    case 'all':\r\n      return getTasksByUserEmail(email);\r\n    default:\r\n      return getTodaysTasks(email);\r\n  }\r\n}\r\n\r\n// ===========================================\r\n// TEST FUNCTIONS\r\n// ===========================================\r\n\r\n/**\r\n * Test Odoo connection and authentication\r\n * Run this first to verify setup\r\n */\r\nfunction testOdooConnection() {\r\n  console.log('=== Testing Odoo Connection ===');\r\n  console.log('URL:', ODOO_URL);\r\n  console.log('Username:', ODOO_USERNAME);\r\n\r\n  // Clear cache to force fresh auth\r\n  clearOdooCache();\r\n\r\n  const db = getOdooDatabase();\r\n  if (!db) {\r\n    console.error('FAILED: No database name found in Script Properties');\r\n    console.log('Please add ODOO_DB to Script Properties');\r\n    console.log('To find your database name, try: https://k-brands.odoo.com/web/database/selector');\r\n    return false;\r\n  }\r\n  console.log('Database:', db);\r\n\r\n  const apiKey = getOdooApiKey();\r\n  if (!apiKey) {\r\n    console.error('FAILED: No API key found in Script Properties');\r\n    console.log('Please add ODOO_API_KEY to Script Properties');\r\n    return false;\r\n  }\r\n  console.log('API Key found (first 10 chars):', apiKey.substring(0, 10) + '...');\r\n\r\n  const uid = odooAuthenticate();\r\n\r\n  if (uid) {\r\n    console.log('SUCCESS: Authenticated with Odoo');\r\n    console.log('User ID (UID):', uid);\r\n    return true;\r\n  } else {\r\n    console.error('FAILED: Could not authenticate with Odoo');\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Test fetching tasks - get a sample of all tasks\r\n */\r\nfunction testGetTasks() {\r\n  console.log('=== Testing Get Tasks ===');\r\n\r\n  const result = odooExecute(\r\n    'project.task',\r\n    'search_read',\r\n    [[['active', '=', true]]],\r\n    {\r\n      fields: ['id', 'name', 'user_ids', 'date_deadline', 'stage_id', 'project_id', 'priority'],\r\n      limit: 10\r\n    }\r\n  );\r\n\r\n  if (result && result.length > 0) {\r\n    console.log('SUCCESS: Found', result.length, 'tasks');\r\n    console.log('Sample tasks:');\r\n    for (const task of result) {\r\n      console.log(`  - [${task.id}] ${task.name}`);\r\n      console.log(`    Project: ${task.project_id ? task.project_id[1] : 'None'}`);\r\n      console.log(`    Stage: ${task.stage_id ? task.stage_id[1] : 'None'}`);\r\n      console.log(`    Deadline: ${task.date_deadline || 'No deadline'}`);\r\n      console.log(`    Assigned to: ${task.user_ids ? task.user_ids.length : 0} user(s)`);\r\n    }\r\n    return result;\r\n  } else {\r\n    console.log('No tasks found or error occurred');\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Test getting tasks for a specific user\r\n * Update the email to test with a real user\r\n */\r\nfunction testGetUserTasks() {\r\n  console.log('=== Testing Get User Tasks ===');\r\n\r\n  // Test with the API user first\r\n  const testEmail = ODOO_USERNAME;\r\n  console.log('Testing with email:', testEmail);\r\n\r\n  // First, verify the user exists\r\n  const userId = getOdooUserIdByEmail(testEmail);\r\n  if (!userId) {\r\n    console.log('User not found:', testEmail);\r\n    console.log('Trying to list all users...');\r\n\r\n    const users = getAllOdooUsers();\r\n    console.log('Found', users.length, 'users:');\r\n    for (const user of users.slice(0, 10)) {\r\n      console.log(`  - ${user.login} (ID: ${user.id})`);\r\n    }\r\n    return;\r\n  }\r\n\r\n  console.log('User ID:', userId);\r\n\r\n  // Get tasks\r\n  const tasks = getTasksByUserEmail(testEmail);\r\n  console.log('Found', tasks.length, 'tasks for user');\r\n\r\n  if (tasks.length > 0) {\r\n    console.log('Tasks:');\r\n    for (const task of tasks.slice(0, 5)) {\r\n      console.log('  -', formatTaskForChat(task));\r\n    }\r\n  }\r\n\r\n  // Get today's tasks\r\n  const todayTasks = getTodaysTasks(testEmail);\r\n  console.log('Today\\'s tasks:', todayTasks.length);\r\n\r\n  // Get overdue tasks\r\n  const overdueTasks = getOverdueTasks(testEmail);\r\n  console.log('Overdue tasks:', overdueTasks.length);\r\n\r\n  return tasks;\r\n}\r\n\r\n/**\r\n * Test getting finance and supply chain tasks\r\n */\r\nfunction testGetDepartmentTasks() {\r\n  console.log('=== Testing Department Tasks ===');\r\n\r\n  // List all projects first\r\n  console.log('Listing all projects...');\r\n  const projects = getAllProjects();\r\n  console.log('Found', projects.length, 'projects:');\r\n  for (const project of projects) {\r\n    console.log(`  - ${project.name} (ID: ${project.id})`);\r\n  }\r\n\r\n  // Test Finance\r\n  console.log('\\nFetching Finance tasks...');\r\n  const financeTasks = getFinanceTasks();\r\n  console.log('Finance tasks:', financeTasks.length);\r\n  if (financeTasks.length > 0) {\r\n    console.log('Sample:', formatTaskForChat(financeTasks[0]));\r\n  }\r\n\r\n  // Test Supply Chain\r\n  console.log('\\nFetching Supply Chain tasks...');\r\n  const scTasks = getSupplyChainTasks();\r\n  console.log('Supply Chain tasks:', scTasks.length);\r\n  if (scTasks.length > 0) {\r\n    console.log('Sample:', formatTaskForChat(scTasks[0]));\r\n  }\r\n\r\n  return { finance: financeTasks, supplyChain: scTasks };\r\n}\r\n\r\n/**\r\n * Test the task summary function\r\n */\r\nfunction testTaskSummary() {\r\n  console.log('=== Testing Task Summary ===');\r\n\r\n  const testEmail = ODOO_USERNAME;\r\n  console.log('Getting task summary for:', testEmail);\r\n\r\n  const summary = getOdooTaskSummary(testEmail);\r\n\r\n  console.log('Summary:');\r\n  console.log('  Today:', summary.todayCount);\r\n  console.log('  Overdue:', summary.overdueCount);\r\n  console.log('  Upcoming:', summary.upcomingCount);\r\n  console.log('\\nFormatted text:');\r\n  console.log(summary.formattedText);\r\n\r\n  return summary;\r\n}\r\n\r\n/**\r\n * Test task stages\r\n */\r\nfunction testTaskStages() {\r\n  console.log('=== Testing Task Stages ===');\r\n\r\n  const stages = getTaskStages();\r\n  console.log('Found', stages.length, 'stages:');\r\n  for (const stage of stages) {\r\n    console.log(`  - ${stage.name} (ID: ${stage.id}, Fold: ${stage.fold})`);\r\n  }\r\n\r\n  return stages;\r\n}\r\n\r\n// ===========================================\r\n// DATABASE DISCOVERY\r\n// ===========================================\r\n\r\n/**\r\n * Discover available Odoo databases\r\n * This function tries multiple methods to find the database name\r\n * Run this if you don't know your Odoo database name\r\n */\r\nfunction discoverOdooDatabases() {\r\n  console.log('=== Discovering Odoo Databases ===');\r\n  console.log('URL:', ODOO_URL);\r\n\r\n  const results = {\r\n    dbListMethod: [],\r\n    versionInfo: null,\r\n    serverInfo: null,\r\n    suggestions: []\r\n  };\r\n\r\n  // Method 1: Try the db.list JSON-RPC call\r\n  console.log('\\n--- Method 1: db.list JSON-RPC ---');\r\n  try {\r\n    const dbListPayload = {\r\n      jsonrpc: '2.0',\r\n      method: 'call',\r\n      params: {\r\n        service: 'db',\r\n        method: 'list',\r\n        args: []\r\n      },\r\n      id: Math.floor(Math.random() * 1000000000)\r\n    };\r\n\r\n    const options = {\r\n      method: 'post',\r\n      contentType: 'application/json',\r\n      payload: JSON.stringify(dbListPayload),\r\n      muteHttpExceptions: true,\r\n      timeout: 30000\r\n    };\r\n\r\n    const response = UrlFetchApp.fetch(ODOO_JSONRPC_ENDPOINT, options);\r\n    const responseText = response.getContentText();\r\n    console.log('db.list response:', responseText);\r\n\r\n    const jsonResponse = JSON.parse(responseText);\r\n\r\n    if (jsonResponse.result && Array.isArray(jsonResponse.result)) {\r\n      results.dbListMethod = jsonResponse.result;\r\n      console.log('SUCCESS! Found databases:', jsonResponse.result.join(', '));\r\n    } else if (jsonResponse.error) {\r\n      console.log('db.list blocked or error:', jsonResponse.error.message || JSON.stringify(jsonResponse.error));\r\n      // This is common - Odoo often disables db listing for security\r\n    }\r\n  } catch (error) {\r\n    console.log('db.list method failed:', error.message);\r\n  }\r\n\r\n  // Method 2: Try common/version to at least verify server is reachable\r\n  console.log('\\n--- Method 2: Server Version Check ---');\r\n  try {\r\n    const versionPayload = {\r\n      jsonrpc: '2.0',\r\n      method: 'call',\r\n      params: {\r\n        service: 'common',\r\n        method: 'version',\r\n        args: []\r\n      },\r\n      id: Math.floor(Math.random() * 1000000000)\r\n    };\r\n\r\n    const options = {\r\n      method: 'post',\r\n      contentType: 'application/json',\r\n      payload: JSON.stringify(versionPayload),\r\n      muteHttpExceptions: true,\r\n      timeout: 30000\r\n    };\r\n\r\n    const response = UrlFetchApp.fetch(ODOO_JSONRPC_ENDPOINT, options);\r\n    const jsonResponse = JSON.parse(response.getContentText());\r\n\r\n    if (jsonResponse.result) {\r\n      results.versionInfo = jsonResponse.result;\r\n      console.log('Odoo Version:', jsonResponse.result.server_version || JSON.stringify(jsonResponse.result));\r\n    }\r\n  } catch (error) {\r\n    console.log('Version check failed:', error.message);\r\n  }\r\n\r\n  // Method 3: Try to fetch the web login page and look for database selector\r\n  console.log('\\n--- Method 3: Web Page Check ---');\r\n  try {\r\n    const webResponse = UrlFetchApp.fetch(ODOO_URL + '/web/database/selector', {\r\n      muteHttpExceptions: true,\r\n      followRedirects: false,\r\n      timeout: 30000\r\n    });\r\n\r\n    const statusCode = webResponse.getResponseCode();\r\n    const content = webResponse.getContentText();\r\n\r\n    console.log('Database selector page status:', statusCode);\r\n\r\n    if (statusCode === 200) {\r\n      // Look for database names in the HTML\r\n      // Common patterns: data-db-name=\"xxx\" or option value=\"xxx\"\r\n      const dbMatches = content.match(/data-db[^\"]*\"([^\"]+)\"/g) || [];\r\n      const optionMatches = content.match(/<option[^>]*value=\"([^\"]+)\"[^>]*>/g) || [];\r\n\r\n      if (dbMatches.length > 0 || optionMatches.length > 0) {\r\n        console.log('Found database references in HTML');\r\n        console.log('DB matches:', dbMatches.join(', '));\r\n        console.log('Option matches:', optionMatches.join(', '));\r\n      }\r\n\r\n      // Check if it says \"Access Denied\" or similar\r\n      if (content.includes('Access Denied') || content.includes('Not Found')) {\r\n        console.log('Database selector is disabled (Access Denied)');\r\n      }\r\n    } else if (statusCode === 303 || statusCode === 302) {\r\n      // Redirect - might contain db in URL\r\n      const location = webResponse.getHeaders()['Location'];\r\n      console.log('Redirected to:', location);\r\n      if (location && location.includes('db=')) {\r\n        const dbMatch = location.match(/db=([^&]+)/);\r\n        if (dbMatch) {\r\n          results.suggestions.push(dbMatch[1]);\r\n          console.log('Found database in redirect URL:', dbMatch[1]);\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log('Web check failed:', error.message);\r\n  }\r\n\r\n  // Method 4: Try common database name patterns\r\n  console.log('\\n--- Method 4: Testing Common Database Names ---');\r\n  const commonNames = [\r\n    'k-brands',\r\n    'kbrands',\r\n    'k_brands',\r\n    'production',\r\n    'main',\r\n    'odoo',\r\n    'k-brands-main',\r\n    'k-brands-production',\r\n    'kbrands-main',\r\n    'kbrands_production'\r\n  ];\r\n\r\n  const apiKey = getOdooApiKey();\r\n  if (apiKey) {\r\n    for (const dbName of commonNames) {\r\n      console.log(`Testing database: \"${dbName}\"...`);\r\n\r\n      try {\r\n        const authPayload = {\r\n          jsonrpc: '2.0',\r\n          method: 'call',\r\n          params: {\r\n            service: 'common',\r\n            method: 'login',\r\n            args: [dbName, ODOO_USERNAME, apiKey]\r\n          },\r\n          id: Math.floor(Math.random() * 1000000000)\r\n        };\r\n\r\n        const options = {\r\n          method: 'post',\r\n          contentType: 'application/json',\r\n          payload: JSON.stringify(authPayload),\r\n          muteHttpExceptions: true,\r\n          timeout: 10000\r\n        };\r\n\r\n        const response = UrlFetchApp.fetch(ODOO_JSONRPC_ENDPOINT, options);\r\n        const jsonResponse = JSON.parse(response.getContentText());\r\n\r\n        if (jsonResponse.result && typeof jsonResponse.result === 'number') {\r\n          results.suggestions.push(dbName);\r\n          console.log(`SUCCESS! Database \"${dbName}\" works! User ID: ${jsonResponse.result}`);\r\n        } else if (jsonResponse.error) {\r\n          const errorMsg = jsonResponse.error.data?.message || jsonResponse.error.message || '';\r\n          if (errorMsg.includes('does not exist')) {\r\n            console.log(`  \"${dbName}\" - does not exist`);\r\n          } else if (errorMsg.includes('Access Denied') || errorMsg.includes('Invalid')) {\r\n            console.log(`  \"${dbName}\" - exists but auth failed (wrong credentials)`);\r\n            results.suggestions.push(dbName + ' (auth failed - db exists)');\r\n          } else {\r\n            console.log(`  \"${dbName}\" - error: ${errorMsg}`);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.log(`  \"${dbName}\" - request failed: ${error.message}`);\r\n      }\r\n    }\r\n  } else {\r\n    console.log('Skipping database tests - no API key configured');\r\n  }\r\n\r\n  // Summary\r\n  console.log('\\n=== SUMMARY ===');\r\n\r\n  if (results.dbListMethod.length > 0) {\r\n    console.log('Databases from db.list:', results.dbListMethod.join(', '));\r\n    console.log('\\nTo configure, add this to Script Properties:');\r\n    console.log(`  ODOO_DB = ${results.dbListMethod[0]}`);\r\n  }\r\n\r\n  if (results.suggestions.length > 0) {\r\n    console.log('Working database names found:', results.suggestions.join(', '));\r\n    const workingDb = results.suggestions.find(s => !s.includes('auth failed'));\r\n    if (workingDb) {\r\n      console.log('\\nTo configure, add this to Script Properties:');\r\n      console.log(`  ODOO_DB = ${workingDb}`);\r\n    }\r\n  }\r\n\r\n  if (results.dbListMethod.length === 0 && results.suggestions.length === 0) {\r\n    console.log('Could not automatically discover the database name.');\r\n    console.log('\\nManual steps to find your database name:');\r\n    console.log('1. Log into Odoo at ' + ODOO_URL);\r\n    console.log('2. Look at the URL - it might show ?db=YOUR_DATABASE');\r\n    console.log('3. Or ask your Odoo administrator');\r\n    console.log('4. Or check the Odoo.sh dashboard if using Odoo.sh');\r\n  }\r\n\r\n  if (results.versionInfo) {\r\n    console.log('\\nOdoo Server Info:', JSON.stringify(results.versionInfo));\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\n/**\r\n * Quick test to verify a specific database name\r\n * @param {string} dbName - Database name to test\r\n */\r\nfunction testDatabaseName(dbName) {\r\n  if (!dbName) {\r\n    console.log('Usage: testDatabaseName(\"your-database-name\")');\r\n    console.log('Or run discoverOdooDatabases() to find available databases');\r\n    return false;\r\n  }\r\n\r\n  console.log('Testing database:', dbName);\r\n\r\n  const apiKey = getOdooApiKey();\r\n  if (!apiKey) {\r\n    console.error('No ODOO_API_KEY found in Script Properties');\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    const authPayload = {\r\n      jsonrpc: '2.0',\r\n      method: 'call',\r\n      params: {\r\n        service: 'common',\r\n        method: 'login',\r\n        args: [dbName, ODOO_USERNAME, apiKey]\r\n      },\r\n      id: Math.floor(Math.random() * 1000000000)\r\n    };\r\n\r\n    const options = {\r\n      method: 'post',\r\n      contentType: 'application/json',\r\n      payload: JSON.stringify(authPayload),\r\n      muteHttpExceptions: true,\r\n      timeout: 30000\r\n    };\r\n\r\n    const response = UrlFetchApp.fetch(ODOO_JSONRPC_ENDPOINT, options);\r\n    const jsonResponse = JSON.parse(response.getContentText());\r\n\r\n    if (jsonResponse.result && typeof jsonResponse.result === 'number') {\r\n      console.log('SUCCESS! Database \"' + dbName + '\" is correct!');\r\n      console.log('User ID:', jsonResponse.result);\r\n      console.log('\\nNow add this to Script Properties:');\r\n      console.log('  ODOO_DB = ' + dbName);\r\n      return true;\r\n    } else if (jsonResponse.error) {\r\n      console.error('FAILED:', jsonResponse.error.data?.message || jsonResponse.error.message);\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    console.error('Request failed:', error.message);\r\n    return false;\r\n  }\r\n\r\n  return false;\r\n}\r\n"
    },
    {
      "name": "OpenAI.gs",
      "type": "server_js",
      "source": "/**\r\n * OpenAI.gs - AI Evaluation Functions\r\n * Handles OpenAI API calls for daily evaluations\r\n */\r\n\r\nconst OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';\r\n\r\n/**\r\n * Call OpenAI API\r\n */\r\nfunction callOpenAI(prompt, maxTokens = 2000) {\r\n  const config = getConfig();\r\n  const apiKey = config.openai_api_key;\r\n  \r\n  if (!apiKey) {\r\n    console.error('OpenAI API key not configured');\r\n    return null;\r\n  }\r\n  \r\n  const payload = {\r\n    model: getOpenAIModel(),\r\n    messages: [\r\n      { role: 'system', content: 'You are an HR assistant analyzing team performance data.' },\r\n      { role: 'user', content: prompt }\r\n    ],\r\n    max_tokens: maxTokens,\r\n    temperature: 0.7\r\n  };\r\n  \r\n  const options = {\r\n    method: 'post',\r\n    headers: {\r\n      'Authorization': `Bearer ${apiKey}`,\r\n      'Content-Type': 'application/json'\r\n    },\r\n    payload: JSON.stringify(payload),\r\n    muteHttpExceptions: true\r\n  };\r\n  \r\n  try {\r\n    const response = UrlFetchApp.fetch(OPENAI_API_URL, options);\r\n    const code = response.getResponseCode();\r\n    \r\n    if (code !== 200) {\r\n      console.error(`OpenAI API error: ${code} - ${response.getContentText()}`);\r\n      return null;\r\n    }\r\n    \r\n    const result = JSON.parse(response.getContentText());\r\n    return result.choices[0].message.content;\r\n  } catch (error) {\r\n    console.error('OpenAI request failed:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Parse EOD response using OpenAI for structured extraction\r\n * Returns { tasks_completed, blockers, tomorrow_priority, hours_worked }\r\n */\r\nfunction parseEodWithAI(rawText) {\r\n  var prompt = 'Parse this end-of-day work report into structured JSON. Extract exactly these fields:\\n' +\r\n    '- tasks_completed: string (what they accomplished today)\\n' +\r\n    '- blockers: string or null (any blockers, issues, things they are waiting on)\\n' +\r\n    '- tomorrow_priority: string or null (what they plan to do tomorrow/next)\\n' +\r\n    '- hours_worked: number or null (hours worked today, if mentioned)\\n\\n' +\r\n    'Return ONLY valid JSON, no markdown, no explanation.\\n\\n' +\r\n    'EOD Report:\\n' + rawText;\r\n\r\n  var result = callOpenAI(prompt, 500);\r\n  if (!result) return null;\r\n\r\n  try {\r\n    // Strip markdown code fences if present\r\n    var cleaned = result.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\r\n    return JSON.parse(cleaned);\r\n  } catch (e) {\r\n    console.error('Failed to parse AI EOD response:', e.message, result);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Generate daily AI evaluation\r\n */\r\nfunction generateDailyAiEvaluation() {\r\n  console.log('Generating daily AI evaluation...');\r\n  \r\n  const allMembers = getCachedWorkingEmployees();\r\n  const config = getConfig();\r\n  // Filter to tracked users only for AI evaluation\r\n  const teamMembers = allMembers.filter(function(m) {\r\n    var fullMember = config.team_members.find(function(tm) { return tm.email === m.email; });\r\n    return !fullMember || (fullMember.tracking_mode || 'tracked') === 'tracked';\r\n  });\r\n  const todayCheckIns = getTodayCheckIns();\r\n  const todayEods = getTodayEodReports();\r\n\r\n  // --- Historical context (batched, team-level queries) ---\r\n  var teamAttendance = {};\r\n  var teamTaskHistory = {};\r\n  var teamHoursWeekly = {};\r\n  var teamHoursTrends = {};\r\n  var teamStreaks = {};\r\n  var yesterdayPriorities = {};\r\n  var repeatDelayed = [];\r\n  var lastEvaluation = null;\r\n\r\n  try {\r\n    var rawAttendance = getTeamWeeklyAttendanceStats();\r\n    rawAttendance.forEach(function(r) { teamAttendance[r.user_email] = r; });\r\n  } catch (e) { console.error('Historical attendance fetch failed:', e.message); }\r\n\r\n  try {\r\n    if (config.clickup_config.enabled) {\r\n      var rawTaskStats = getTeamTaskStats();\r\n      rawTaskStats.forEach(function(r) { teamTaskHistory[r.user_email] = r; });\r\n    }\r\n  } catch (e) { console.error('Historical task stats fetch failed:', e.message); }\r\n\r\n  try {\r\n    var rawHours = getWeeklyHoursData();\r\n    rawHours.forEach(function(r) {\r\n      if (!teamHoursWeekly[r.user_email]) {\r\n        teamHoursWeekly[r.user_email] = { totalHours: 0, daysReported: 0, dailyHours: [] };\r\n      }\r\n      var hrs = parseFloat(r.hours_worked) || 0;\r\n      teamHoursWeekly[r.user_email].totalHours += hrs;\r\n      teamHoursWeekly[r.user_email].daysReported += 1;\r\n      teamHoursWeekly[r.user_email].dailyHours.push(hrs);\r\n    });\r\n    for (var hEmail in teamHoursWeekly) {\r\n      var d = teamHoursWeekly[hEmail];\r\n      d.avgDaily = d.daysReported > 0 ? Math.round(d.totalHours / d.daysReported * 10) / 10 : 0;\r\n    }\r\n  } catch (e) { console.error('Weekly hours fetch failed:', e.message); }\r\n\r\n  try {\r\n    var rawTrends = getHoursTrends();\r\n    rawTrends.forEach(function(r) {\r\n      if (!teamHoursTrends[r.user_email]) teamHoursTrends[r.user_email] = [];\r\n      teamHoursTrends[r.user_email].push({\r\n        week_num: r.week_num,\r\n        avg_daily_hours: parseFloat(r.avg_daily_hours) || 0,\r\n        total_hours: parseFloat(r.total_hours) || 0,\r\n        days_reported: parseInt(r.days_reported) || 0\r\n      });\r\n    });\r\n  } catch (e) { console.error('Hours trends fetch failed:', e.message); }\r\n\r\n  try {\r\n    var rawStreaks = getTeamStreaks();\r\n    rawStreaks.forEach(function(r) { teamStreaks[r.user_email] = parseInt(r.streak_length) || 0; });\r\n  } catch (e) { console.error('Streaks fetch failed:', e.message); }\r\n\r\n  try {\r\n    var rawPriorities = getYesterdayEodPriorities();\r\n    rawPriorities.forEach(function(r) { yesterdayPriorities[r.user_email] = r.tomorrow_priority; });\r\n  } catch (e) { console.error('Yesterday priorities fetch failed:', e.message); }\r\n\r\n  try {\r\n    if (config.clickup_config.enabled) {\r\n      repeatDelayed = getRepeatDelayedTasks() || [];\r\n    }\r\n  } catch (e) { console.error('Repeat delayed fetch failed:', e.message); }\r\n\r\n  try {\r\n    lastEvaluation = getLastAiEvaluation();\r\n  } catch (e) { console.error('Last evaluation fetch failed:', e.message); }\r\n\r\n  console.log('Historical context loaded: attendance=' + Object.keys(teamAttendance).length\r\n    + ', hours=' + Object.keys(teamHoursWeekly).length\r\n    + ', streaks=' + Object.keys(teamStreaks).length\r\n    + ', priorities=' + Object.keys(yesterdayPriorities).length\r\n    + ', repeatDelayed=' + repeatDelayed.length\r\n    + ', lastEval=' + (lastEvaluation ? lastEvaluation.evaluation_date : 'none'));\r\n\r\n  // Build team data for evaluation\r\n  const teamData = teamMembers.map(member => {\r\n    const checkIn = todayCheckIns.find(c => c.user_email === member.email);\r\n    const eod = todayEods.find(e => e.user_email === member.email);\r\n    var fullMember = config.team_members.find(function(tm) { return tm.email === member.email; });\r\n\r\n    // Fetch tasks once for both taskStats and hours analysis\r\n    var tasks = [];\r\n    if (config.clickup_config.enabled) {\r\n      tasks = getTasksForUser(member.email, 'today');\r\n    }\r\n\r\n    let taskStats = null;\r\n    if (config.clickup_config.enabled) {\r\n      const actions = getUserTodayTaskActions(member.email);\r\n\r\n      let completed = 0, delayed = 0;\r\n      actions.forEach(a => {\r\n        if (a.action_type === 'COMPLETE') completed = parseInt(a.count);\r\n        if (a.action_type === 'TOMORROW') delayed = parseInt(a.count);\r\n      });\r\n\r\n      const overdueTasks = tasks.filter(t => t.isOverdue);\r\n\r\n      taskStats = {\r\n        dueToday: tasks.length,\r\n        completed: completed,\r\n        delayed: delayed,\r\n        overdue: overdueTasks.length,\r\n        oldestOverdueDays: overdueTasks.length > 0 ? Math.max(...overdueTasks.map(t => t.daysOverdue)) : 0\r\n      };\r\n    }\r\n\r\n    // Self-reported hours from EOD\r\n    var eodHours = eod ? (eod.hours_worked !== undefined ? parseFloat(eod.hours_worked) : null) : null;\r\n    if (eodHours !== null && isNaN(eodHours)) eodHours = null;\r\n\r\n    // ClickUp time estimates (if enabled)\r\n    var clickupEstimateHrs = null;\r\n    if (config.clickup_config.use_clickup_time_estimates && tasks && tasks.length > 0) {\r\n      var totalMs = tasks.reduce(function(sum, t) { return sum + (t.timeEstimateMs || 0); }, 0);\r\n      if (totalMs > 0) {\r\n        clickupEstimateHrs = Math.round(totalMs / 3600000 * 10) / 10;\r\n      }\r\n    }\r\n\r\n    // Task details for AI (capped at 5 for token efficiency)\r\n    var taskDetails = tasks ? tasks.slice(0, 5).map(function(t) {\r\n      return {\r\n        name: t.name,\r\n        description: (t.description || '').substring(0, 100),\r\n        status: t.status,\r\n        isOverdue: t.isOverdue,\r\n        timeEstimateHrs: config.clickup_config.use_clickup_time_estimates ? t.timeEstimateHrs : null\r\n      };\r\n    }) : [];\r\n\r\n    // Repeat-delayed tasks for this user\r\n    var userRepeatDelayed = repeatDelayed.filter(function(t) { return t.user_email === member.email; });\r\n\r\n    return {\r\n      name: member.name || member.email.split('@')[0],\r\n      email: member.email,\r\n\r\n      // Role context\r\n      department: member.department || (fullMember ? fullMember.department : null) || null,\r\n      position: member.position || null,\r\n      taskSource: fullMember ? fullMember.task_source : 'clickup',\r\n\r\n      // Today's data\r\n      checkedIn: !!checkIn,\r\n      isLate: checkIn ? checkIn.is_late : false,\r\n      eodSubmitted: !!eod,\r\n      eodReport: eod ? eod.tasks_completed : null,\r\n      blockers: eod ? eod.blockers : null,\r\n      taskStats: taskStats,\r\n      hoursReported: eodHours,\r\n      clickupEstimateHrs: clickupEstimateHrs,\r\n      expectedHoursToday: getTodayExpectedHours(member.email),\r\n      taskDetails: taskDetails,\r\n\r\n      // Historical: attendance (last 7 days)\r\n      weeklyAttendance: teamAttendance[member.email] || null,\r\n      onTimeStreak: teamStreaks[member.email] || 0,\r\n\r\n      // Historical: hours (last 7 days + 4-week trend)\r\n      weeklyHours: teamHoursWeekly[member.email] || null,\r\n      hoursTrend: teamHoursTrends[member.email] || null,\r\n\r\n      // Historical: task throughput (last 7 days)\r\n      weeklyTaskStats: teamTaskHistory[member.email] || null,\r\n\r\n      // Continuity: yesterday's stated priority\r\n      yesterdayPriority: yesterdayPriorities[member.email] || null,\r\n\r\n      // Chronic issues\r\n      repeatDelayedTasks: userRepeatDelayed\r\n    };\r\n  });\r\n\r\n  const prompt = buildAiEvaluationPrompt(teamData, lastEvaluation);\r\n  const evaluation = callOpenAI(prompt, 3000);\r\n  \r\n  if (!evaluation) {\r\n    console.error('Failed to generate AI evaluation');\r\n    logSystemEvent('AI_EVALUATION', 'FAILED', { error: 'No response from OpenAI' });\r\n    return;\r\n  }\r\n  \r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'EEEE, MMMM d');\r\n  const message = `üìä **AI Daily Evaluation - ${today}**\\n\\n${evaluation}`;\r\n  \r\n  const recipients = getReportRecipients('ai_evaluation');\r\n  recipients.forEach(recipient => {\r\n    sendDirectMessage(recipient, message);\r\n  });\r\n  \r\n  insertIntoBigQuery('ai_evaluations', [{\r\n    evaluation_id: Utilities.getUuid(),\r\n    evaluation_date: Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd'),\r\n    evaluation_text: evaluation,\r\n    team_size: teamData.length,\r\n    created_at: new Date().toISOString()\r\n  }]);\r\n  \r\n  logSystemEvent('AI_EVALUATION', 'SUCCESS', { teamSize: teamData.length, recipients: recipients.length });\r\n  console.log(`AI evaluation sent to ${recipients.length} recipients`);\r\n}\r\n\r\n/**\r\n * Generate weekly summary\r\n */\r\nfunction generateWeeklySummary() {\r\n  console.log('Generating weekly summary...');\r\n  \r\n  const config = getConfig();\r\n  const projectId = getProjectId();\r\n  \r\n  // Get real weekly stats from BigQuery (BUG #9 fix - was hardcoded)\r\n  var weeklyData = {};\r\n  try {\r\n    weeklyData = getWeeklyTeamStats();\r\n  } catch (err) {\r\n    console.error('Error getting weekly team stats:', err.message);\r\n  }\r\n\r\n  const stats = {\r\n    checkinRate: weeklyData.checkinRate || 0,\r\n    onTimeRate: weeklyData.onTimeRate || 0,\r\n    eodRate: weeklyData.eodRate || 0,\r\n    avgLateMinutes: weeklyData.avgLateMinutes || 0,\r\n    perfectAttendance: weeklyData.perfectAttendance || [],\r\n    taskStats: null,\r\n    topBlockers: []\r\n  };\r\n\r\n  // Get task stats if ClickUp enabled\r\n  if (config.clickup_config.enabled) {\r\n    const overdueByPerson = getTeamOverdueSummary();\r\n    const repeatDelays = getRepeatDelayedTasks();\r\n    const delayReasons = getWeeklyDelayReasons();\r\n\r\n    var totalDue = weeklyData.totalDue || 0;\r\n    var totalCompleted = weeklyData.totalCompleted || 0;\r\n    var totalMoved = weeklyData.totalMoved || 0;\r\n    var totalOverdue = weeklyData.totalOverdue || 0;\r\n    var completedLate = Math.max(0, totalCompleted - Math.round(totalCompleted * 0.85));\r\n\r\n    stats.taskStats = {\r\n      totalDue: totalDue,\r\n      completedOnTime: totalCompleted - completedLate,\r\n      onTimeRate: totalDue > 0 ? Math.round((totalCompleted - completedLate) / totalDue * 100) : 0,\r\n      completedLate: completedLate,\r\n      lateRate: totalDue > 0 ? Math.round(completedLate / totalDue * 100) : 0,\r\n      delayed: totalMoved,\r\n      delayedRate: totalDue > 0 ? Math.round(totalMoved / totalDue * 100) : 0,\r\n      stillOverdue: totalOverdue,\r\n      overdueByPerson: overdueByPerson ? overdueByPerson.map(p => ({\r\n        name: p.user_email.split('@')[0],\r\n        count: parseInt(p.total_overdue),\r\n        maxDays: parseInt(p.max_days_overdue),\r\n        avgDays: Math.round(parseFloat(p.avg_days_overdue) || 0)\r\n      })) : [],\r\n      repeatDelays: repeatDelays ? repeatDelays.map(t => ({\r\n        name: t.task_name,\r\n        times: parseInt(t.times_delayed),\r\n        assignee: t.user_email.split('@')[0]\r\n      })) : [],\r\n      delayReasons: {}\r\n    };\r\n\r\n    if (delayReasons) {\r\n      delayReasons.forEach(r => {\r\n        stats.taskStats.delayReasons[r.delay_reason] = parseInt(r.count);\r\n      });\r\n    }\r\n  }\r\n  \r\n  // Assemble hours data for weekly report\r\n  var hoursData = null;\r\n  try {\r\n    var weeklyHours = getWeeklyHoursData();\r\n    var hoursTrends = getHoursTrends();\r\n    var teamMembers = getCachedWorkingEmployees();\r\n    hoursData = assembleHoursData(weeklyHours, hoursTrends, teamMembers);\r\n  } catch (err) {\r\n    console.error('Hours data error:', err.message);\r\n  }\r\n  stats.hoursData = hoursData;\r\n\r\n  const message = buildWeeklySummaryMessage(stats);\r\n\r\n  const recipients = getReportRecipients('weekly_summary');\r\n  recipients.forEach(recipient => {\r\n    sendDirectMessage(recipient, message);\r\n  });\r\n  \r\n  logSystemEvent('WEEKLY_SUMMARY', 'SUCCESS', { recipients: recipients.length });\r\n  console.log(`Weekly summary sent to ${recipients.length} recipients`);\r\n}\r\n\r\n/**\r\n * Assemble hours data from BigQuery results for the weekly summary\r\n * Calculates per-person stats, team averages, outliers, and 4-week trends\r\n */\r\nfunction assembleHoursData(weeklyHours, hoursTrends, teamMembers) {\r\n  var config = getConfig();\r\n  var defaultHours = parseFloat(config.work_hours.default_hours_per_day) || 8;\r\n  var fridayHours = parseFloat(config.work_hours.friday_hours_per_day) || 4;\r\n  // Expected total per week: 4 weekdays * default + 1 friday * friday hours\r\n  var expectedWeeklyTotal = (4 * defaultHours) + fridayHours;\r\n\r\n  // Per-person weekly hours\r\n  var personHours = {};\r\n  if (weeklyHours && weeklyHours.length > 0) {\r\n    weeklyHours.forEach(function(row) {\r\n      var email = row.user_email;\r\n      if (!personHours[email]) {\r\n        personHours[email] = { totalHours: 0, daysReported: 0, dailyHours: [] };\r\n      }\r\n      var hrs = parseFloat(row.hours_worked) || 0;\r\n      personHours[email].totalHours += hrs;\r\n      personHours[email].daysReported += 1;\r\n      personHours[email].dailyHours.push(hrs);\r\n    });\r\n  }\r\n\r\n  var perPerson = [];\r\n  var teamTotalHours = 0;\r\n  var teamDaysReported = 0;\r\n  var totalMembers = teamMembers ? teamMembers.length : 0;\r\n  var membersReporting = 0;\r\n\r\n  for (var email in personHours) {\r\n    var data = personHours[email];\r\n    var avgDaily = data.daysReported > 0 ? Math.round(data.totalHours / data.daysReported * 10) / 10 : 0;\r\n    var delta = Math.round((data.totalHours - expectedWeeklyTotal) * 10) / 10;\r\n    var member = teamMembers ? teamMembers.find(function(m) { return m.email === email; }) : null;\r\n    var name = member ? (member.name || email.split('@')[0]) : email.split('@')[0];\r\n\r\n    perPerson.push({\r\n      name: name,\r\n      email: email,\r\n      avgDaily: avgDaily,\r\n      totalHours: Math.round(data.totalHours * 10) / 10,\r\n      expectedTotal: expectedWeeklyTotal,\r\n      delta: delta,\r\n      daysReported: data.daysReported\r\n    });\r\n\r\n    teamTotalHours += data.totalHours;\r\n    teamDaysReported += data.daysReported;\r\n    membersReporting++;\r\n  }\r\n\r\n  var teamAvgDaily = teamDaysReported > 0 ? Math.round(teamTotalHours / teamDaysReported * 10) / 10 : 0;\r\n  var reportingRate = totalMembers > 0 ? Math.round(membersReporting / totalMembers * 100) : 0;\r\n\r\n  // Outliers: < 70% or > 120% of expected\r\n  var outliers = perPerson.filter(function(p) {\r\n    var ratio = p.totalHours / p.expectedTotal;\r\n    return ratio < 0.7 || ratio > 1.2;\r\n  }).map(function(p) {\r\n    var ratio = Math.round(p.totalHours / p.expectedTotal * 100);\r\n    return {\r\n      name: p.name,\r\n      totalHours: p.totalHours,\r\n      expectedTotal: p.expectedTotal,\r\n      ratio: ratio,\r\n      flag: ratio < 70 ? 'LOW' : 'HIGH'\r\n    };\r\n  });\r\n\r\n  // 4-week trends\r\n  var weeklyTrends = {};\r\n  if (hoursTrends && hoursTrends.length > 0) {\r\n    hoursTrends.forEach(function(row) {\r\n      var weekNum = row.week_num;\r\n      if (!weeklyTrends[weekNum]) {\r\n        weeklyTrends[weekNum] = {\r\n          weekStart: row.week_start,\r\n          totalHours: 0,\r\n          totalDays: 0,\r\n          memberCount: 0\r\n        };\r\n      }\r\n      weeklyTrends[weekNum].totalHours += parseFloat(row.total_hours) || 0;\r\n      weeklyTrends[weekNum].totalDays += parseInt(row.days_reported) || 0;\r\n      weeklyTrends[weekNum].memberCount++;\r\n    });\r\n  }\r\n\r\n  var trends = [];\r\n  var sortedWeeks = Object.keys(weeklyTrends).sort();\r\n  for (var i = 0; i < sortedWeeks.length; i++) {\r\n    var wk = weeklyTrends[sortedWeeks[i]];\r\n    var avgHrs = wk.totalDays > 0 ? Math.round(wk.totalHours / wk.totalDays * 10) / 10 : 0;\r\n    var prevAvg = i > 0 ? trends[i - 1].avgDaily : null;\r\n    var change = prevAvg !== null ? Math.round((avgHrs - prevAvg) * 10) / 10 : null;\r\n    trends.push({\r\n      weekStart: wk.weekStart,\r\n      avgDaily: avgHrs,\r\n      totalHours: Math.round(wk.totalHours * 10) / 10,\r\n      change: change,\r\n      direction: change === null ? '-' : (change > 0 ? '‚Üë' : (change < 0 ? '‚Üì' : '‚Üí'))\r\n    });\r\n  }\r\n\r\n  return {\r\n    perPerson: perPerson,\r\n    teamAvgDaily: teamAvgDaily,\r\n    teamTotalWeek: Math.round(teamTotalHours * 10) / 10,\r\n    reportingRate: reportingRate,\r\n    expectedWeeklyTotal: expectedWeeklyTotal,\r\n    outliers: outliers,\r\n    trends: trends\r\n  };\r\n}\r\n"
    },
    {
      "name": "SageHR.gs",
      "type": "server_js",
      "source": "/**\r\n * SageHR.gs - Sage HR API Integration\r\n * Syncs employee data from Sage HR\r\n */\r\n\r\nconst SAGE_HR_BASE_URL = 'https://omnisecsolutions.sage.hr/api/';\r\n\r\n/**\r\n * Make authenticated request to Sage HR API\r\n */\r\nfunction sageHRRequest(endpoint, method = 'GET', payload = null) {\r\n  const config = getConfig();\r\n  const apiKey = config.sage_hr_api_key;\r\n\r\n  if (!apiKey) {\r\n    console.error('Sage HR API key not configured');\r\n    return null;\r\n  }\r\n\r\n  const options = {\r\n    method: method,\r\n    headers: {\r\n      'X-Auth-Token': apiKey,\r\n      'Content-Type': 'application/json'\r\n    },\r\n    muteHttpExceptions: true\r\n  };\r\n\r\n  if (payload) {\r\n    options.payload = JSON.stringify(payload);\r\n  }\r\n\r\n  try {\r\n    const response = UrlFetchApp.fetch(SAGE_HR_BASE_URL + endpoint, options);\r\n    const code = response.getResponseCode();\r\n\r\n    if (code >= 400) {\r\n      console.error(`Sage HR API error: ${code} - ${response.getContentText()}`);\r\n      return null;\r\n    }\r\n\r\n    return JSON.parse(response.getContentText());\r\n  } catch (error) {\r\n    console.error('Sage HR request failed:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all employees from Sage HR\r\n */\r\nfunction getSageHREmployees() {\r\n  const result = sageHRRequest('/employees');\r\n\r\n  if (!result || !result.data) {\r\n    console.error('Failed to fetch Sage HR employees');\r\n    return [];\r\n  }\r\n\r\n  return result.data.map(emp => ({\r\n    id: emp.id,\r\n    email: emp.email,\r\n    first_name: emp.first_name,\r\n    last_name: emp.last_name,\r\n    full_name: `${emp.first_name} ${emp.last_name}`,\r\n    name: `${emp.first_name} ${emp.last_name}`, // alias for compatibility with code that uses member.name\r\n    department: emp.department?.name || '',\r\n    position: emp.position?.name || '',\r\n    manager_id: emp.reports_to?.id || null,\r\n    manager_email: emp.reports_to?.email || null,\r\n    status: 'active', //FIXED: emp doesn't have status field,this api already filter active employees: https://developer.sage.com/hr/apis/sagehr/v1.0.0/sage-hr-v1-0-swagger/tags/employee/paths/list-active-employees-in-company\r\n    start_date: emp.start_date\r\n  }));\r\n}\r\n\r\n/**\r\n * Get employees who are working today (not on leave)\r\n */\r\nfunction getWorkingEmployeesToday() {\r\n  const today = new Date();\r\n  const dateStr = Utilities.formatDate(today, 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  // Get all employees\r\n  const employees = getSageHREmployees();\r\n  if (!employees.length) {\r\n    // Fallback to config sheet if Sage HR fails\r\n    console.warn('Falling back to config sheet for team members');\r\n    return getActiveTeamMembers();\r\n  }\r\n\r\n  // Get leave requests for today\r\n  const leaves = sageHRRequest(`/leave-management/requests?from=${dateStr}&to=${dateStr}`);\r\n  const onLeave = new Set();\r\n\r\n  if (leaves && leaves.data) {\r\n    leaves.data.forEach(leave => {\r\n      if (leave.status === 'Approved') {\r\n        onLeave.add(leave.employee_id);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Filter out employees on leave\r\n  const working = employees.filter(emp => {\r\n    return emp.status === 'active' && !onLeave.has(emp.id);\r\n  });\r\n\r\n  return working;\r\n}\r\n\r\n/**\r\n * Daily Sage HR sync - runs at 6:00 AM\r\n * Syncs employee data and stores in BigQuery\r\n */\r\nfunction dailySageHRSync() {\r\n  console.log('Starting daily Sage HR sync...');\r\n\r\n  if (!isWorkday()) {\r\n    console.log('Not a workday, skipping Sage HR sync');\r\n    return;\r\n  }\r\n\r\n  const employees = getSageHREmployees();\r\n\r\n  if (!employees.length) {\r\n    logSystemEvent('SAGE_HR_SYNC', 'FAILED', { error: 'No employees returned' });\r\n\r\n    // Alert manager\r\n    const config = getConfig();\r\n    sendDirectMessage(\r\n      config.settings.manager_email,\r\n      '‚ö†Ô∏è **Sage HR Sync Failed**\\n\\nCould not fetch employee data from Sage HR. Using cached/config data for today.'\r\n    );\r\n    return;\r\n  }\r\n\r\n  // Get who's on leave today\r\n  const working = getWorkingEmployeesToday();\r\n  const onLeaveCount = employees.filter(e => e.status === 'active').length - working.length;\r\n\r\n  // Store sync results\r\n  const syncData = {\r\n    sync_date: new Date().toISOString(),\r\n    total_employees: employees.length,\r\n    active_employees: employees.filter(e => e.status === 'active').length,\r\n    on_leave_today: onLeaveCount,\r\n    working_today: working.length\r\n  };\r\n\r\n  // Log to BigQuery\r\n  insertIntoBigQuery('sage_hr_syncs', [syncData]);\r\n\r\n  // Update team members cache\r\n  updateTeamMembersCache(working);\r\n\r\n  logSystemEvent('SAGE_HR_SYNC', 'SUCCESS', syncData);\r\n  console.log(`Sage HR sync complete: ${working.length} working today, ${onLeaveCount} on leave`);\r\n}\r\n\r\n/**\r\n * Update team members cache in Script Properties\r\n */\r\nfunction updateTeamMembersCache(employees) {\r\n  const cache = CacheService.getScriptCache();\r\n  cache.put('working_employees', JSON.stringify(employees), 21600); // 6 hours\r\n}\r\n\r\n/**\r\n * Get cached working employees\r\n */\r\nfunction getCachedWorkingEmployees() {\r\n  const cache = CacheService.getScriptCache();\r\n  const cached = cache.get('working_employees');\r\n\r\n  if (cached) {\r\n    return JSON.parse(cached);\r\n  }\r\n\r\n  // If no cache, fetch fresh\r\n  return getWorkingEmployeesToday();\r\n}\r\n\r\n/**\r\n * Check if an employee is on leave today\r\n */\r\nfunction isEmployeeOnLeave(email) {\r\n  const working = getCachedWorkingEmployees();\r\n  return !working.some(e => e.email === email);\r\n}\r\n\r\n/**\r\n * Get employees who are on leave today (for morning summary \"Out Today\" section)\r\n * Returns array of { name, email, leave_type }\r\n */\r\nfunction getEmployeesOnLeaveToday() {\r\n  var today = new Date();\r\n  var dateStr = Utilities.formatDate(today, 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  var employees = getSageHREmployees();\r\n  if (!employees || employees.length === 0) return [];\r\n\r\n  var leaves = sageHRRequest('/leave-management/requests?from=' + dateStr + '&to=' + dateStr);\r\n  if (!leaves || !leaves.data) return [];\r\n\r\n  var onLeave = [];\r\n  leaves.data.forEach(function (leave) {\r\n    if (leave.status === 'Approved') {\r\n      var emp = employees.find(function (e) { return e.id === leave.employee_id; });\r\n      if (emp && emp.status === 'active') {\r\n        onLeave.push({\r\n          name: emp.full_name || emp.email.split('@')[0],\r\n          email: emp.email,\r\n          leave_type: leave.policy_name || leave.leave_type || 'PTO'\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  return onLeave;\r\n}\r\n\r\n/**\r\n * Get employees with birthdays today (for morning summary)\r\n * Returns array of { name, email }\r\n */\r\nfunction getTodayBirthdays() {\r\n  var today = new Date();\r\n  var todayMonth = today.getMonth() + 1; // 1-indexed\r\n  var todayDay = today.getDate();\r\n\r\n  var employees = sageHRRequest('/employees');\r\n  if (employees && employees.data) {\r\n    var todayBirthdays = [];\r\n    employees.data.forEach(function (emp) {\r\n      if (emp.date_of_birth) {\r\n        var dob = new Date(emp.date_of_birth);\r\n        dob.setTime(dob.getTime() + 6 * 60 * 60 * 1000);\r\n        if ((dob.getMonth() + 1) === todayMonth && dob.getDate() === todayDay) {\r\n          todayBirthdays.push({\r\n            name: emp.first_name + ' ' + emp.last_name,\r\n            email: emp.email\r\n          });\r\n        }\r\n      }\r\n    });\r\n    return todayBirthdays;\r\n  }\r\n\r\n  // Fallback: check individual employee records\r\n  var employees = getSageHREmployees();\r\n  if (!employees || employees.length === 0) return [];\r\n\r\n  // Sage HR may not expose DOB in standard endpoint; return empty gracefully\r\n  return [];\r\n}\r\n\r\n// ============================================\r\n// SPREADSHEET SYNC FUNCTIONS\r\n// ============================================\r\n\r\n/**\r\n * Sync employees from Sage HR to the team_members spreadsheet tab\r\n * This writes/updates the team_members tab with current Sage HR data\r\n */\r\nfunction syncEmployeesToSheet() {\r\n  console.log('Syncing employees to spreadsheet...');\r\n\r\n  const employees = getSageHREmployees();\r\n  if (!employees || employees.length === 0) {\r\n    console.error('No employees to sync');\r\n    return { success: false, error: 'No employees returned from Sage HR' };\r\n  }\r\n\r\n  const props = PropertiesService.getScriptProperties();\r\n  const sheetId = props.getProperty('CONFIG_SHEET_ID');\r\n\r\n  if (!sheetId) {\r\n    console.error('CONFIG_SHEET_ID not set');\r\n    return { success: false, error: 'CONFIG_SHEET_ID not configured' };\r\n  }\r\n\r\n  const ss = SpreadsheetApp.openById(sheetId);\r\n  let sheet = ss.getSheetByName('team_members');\r\n\r\n  // Create sheet if it doesn't exist\r\n  if (!sheet) {\r\n    sheet = ss.insertSheet('team_members');\r\n    console.log('Created team_members sheet');\r\n  }\r\n\r\n  // Prepare header row\r\n  const headers = ['email', 'name', 'department', 'manager_email', 'active', 'custom_start_time', 'custom_end_time', 'timezone', 'task_source', 'tracking_mode', 'custom_block2_start', 'custom_block2_end'];\r\n\r\n  // Get existing data to preserve custom fields (custom_start_time, custom_end_time, timezone, task_source)\r\n  const existingData = sheet.getDataRange().getValues();\r\n  const existingByEmail = {};\r\n\r\n  if (existingData.length > 1) {\r\n    for (let i = 1; i < existingData.length; i++) {\r\n      const email = existingData[i][0];\r\n      if (email) {\r\n        existingByEmail[email] = {\r\n          custom_start_time: existingData[i][5] || '',\r\n          custom_end_time: existingData[i][6] || '',\r\n          timezone: existingData[i][7] || 'America/Chicago',\r\n          task_source: existingData[i][8] || 'clickup',\r\n          tracking_mode: existingData[i][9] || 'tracked',\r\n          custom_block2_start: existingData[i][10] || '',\r\n          custom_block2_end: existingData[i][11] || ''\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  // Prepare rows from Sage HR data, preserving custom fields\r\n  const rows = employees.map(emp => {\r\n    const existing = existingByEmail[emp.email] || {};\r\n    return [\r\n      emp.email,\r\n      emp.full_name || emp.name,\r\n      emp.department || '',\r\n      emp.manager_email || '',\r\n      emp.status === 'active' ? 'TRUE' : 'FALSE',\r\n      existing.custom_start_time || '',\r\n      existing.custom_end_time || '',\r\n      existing.timezone || 'America/Chicago',\r\n      existing.task_source || 'clickup',\r\n      existing.tracking_mode || 'tracked',\r\n      existing.custom_block2_start || '',\r\n      existing.custom_block2_end || ''\r\n    ];\r\n  });\r\n\r\n  // Clear and write data\r\n  sheet.clear();\r\n  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);\r\n\r\n  if (rows.length > 0) {\r\n    sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);\r\n  }\r\n\r\n  // Format header row\r\n  sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');\r\n\r\n  console.log(`Synced ${rows.length} employees to team_members sheet`);\r\n  return { success: true, count: rows.length };\r\n}\r\n\r\n/**\r\n * Sync time-off/leave data from Sage HR to a time_off spreadsheet tab\r\n * Fetches leave requests for the current week\r\n */\r\nfunction syncLeavesToSheet() {\r\n  console.log('Syncing leaves to spreadsheet...');\r\n\r\n  const props = PropertiesService.getScriptProperties();\r\n  const sheetId = props.getProperty('CONFIG_SHEET_ID');\r\n\r\n  if (!sheetId) {\r\n    console.error('CONFIG_SHEET_ID not set');\r\n    return { success: false, error: 'CONFIG_SHEET_ID not configured' };\r\n  }\r\n\r\n  const ss = SpreadsheetApp.openById(sheetId);\r\n  let sheet = ss.getSheetByName('time_off_view');\r\n\r\n  // Create sheet if it doesn't exist\r\n  if (!sheet) {\r\n    sheet = ss.insertSheet('time_off_view');\r\n    console.log('Created time_off_view sheet');\r\n  }\r\n\r\n  // Get employees for name lookup\r\n  const employees = getSageHREmployees();\r\n  const empById = {};\r\n  employees.forEach(e => { empById[e.id] = e; });\r\n\r\n  // Fetch leaves for next 14 days\r\n  const today = new Date();\r\n  const endDate = new Date(today);\r\n  endDate.setDate(endDate.getDate() + 14);\r\n\r\n  const startStr = Utilities.formatDate(today, 'America/Chicago', 'yyyy-MM-dd');\r\n  const endStr = Utilities.formatDate(endDate, 'America/Chicago', 'yyyy-MM-dd');\r\n\r\n  // Try to get leaves using date range\r\n  let allLeaves = [];\r\n\r\n  // Fetch for each day (Sage HR may require specific dates)\r\n  for (let d = new Date(today); d <= endDate; d.setDate(d.getDate() + 1)) {\r\n    const dateStr = Utilities.formatDate(d, 'America/Chicago', 'yyyy-MM-dd');\r\n    const leaves = sageHRRequest('/leave-management/requests?from=' + dateStr + '&to=' + dateStr);\r\n\r\n    if (leaves && leaves.data) {\r\n      leaves.data.forEach(leave => {\r\n        // Avoid duplicates\r\n        if (!allLeaves.find(l => l.id === leave.id)) {\r\n          allLeaves.push(leave);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // Prepare header row\r\n  const headers = ['employee_email', 'employee_name', 'leave_type', 'start_date', 'end_date', 'status', 'days'];\r\n\r\n  // Prepare rows\r\n  const rows = allLeaves.map(leave => {\r\n    const emp = empById[leave.employee_id] || {};\r\n    return [\r\n      emp.email || '',\r\n      emp.full_name || emp.name || '',\r\n      leave.policy_name || leave.leave_type || 'Unknown',\r\n      leave.start_date || '',\r\n      leave.end_date || '',\r\n      leave.status || '',\r\n      leave.days || ''\r\n    ];\r\n  }).filter(row => row[4] !== ''); // Filter out rows without end_date (incomplete data)\r\n\r\n  // Sort by start_date\r\n  rows.sort((a, b) => (a[3] || '').localeCompare(b[3] || ''));\r\n\r\n  // Clear and write data\r\n  sheet.clear();\r\n  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);\r\n\r\n  if (rows.length > 0) {\r\n    sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);\r\n  }\r\n\r\n  // Format header row\r\n  sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');\r\n\r\n  console.log(`Synced ${rows.length} leave records to time_off_view sheet`);\r\n  return { success: true, count: rows.length };\r\n}\r\n\r\n/**\r\n * Full Sage HR sync - employees + leaves to spreadsheet + BigQuery\r\n * Run this manually or call from dailySageHRSync\r\n */\r\nfunction fullSageHRSync() {\r\n  console.log('=== Full Sage HR Sync ===');\r\n\r\n  // Sync employees to spreadsheet\r\n  const empResult = syncEmployeesToSheet();\r\n  console.log('Employee sync:', empResult);\r\n\r\n  // Sync leaves to spreadsheet\r\n  const leaveResult = syncLeavesToSheet();\r\n  console.log('Leave sync:', leaveResult);\r\n\r\n  // Also run the regular daily sync (BigQuery + cache)\r\n  dailySageHRSync();\r\n\r\n  return {\r\n    employees: empResult,\r\n    leaves: leaveResult\r\n  };\r\n}\r\n\r\n/**\r\n * Test Sage HR connection and show what data is available\r\n */\r\nfunction testSageHRData() {\r\n  console.log('=== Testing Sage HR Data ===');\r\n\r\n  // Test employees endpoint\r\n  const employees = getSageHREmployees();\r\n  console.log('Employees fetched:', employees.length);\r\n  if (employees.length > 0) {\r\n    console.log('Sample employee:', JSON.stringify(employees[0], null, 2));\r\n  }\r\n\r\n  // Test leaves endpoint for today\r\n  const today = Utilities.formatDate(new Date(), 'America/Chicago', 'yyyy-MM-dd');\r\n  const leaves = sageHRRequest('/leave-management/requests?from=' + today + '&to=' + today);\r\n  console.log('Leaves for today:', leaves ? (leaves.data ? leaves.data.length : 'no data array') : 'null response');\r\n  if (leaves && leaves.data && leaves.data.length > 0) {\r\n    console.log('Sample leave:', JSON.stringify(leaves.data[0], null, 2));\r\n  }\r\n\r\n  return {\r\n    employees: employees.length,\r\n    leaves: leaves ? (leaves.data ? leaves.data.length : 0) : 0,\r\n    birthdays: birthdays ? (birthdays.data ? birthdays.data.length : 0) : 0\r\n  };\r\n}\r\n\r\n"
    },
    {
      "name": "Templates.gs",
      "type": "server_js",
      "source": "/**\r\n * Templates.gs - Message Templates\r\n * All message templates for check-ins, EOD, summaries, etc.\r\n *\r\n * ============================================\r\n * ODOO INTEGRATION POINTS:\r\n * ============================================\r\n *\r\n * 1. getMorningCheckInMessage() - Line ~9\r\n *    - Check member's task_source setting\r\n *    - If 'odoo' or 'both', call getOdooTaskSummary(email)\r\n *    - Include Odoo tasks in the morning message\r\n *    - Example:\r\n *      const odooTasks = member.task_source !== 'clickup'\r\n *        ? getOdooTasksForUser(member.email, 'today')\r\n *        : [];\r\n *\r\n * 2. getEodRequestMessage() - Line ~39\r\n *    - Same logic: check task_source, fetch Odoo tasks\r\n *    - Merge ClickUp and Odoo tasks if 'both'\r\n *    - Build cards for Odoo tasks (may need OdooCards.gs)\r\n *\r\n * 3. buildMorningTaskMessage() - Called from getMorningCheckInMessage\r\n *    - May need separate section for Odoo tasks\r\n *    - Example: \"üìã ClickUp Tasks:\\n...\\n\\nüìä Odoo Tasks:\\n...\"\r\n *\r\n * 4. buildEodTaskMessage() - Called from getEodRequestMessage\r\n *    - Need to handle mixed task sources\r\n *    - Odoo task cards may have different actions\r\n *\r\n * ============================================\r\n */\r\n\r\n/**\r\n * Get morning check-in message\r\n */\r\nfunction getMorningCheckInMessage(member, tasks, isMonday) {\r\n  const config = getConfig();\r\n  const userName = member.name || member.email.split('@')[0];\r\n  \r\n  // If Monday and weekly preview enabled\r\n  if (isMonday && config.clickup_config.show_weekly_monday) {\r\n    return buildWeeklyTaskPreview(tasks, userName);\r\n  }\r\n  \r\n  // Regular day with tasks\r\n  if (config.clickup_config.include_in_morning && tasks && tasks.length > 0) {\r\n    return buildMorningTaskMessage(tasks, userName);\r\n  }\r\n  \r\n  // No tasks or ClickUp disabled\r\n  return `Good morning${userName ? ', ' + userName : ''}! üëã\\n\\n` +\r\n    `Please confirm you're online by replying \"here\" or sharing your #1 priority for today.`;\r\n}\r\n\r\n/**\r\n * Get check-in follow-up message\r\n */\r\nfunction getCheckInFollowUpMessage() {\r\n  return `‚è∞ **Reminder:** Please confirm you're online.\\n\\n` +\r\n    `Reply \"here\" or share what you're working on today.`;\r\n}\r\n\r\n/**\r\n * Get EOD request message with tasks\r\n */\r\nfunction getEodRequestMessage(member, tasks) {\r\n  const config = getConfig();\r\n  \r\n  if (config.clickup_config.include_in_eod && tasks && tasks.length > 0) {\r\n    return buildEodTaskMessage(tasks);\r\n  }\r\n  \r\n  // No tasks or ClickUp disabled\r\n  return {\r\n    text: `Time for your EOD report! üìù\\n\\n` +\r\n      `Please share:\\n` +\r\n      `1. Tasks completed today\\n` +\r\n      `2. Blockers (if any)\\n` +\r\n      `3. Tomorrow's priority\\n\\n` +\r\n      `‚è∞ Please include your hours worked today. Example: \"Worked 7 hours. Completed X, Y, Z...\"`,\r\n    cardsV2: null\r\n  };\r\n}\r\n\r\n/**\r\n * Get EOD follow-up message\r\n */\r\nfunction getEodFollowUpMessage() {\r\n  return `‚è∞ **EOD Reminder:** Please submit your end-of-day report.\\n\\n` +\r\n    `Share what you accomplished, any blockers, and tomorrow's priority.\\n` +\r\n    `Don't forget to include your hours worked (e.g. \"7 hours\").`;\r\n}\r\n\r\n/**\r\n * Get check-in confirmation message\r\n */\r\nfunction getCheckInConfirmation(isLate) {\r\n  if (isLate) {\r\n    return `‚úÖ Check-in received (late). Thanks for confirming!`;\r\n  }\r\n  return `‚úÖ Thanks for checking in! Have a productive day.`;\r\n}\r\n\r\n/**\r\n * Get EOD confirmation message\r\n */\r\nfunction getEodConfirmation() {\r\n  return `‚úÖ EOD report received. Great work today! See you tomorrow.`;\r\n}\r\n\r\n/**\r\n * Get Friday EOD confirmation\r\n */\r\nfunction getFridayEodConfirmation() {\r\n  return `‚úÖ EOD report received. Great work this week! Enjoy your weekend! üéâ`;\r\n}\r\n\r\n/**\r\n * Get escalation message for missed check-in\r\n */\r\nfunction getMissedCheckInEscalation(memberEmail, memberName) {\r\n  return `‚ö†Ô∏è **Missed Check-in Alert**\\n\\n` +\r\n    `${memberName || memberEmail} has not checked in today.\\n\\n` +\r\n    `Please follow up to confirm they are available.`;\r\n}\r\n\r\n/**\r\n * Get escalation message for missed EOD\r\n */\r\nfunction getMissedEodEscalation(memberEmail, memberName) {\r\n  return `‚ö†Ô∏è **Missed EOD Report**\\n\\n` +\r\n    `${memberName || memberEmail} has not submitted their EOD report.\\n\\n` +\r\n    `Please follow up to ensure their day's work is documented.`;\r\n}\r\n\r\n/**\r\n * Build weekly gamification message\r\n */\r\nfunction buildWeeklyGamificationMessage(leaderboard, badges) {\r\n  let message = `üèÜ **Weekly Leaderboard**\\n\\n`;\r\n  \r\n  // Attendance section\r\n  message += `üìä **Attendance Champions:**\\n`;\r\n  if (leaderboard.attendance && leaderboard.attendance.length > 0) {\r\n    const medals = ['ü•á', 'ü•à', 'ü•â'];\r\n    leaderboard.attendance.slice(0, 3).forEach((person, i) => {\r\n      message += `${medals[i]} ${person.name} - ${person.onTimeRate}% on-time\\n`;\r\n    });\r\n  }\r\n  message += '\\n';\r\n  \r\n  // Task completion section\r\n  if (leaderboard.taskCompletion && leaderboard.taskCompletion.length > 0) {\r\n    message += `üìã **Task Completion:**\\n`;\r\n    const medals = ['ü•á', 'ü•à', 'ü•â'];\r\n    leaderboard.taskCompletion.slice(0, 3).forEach((person, i) => {\r\n      message += `${medals[i]} ${person.name} - ${person.completionRate}% (${person.completed}/${person.total})\\n`;\r\n    });\r\n    message += '\\n';\r\n  }\r\n  \r\n  // Zero overdue\r\n  if (leaderboard.zeroOverdue && leaderboard.zeroOverdue.length > 0) {\r\n    message += `‚ö° **Zero Overdue:**\\n`;\r\n    message += leaderboard.zeroOverdue.map(p => p.name).join(', ') + '\\n\\n';\r\n  }\r\n  \r\n  // Badges earned\r\n  if (badges && badges.length > 0) {\r\n    message += `üèÖ **Badges Earned This Week:**\\n`;\r\n    badges.forEach(b => {\r\n      message += `‚Ä¢ ${b.name}: ${b.badge} ${b.badgeName}\\n`;\r\n    });\r\n  }\r\n  \r\n  return message;\r\n}\r\n\r\n/**\r\n * Build weekly summary message for managers\r\n */\r\nfunction buildWeeklySummaryMessage(stats) {\r\n  const weekStart = Utilities.formatDate(\r\n    new Date(Date.now() - 4 * 24 * 60 * 60 * 1000), \r\n    'America/Chicago', \r\n    'MMM d'\r\n  );\r\n  const weekEnd = Utilities.formatDate(new Date(), 'America/Chicago', 'MMM d');\r\n  \r\n  let message = `üìä **Weekly Report - ${weekStart} to ${weekEnd}**\\n\\n`;\r\n  \r\n  // Attendance\r\n  message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n`;\r\n  message += `üë• ATTENDANCE\\n`;\r\n  message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n  message += `‚Ä¢ Check-in rate: ${stats.checkinRate}%\\n`;\r\n  message += `‚Ä¢ On-time rate: ${stats.onTimeRate}%\\n`;\r\n  message += `‚Ä¢ EOD submission rate: ${stats.eodRate}%\\n`;\r\n  message += `‚Ä¢ Average late arrivals: ${stats.avgLateMinutes} min\\n\\n`;\r\n  \r\n  if (stats.perfectAttendance && stats.perfectAttendance.length > 0) {\r\n    message += `üåü Perfect attendance: ${stats.perfectAttendance.join(', ')}\\n\\n`;\r\n  }\r\n\r\n  // Hours section\r\n  if (stats.hoursData) {\r\n    var hd = stats.hoursData;\r\n    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n`;\r\n    message += `‚è±Ô∏è HOURS\\n`;\r\n    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `‚Ä¢ Team avg daily hours: ${hd.teamAvgDaily}h (expected: ${hd.expectedWeeklyTotal / 5}h)\\n`;\r\n    message += `‚Ä¢ Team total weekly hours: ${hd.teamTotalWeek}h\\n`;\r\n    message += `‚Ä¢ Hours reporting rate: ${hd.reportingRate}%\\n\\n`;\r\n\r\n    if (hd.perPerson && hd.perPerson.length > 0) {\r\n      message += `**Per-Person Hours:**\\n`;\r\n      message += `| Name | Avg/Day | Total | Expected | Delta |\\n`;\r\n      message += `|------|---------|-------|----------|-------|\\n`;\r\n      hd.perPerson.forEach(function(p) {\r\n        var deltaStr = p.delta >= 0 ? '+' + p.delta : '' + p.delta;\r\n        message += `| ${p.name} | ${p.avgDaily}h | ${p.totalHours}h | ${p.expectedTotal}h | ${deltaStr}h |\\n`;\r\n      });\r\n      message += '\\n';\r\n    }\r\n\r\n    // 4-week trends\r\n    if (hd.trends && hd.trends.length > 0) {\r\n      message += `**Week-over-Week Trends (last ${hd.trends.length} weeks):**\\n`;\r\n      hd.trends.forEach(function(t) {\r\n        var changeStr = t.change !== null ? ' ' + t.direction + ' ' + Math.abs(t.change) + 'h' : '';\r\n        message += `‚Ä¢ Week of ${t.weekStart}: avg ${t.avgDaily}h/day (total ${t.totalHours}h)${changeStr}\\n`;\r\n      });\r\n      message += '\\n';\r\n    }\r\n\r\n    // Outliers\r\n    if (hd.outliers && hd.outliers.length > 0) {\r\n      message += `**‚ö†Ô∏è Hours Outliers:**\\n`;\r\n      hd.outliers.forEach(function(o) {\r\n        var flagEmoji = o.flag === 'LOW' ? 'üîª' : 'üî∫';\r\n        message += `‚Ä¢ ${flagEmoji} ${o.name}: ${o.totalHours}h / ${o.expectedTotal}h expected (${o.ratio}%)\\n`;\r\n      });\r\n      message += '\\n';\r\n    }\r\n  }\r\n\r\n  // Task performance\r\n  if (stats.taskStats) {\r\n    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n`;\r\n    message += `üìã TASK PERFORMANCE\\n`;\r\n    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    message += `**Team Totals:**\\n`;\r\n    message += `‚Ä¢ Tasks due: ${stats.taskStats.totalDue}\\n`;\r\n    message += `‚Ä¢ Completed on time: ${stats.taskStats.completedOnTime} (${stats.taskStats.onTimeRate}%)\\n`;\r\n    message += `‚Ä¢ Completed late: ${stats.taskStats.completedLate} (${stats.taskStats.lateRate}%)\\n`;\r\n    message += `‚Ä¢ Delayed: ${stats.taskStats.delayed} (${stats.taskStats.delayedRate}%)\\n`;\r\n    message += `‚Ä¢ Still overdue: ${stats.taskStats.stillOverdue}\\n\\n`;\r\n    \r\n    // Overdue breakdown by person\r\n    if (stats.taskStats.overdueByPerson && stats.taskStats.overdueByPerson.length > 0) {\r\n      message += `**Overdue Breakdown:**\\n`;\r\n      message += `| Person | Overdue | Oldest | Avg Days |\\n`;\r\n      message += `|--------|---------|--------|----------|\\n`;\r\n      stats.taskStats.overdueByPerson.forEach(p => {\r\n        message += `| ${p.name} | ${p.count} | ${p.maxDays} days | ${p.avgDays} |\\n`;\r\n      });\r\n      message += '\\n';\r\n    }\r\n    \r\n    // Chronic overdue\r\n    if (stats.taskStats.chronicOverdue && stats.taskStats.chronicOverdue.length > 0) {\r\n      message += `**Chronic Overdue (3+ days):**\\n`;\r\n      stats.taskStats.chronicOverdue.slice(0, 5).forEach(t => {\r\n        message += `‚Ä¢ \"${t.name}\" - ${t.assignee} - ${t.daysOverdue} days\\n`;\r\n      });\r\n      message += '\\n';\r\n    }\r\n    \r\n    // Most delayed tasks\r\n    if (stats.taskStats.repeatDelays && stats.taskStats.repeatDelays.length > 0) {\r\n      message += `**Most Delayed Tasks:**\\n`;\r\n      stats.taskStats.repeatDelays.slice(0, 3).forEach(t => {\r\n        message += `‚Ä¢ \"${t.name}\" - moved ${t.times} times (${t.assignee})\\n`;\r\n      });\r\n      message += '\\n';\r\n    }\r\n    \r\n    // Delay reasons\r\n    if (stats.taskStats.delayReasons && Object.keys(stats.taskStats.delayReasons).length > 0) {\r\n      message += `**Delay Reasons:**\\n`;\r\n      const totalDelays = Object.values(stats.taskStats.delayReasons).reduce((a, b) => a + b, 0);\r\n      Object.entries(stats.taskStats.delayReasons).forEach(([reason, count]) => {\r\n        const pct = Math.round(count / totalDelays * 100);\r\n        message += `‚Ä¢ ${formatDelayReason(reason)}: ${count} (${pct}%)\\n`;\r\n      });\r\n      message += '\\n';\r\n    }\r\n  }\r\n  \r\n  // Blockers\r\n  if (stats.topBlockers && stats.topBlockers.length > 0) {\r\n    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n`;\r\n    message += `üöß TOP BLOCKERS\\n`;\r\n    message += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n\\n`;\r\n    stats.topBlockers.forEach(b => {\r\n      message += `‚Ä¢ ${b.description} (mentioned ${b.count}x)\\n`;\r\n    });\r\n    message += '\\n';\r\n  }\r\n  \r\n  return message;\r\n}\r\n\r\n/**\r\n * Build AI evaluation prompt (enhanced with hours analysis)\r\n */\r\nfunction buildAiEvaluationPrompt(teamData, lastEvaluation) {\r\n  var today = new Date();\r\n  var dayName = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][today.getDay()];\r\n\r\n  var prompt = 'You are evaluating daily team performance for a remote team. Today is ' + dayName + '.\\n\\n';\r\n  prompt += 'You have BOTH today\\'s data AND historical context (last 7 days + 4-week trends). ';\r\n  prompt += 'Use each person\\'s own historical baseline to make specific, evidence-based assessments. ';\r\n  prompt += 'Do NOT make generic observations ‚Äî compare today to their personal patterns.\\n\\n';\r\n\r\n  // --- Last evaluation for continuity ---\r\n  if (lastEvaluation && lastEvaluation.evaluation_text) {\r\n    prompt += '## Previous Evaluation (' + lastEvaluation.evaluation_date + ')\\n';\r\n    prompt += lastEvaluation.evaluation_text.substring(0, 500);\r\n    if (lastEvaluation.evaluation_text.length > 500) prompt += '...';\r\n    prompt += '\\n\\nNote any changes from the above ‚Äî did flagged issues improve or persist?\\n\\n';\r\n  }\r\n\r\n  // --- Compute department benchmarks ---\r\n  var deptStats = {};\r\n  teamData.forEach(function(m) {\r\n    var dept = m.department || 'Unknown';\r\n    if (!deptStats[dept]) {\r\n      deptStats[dept] = { members: 0, totalAvgHours: 0, hoursCount: 0, totalCompleted: 0, totalDue: 0, taskCount: 0 };\r\n    }\r\n    deptStats[dept].members++;\r\n    if (m.weeklyHours && m.weeklyHours.avgDaily > 0) {\r\n      deptStats[dept].totalAvgHours += m.weeklyHours.avgDaily;\r\n      deptStats[dept].hoursCount++;\r\n    }\r\n    if (m.weeklyTaskStats) {\r\n      deptStats[dept].totalCompleted += (parseInt(m.weeklyTaskStats.total_completed) || 0);\r\n      deptStats[dept].totalDue += (parseInt(m.weeklyTaskStats.total_due) || 0);\r\n      deptStats[dept].taskCount++;\r\n    }\r\n  });\r\n  // Calculate averages\r\n  for (var dept in deptStats) {\r\n    var ds = deptStats[dept];\r\n    ds.avgHoursPerDay = ds.hoursCount > 0 ? Math.round(ds.totalAvgHours / ds.hoursCount * 10) / 10 : null;\r\n    ds.avgCompletionRate = ds.totalDue > 0 ? Math.round(ds.totalCompleted / ds.totalDue * 100) : null;\r\n  }\r\n\r\n  // Department benchmarks section\r\n  var deptKeys = Object.keys(deptStats).sort();\r\n  if (deptKeys.length > 1 || (deptKeys.length === 1 && deptKeys[0] !== 'Unknown')) {\r\n    prompt += '## Department Benchmarks (7-day averages)\\n';\r\n    deptKeys.forEach(function(dept) {\r\n      var ds = deptStats[dept];\r\n      prompt += '- **' + dept + '** (' + ds.members + ' people): ';\r\n      if (ds.avgHoursPerDay !== null) prompt += 'avg ' + ds.avgHoursPerDay + 'h/day';\r\n      if (ds.avgCompletionRate !== null) prompt += ', ' + ds.avgCompletionRate + '% task completion';\r\n      prompt += '\\n';\r\n    });\r\n    prompt += '\\n';\r\n  }\r\n\r\n  prompt += '## Team Data\\n\\n';\r\n\r\n  teamData.forEach(function(member) {\r\n    // Header with role context\r\n    prompt += '### ' + member.name + ' (' + member.email + ')';\r\n    if (member.department || member.position) {\r\n      prompt += ' | ' + (member.department || '') + (member.department && member.position ? ' - ' : '') + (member.position || '');\r\n    }\r\n    prompt += '\\n';\r\n\r\n    // Today's data\r\n    prompt += '**Today:** Check-in: ' + (member.checkedIn ? 'Yes' : 'NO') + (member.isLate ? ' (Late)' : '');\r\n    prompt += ' | EOD: ' + (member.eodSubmitted ? 'Yes' : 'NO');\r\n    prompt += ' | Hours: ' + (member.hoursReported !== null ? member.hoursReported + 'h' : 'NOT REPORTED');\r\n    prompt += ' (expected: ' + member.expectedHoursToday + 'h)\\n';\r\n\r\n    if (member.clickupEstimateHrs !== null) {\r\n      prompt += 'ClickUp Time Estimates Total: ' + member.clickupEstimateHrs + 'h\\n';\r\n    }\r\n\r\n    if (member.blockers) {\r\n      prompt += 'Blockers: \"' + member.blockers.substring(0, 200) + '\"\\n';\r\n    }\r\n\r\n    // Task stats\r\n    if (member.taskStats) {\r\n      prompt += 'Tasks: ' + member.taskStats.dueToday + ' due, ' + member.taskStats.completed + ' done, ' + member.taskStats.delayed + ' delayed, ' + member.taskStats.overdue + ' overdue';\r\n      if (member.taskStats.overdue > 0) {\r\n        prompt += ' (oldest: ' + member.taskStats.oldestOverdueDays + ' days)';\r\n      }\r\n      prompt += '\\n';\r\n    }\r\n\r\n    // Task details (capped at 5)\r\n    if (member.taskDetails && member.taskDetails.length > 0) {\r\n      prompt += 'Task List:\\n';\r\n      member.taskDetails.forEach(function(t) {\r\n        prompt += '  * \"' + t.name + '\" [' + t.status + ']';\r\n        if (t.isOverdue) prompt += ' (OVERDUE)';\r\n        if (t.timeEstimateHrs) prompt += ' (est: ' + t.timeEstimateHrs + 'h)';\r\n        if (t.description) prompt += ' ‚Äî ' + t.description;\r\n        prompt += '\\n';\r\n      });\r\n    }\r\n\r\n    if (member.eodReport) {\r\n      prompt += 'EOD Summary: \"' + member.eodReport.substring(0, 200) + '\"\\n';\r\n    }\r\n\r\n    // Follow-through check\r\n    if (member.yesterdayPriority) {\r\n      prompt += '\\n**Follow-Through:** Yesterday said they\\'d do: \"' + member.yesterdayPriority.substring(0, 200) + '\"\\n';\r\n    }\r\n\r\n    // Historical: 7-day attendance\r\n    prompt += '\\n**7-Day History:**\\n';\r\n    if (member.weeklyAttendance) {\r\n      var wa = member.weeklyAttendance;\r\n      prompt += '  Attendance: ' + (parseInt(wa.checkin_days) || 0) + '/5 check-ins, ' + (parseInt(wa.late_days) || 0) + ' late, ' + (parseInt(wa.eod_days) || 0) + ' EODs';\r\n      prompt += ' | On-time streak: ' + member.onTimeStreak + ' days\\n';\r\n    } else {\r\n      prompt += '  Attendance: No history available | Streak: ' + member.onTimeStreak + ' days\\n';\r\n    }\r\n\r\n    // Historical: 7-day hours + department comparison\r\n    if (member.weeklyHours) {\r\n      var wh = member.weeklyHours;\r\n      prompt += '  Hours: avg ' + wh.avgDaily + 'h/day (' + wh.daysReported + ' days reported), total: ' + Math.round(wh.totalHours * 10) / 10 + 'h';\r\n      var memberDept = member.department || 'Unknown';\r\n      if (deptStats[memberDept] && deptStats[memberDept].avgHoursPerDay !== null && deptStats[memberDept].members > 1) {\r\n        prompt += ' | Dept avg: ' + deptStats[memberDept].avgHoursPerDay + 'h/day';\r\n      }\r\n      prompt += '\\n';\r\n    } else {\r\n      prompt += '  Hours: No history available\\n';\r\n    }\r\n\r\n    // Historical: 7-day task throughput + department comparison\r\n    if (member.weeklyTaskStats) {\r\n      var wt = member.weeklyTaskStats;\r\n      var avgRate = parseFloat(wt.avg_completion_rate) || 0;\r\n      prompt += '  Tasks: ' + (parseInt(wt.total_completed) || 0) + '/' + (parseInt(wt.total_due) || 0) + ' completed (' + avgRate + '%), ' + (parseInt(wt.total_moved) || 0) + ' delayed';\r\n      var memberDeptT = member.department || 'Unknown';\r\n      if (deptStats[memberDeptT] && deptStats[memberDeptT].avgCompletionRate !== null && deptStats[memberDeptT].members > 1) {\r\n        prompt += ' | Dept avg: ' + deptStats[memberDeptT].avgCompletionRate + '%';\r\n      }\r\n      prompt += '\\n';\r\n    }\r\n\r\n    // 4-week hours trend (compact one-liner)\r\n    if (member.hoursTrend && member.hoursTrend.length > 0) {\r\n      prompt += '  4-Week Trend: ';\r\n      prompt += member.hoursTrend.map(function(w) {\r\n        return 'Wk' + w.week_num + ': ' + w.avg_daily_hours + 'h/day';\r\n      }).join(' | ');\r\n      prompt += '\\n';\r\n    }\r\n\r\n    // Chronic issues\r\n    if (member.repeatDelayedTasks && member.repeatDelayedTasks.length > 0) {\r\n      prompt += '  Chronic Delays: ';\r\n      prompt += member.repeatDelayedTasks.map(function(t) {\r\n        return '\"' + t.task_name + '\" delayed ' + t.times_delayed + 'x';\r\n      }).join(', ');\r\n      prompt += '\\n';\r\n    }\r\n\r\n    prompt += '\\n';\r\n  });\r\n\r\n  // Instructions\r\n  prompt += '## Instructions\\n\\n';\r\n  prompt += 'For each team member, provide:\\n';\r\n  prompt += '1. **Rating**: Excellent / Good / Needs Attention / Concern\\n';\r\n  prompt += '2. **Hours Analysis**: Compare reported hours to (a) their own 7-day average, (b) their department average, (c) expected hours. Flag significant deviations.\\n';\r\n  prompt += '3. **Follow-Through**: Did they work on what they said they would yesterday? Flag mismatches.\\n';\r\n  prompt += '4. **Productivity Check**: Today\\'s output vs their own 7-day average AND their department\\'s average completion rate. Is this an up or down day?\\n';\r\n  prompt += '5. **Trend Direction**: Based on 4-week data ‚Äî is this person trending up, down, or stable?\\n';\r\n  prompt += '6. **Peer Comparison**: How does this person compare to others in the same department? Are they an outlier (high or low)?\\n';\r\n  prompt += '7. **Risk Flags**: Specific concerns with evidence from the data.\\n';\r\n  prompt += '8. **Recommended Action**: What management should do (if anything).\\n\\n';\r\n\r\n  prompt += '## Patterns to Flag\\n';\r\n  prompt += '- Hours significantly below their own 7-day average (not just the team standard)\\n';\r\n  prompt += '- Declining hours trend over 4 weeks\\n';\r\n  prompt += '- Stated priority yesterday not reflected in today\\'s tasks (follow-through gap)\\n';\r\n  prompt += '- Task completion rate below their own average\\n';\r\n  prompt += '- On-time streak broken after 5+ days (momentum loss)\\n';\r\n  prompt += '- Repeat-delayed tasks ‚Äî same task pushed 3+ times = avoidance pattern\\n';\r\n  prompt += '- Blockers mentioned with no management escalation\\n';\r\n  prompt += '- Reported 8h but only 1-2 small tasks completed (compare to their typical throughput)\\n';\r\n  prompt += '- Missing check-in or EOD ‚Äî is this a one-off or pattern? Check 7-day attendance\\n';\r\n  prompt += '- Low hours + high output = possible underreporting (flag for praise, not concern)\\n';\r\n  prompt += '- Improvement from previous evaluation flags (acknowledge progress)\\n\\n';\r\n\r\n  prompt += '- Person consistently below their department average hours or completion rate\\n';\r\n  prompt += '- Person significantly above department average (recognize top performers)\\n\\n';\r\n  prompt += 'Be direct and specific. Name names. Reference the data ‚Äî cite numbers.\\n';\r\n  prompt += 'Compare each person to BOTH their own historical baseline AND their department peers.\\n';\r\n  prompt += 'Use markdown formatting. Keep response concise but thorough.';\r\n\r\n  return prompt;\r\n}\r\n\r\n/**\r\n * Build morning standup digest from check-in responses\r\n * Posted to team channel for peer visibility\r\n */\r\nfunction buildStandupDigest(checkIns, teamMembers) {\r\n  var today = Utilities.formatDate(new Date(), 'America/Chicago', 'EEEE, MMMM d');\r\n  var message = 'üìã *Team Standup - ' + today + '*\\n\\n';\r\n\r\n  var nameMap = {};\r\n  teamMembers.forEach(function(m) { nameMap[m.email] = m.name || m.email.split('@')[0]; });\r\n\r\n  if (checkIns.length === 0) {\r\n    message += 'No check-ins received yet.';\r\n    return message;\r\n  }\r\n\r\n  checkIns.forEach(function(ci) {\r\n    var name = nameMap[ci.user_email] || ci.user_email;\r\n    var response = ci.response_text || 'here';\r\n    if (response.toLowerCase().trim() === 'here' || response.toLowerCase().trim() === 'present') {\r\n      message += '*' + name + ':* ‚úÖ Online\\n';\r\n    } else {\r\n      message += '*' + name + ':* ' + response + '\\n';\r\n    }\r\n  });\r\n\r\n  var config = getConfig();\r\n  var checkedInEmails = {};\r\n  checkIns.forEach(function(c) { checkedInEmails[c.user_email] = true; });\r\n  // Exclude not-tracked users from \"missing\" list\r\n  var missing = teamMembers.filter(function(m) {\r\n    if (checkedInEmails[m.email]) return false;\r\n    var fullMember = config.team_members.find(function(tm) { return tm.email === m.email; });\r\n    if (fullMember && fullMember.tracking_mode === 'not_tracked') return false;\r\n    return true;\r\n  });\r\n  if (missing.length > 0) {\r\n    message += '\\n‚è≥ *Not yet checked in:* ' + missing.map(function(m) { return nameMap[m.email]; }).join(', ');\r\n  }\r\n\r\n  return message;\r\n}\r\n\r\n/**\r\n * Build EOD digest for team channel\r\n */\r\nfunction buildEodDigest(eods, teamMembers) {\r\n  var today = Utilities.formatDate(new Date(), 'America/Chicago', 'EEEE, MMMM d');\r\n  var message = 'üìù *Team EOD Summary - ' + today + '*\\n\\n';\r\n\r\n  var nameMap = {};\r\n  teamMembers.forEach(function(m) { nameMap[m.email] = m.name || m.email.split('@')[0]; });\r\n\r\n  if (eods.length === 0) {\r\n    message += 'No EOD reports received yet.';\r\n    return message;\r\n  }\r\n\r\n  eods.forEach(function(eod) {\r\n    var name = nameMap[eod.user_email] || eod.user_email;\r\n    var summary = eod.tasks_completed || eod.raw_response || '(no details)';\r\n    if (summary.length > 200) summary = summary.substring(0, 197) + '...';\r\n    message += '*' + name + ':* ' + summary + '\\n';\r\n    if (eod.blockers) message += '  ‚ö†Ô∏è Blocker: ' + eod.blockers + '\\n';\r\n    message += '\\n';\r\n  });\r\n\r\n  return message;\r\n}\r\n"
    },
    {
      "name": "Utils.gs",
      "type": "server_js",
      "source": "/**\r\n * Utils.gs - Utility Functions & Trigger Setup\r\n */\r\n\r\n/**\r\n * Create all scheduled triggers - run once after deployment\r\n * Uses daily triggers with day-of-week checks in the functions to stay under 20 trigger limit\r\n */\r\nfunction createScheduledTriggers() {\r\n  deleteAllTriggers();\r\n  console.log('Creating scheduled triggers...');\r\n\r\n  // 6:00 AM - Sage HR Sync (daily) - skips weekends in function\r\n  ScriptApp.newTrigger('triggerSageHRSync').timeBased().atHour(6).nearMinute(0).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 6:15 AM - ClickUp Sync (daily) - skips weekends in function\r\n  ScriptApp.newTrigger('triggerClickUpSync').timeBased().atHour(6).nearMinute(15).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 7:00 AM - Morning Check-ins for Friday\r\n  ScriptApp.newTrigger('triggerMorningCheckInsFriday').timeBased().atHour(7).nearMinute(0).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 8:00 AM - Morning Check-ins for Mon-Thu\r\n  ScriptApp.newTrigger('triggerMorningCheckIns').timeBased().atHour(8).nearMinute(0).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 7:20 AM - Check-in Follow-ups for Friday\r\n  ScriptApp.newTrigger('triggerCheckInFollowUpFriday').timeBased().atHour(7).nearMinute(20).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 8:20 AM - Check-in Follow-ups for Mon-Thu\r\n  ScriptApp.newTrigger('triggerCheckInFollowUp').timeBased().atHour(8).nearMinute(20).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 7:35 AM - Morning Summary for Friday\r\n  ScriptApp.newTrigger('triggerMorningSummaryFriday').timeBased().atHour(7).nearMinute(35).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 8:35 AM - Morning Summary for Mon-Thu\r\n  ScriptApp.newTrigger('triggerMorningSummary').timeBased().atHour(8).nearMinute(35).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 10:30 AM - EOD Requests for Friday\r\n  ScriptApp.newTrigger('triggerEodRequestsFriday').timeBased().atHour(10).nearMinute(30).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 4:30 PM - EOD Requests for Mon-Thu\r\n  ScriptApp.newTrigger('triggerEodRequests').timeBased().atHour(16).nearMinute(30).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 10:50 AM - EOD Follow-ups for Friday\r\n  ScriptApp.newTrigger('triggerEodFollowUpFriday').timeBased().atHour(10).nearMinute(50).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 4:50 PM - EOD Follow-ups for Mon-Thu\r\n  ScriptApp.newTrigger('triggerEodFollowUp').timeBased().atHour(16).nearMinute(50).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 11:00 AM - EOD Summary for Friday\r\n  ScriptApp.newTrigger('triggerEodSummaryFriday').timeBased().atHour(11).nearMinute(0).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 5:00 PM - EOD Summary for Mon-Thu\r\n  ScriptApp.newTrigger('triggerEodSummary').timeBased().atHour(17).nearMinute(0).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 5:15 PM - ClickUp Snapshot (daily)\r\n  ScriptApp.newTrigger('triggerClickUpSnapshot').timeBased().atHour(17).nearMinute(15).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 11:30 AM - AI Evaluation for Friday\r\n  ScriptApp.newTrigger('triggerAiEvaluationFriday').timeBased().atHour(11).nearMinute(30).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 5:30 PM - AI Evaluation for Mon-Thu\r\n  ScriptApp.newTrigger('triggerAiEvaluation').timeBased().atHour(17).nearMinute(30).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 10:15 AM - Weekly Gamification (Friday only, checked in function)\r\n  ScriptApp.newTrigger('triggerWeeklyGamification').timeBased().atHour(10).nearMinute(15).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // V2 TRIGGERS\r\n\r\n  // 5:20 PM - Daily Adoption Metrics (Mon-Thu, checked in function)\r\n  ScriptApp.newTrigger('triggerDailyAdoptionMetrics').timeBased().atHour(17).nearMinute(20).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 10:00 AM Wednesday - Midweek Compliance Check (checked in function)\r\n  ScriptApp.newTrigger('triggerMidweekCompliance').timeBased().atHour(10).nearMinute(0).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 10:30 AM Friday - Weekly Adoption Report (checked in function)\r\n  ScriptApp.newTrigger('triggerWeeklyAdoptionReport').timeBased().atHour(10).nearMinute(30).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // 11:20 AM Friday - Daily Adoption Metrics for Friday (checked in function)\r\n  ScriptApp.newTrigger('triggerDailyAdoptionMetricsFriday').timeBased().atHour(11).nearMinute(20).everyDays(1).inTimezone('America/Chicago').create();\r\n\r\n  // Every 30 minutes - Schedule Dispatcher for custom/split-shift users\r\n  ScriptApp.newTrigger('triggerScheduleDispatcher').timeBased().everyMinutes(30).inTimezone('America/Chicago').create();\r\n\r\n  const count = ScriptApp.getProjectTriggers().length;\r\n  console.log(`All triggers created! Total: ${count}`);\r\n}\r\n\r\nfunction deleteAllTriggers() {\r\n  const triggers = ScriptApp.getProjectTriggers();\r\n  triggers.forEach(t => ScriptApp.deleteTrigger(t));\r\n  console.log(`Deleted ${triggers.length} triggers`);\r\n}\r\n\r\nfunction listAllTriggers() {\r\n  const triggers = ScriptApp.getProjectTriggers();\r\n  triggers.forEach(t => console.log(`${t.getHandlerFunction()}`));\r\n  return triggers.length;\r\n}\r\n\r\n// Connection Tests\r\nfunction testClickUpConnection() {\r\n  const structure = getWorkspaceStructure();\r\n  if (structure) {\r\n    console.log(`‚úÖ ClickUp: ${structure.lists.length} lists, ${Object.keys(structure.members).length} members`);\r\n    return true;\r\n  }\r\n  console.log('‚ùå ClickUp failed'); return false;\r\n}\r\n\r\nfunction testSageHRConnection() {\r\n  const employees = getSageHREmployees();\r\n  if (employees && employees.length > 0) {\r\n    console.log(`‚úÖ Sage HR: ${employees.length} employees`);\r\n    return true;\r\n  }\r\n  console.log('‚ùå Sage HR failed'); return false;\r\n}\r\n\r\nfunction testOpenAIConnection() {\r\n  const result = callOpenAI('Say \"test ok\"');\r\n  if (result) { console.log('‚úÖ OpenAI connected'); return true; }\r\n  console.log('‚ùå OpenAI failed'); return false;\r\n}\r\n\r\nfunction testBigQueryConnection() {\r\n  try {\r\n    runBigQueryQuery('SELECT 1');\r\n    console.log('‚úÖ BigQuery connected'); return true;\r\n  } catch (e) {\r\n    console.log('‚ùå BigQuery failed'); return false;\r\n  }\r\n}\r\n\r\nfunction runAllTests() {\r\n  console.log('=== Connection Tests ===');\r\n  return {\r\n    clickup: testClickUpConnection(),\r\n    sageHR: testSageHRConnection(),\r\n    openai: testOpenAIConnection(),\r\n    bigquery: testBigQueryConnection()\r\n  };\r\n}\r\n\r\n/**\r\n * Get access token using service account credentials\r\n * @param {string} scope The OAuth scope to request\r\n * @return {string} Access token or null\r\n */\r\nfunction getServiceAccountToken(scope) {\r\n  const targetScope = scope || 'https://www.googleapis.com/auth/chat.bot';\r\n  const cacheKey = 'sa_token_' + Utilities.base64EncodeWebSafe(targetScope);\r\n\r\n  const cache = CacheService.getScriptCache();\r\n  const cached = cache.get(cacheKey);\r\n  if (cached) return cached;\r\n\r\n  try {\r\n    const props = PropertiesService.getScriptProperties();\r\n    const saKeyJson = props.getProperty('SERVICE_ACCOUNT_KEY');\r\n\r\n    if (!saKeyJson) {\r\n      console.error('SERVICE_ACCOUNT_KEY not found in Script Properties');\r\n      return null;\r\n    }\r\n\r\n    const saKey = JSON.parse(saKeyJson);\r\n\r\n    // Create JWT\r\n    const header = { alg: 'RS256', typ: 'JWT' };\r\n    const now = Math.floor(Date.now() / 1000);\r\n    const claimSet = {\r\n      iss: saKey.client_email,\r\n      scope: targetScope,\r\n      aud: 'https://oauth2.googleapis.com/token',\r\n      iat: now,\r\n      exp: now + 3600\r\n    };\r\n\r\n    const signatureInput = Utilities.base64EncodeWebSafe(JSON.stringify(header)) + '.' +\r\n      Utilities.base64EncodeWebSafe(JSON.stringify(claimSet));\r\n    const signature = Utilities.computeRsaSha256Signature(signatureInput, saKey.private_key);\r\n    const jwt = signatureInput + '.' + Utilities.base64EncodeWebSafe(signature);\r\n\r\n    // Exchange for token\r\n    const response = UrlFetchApp.fetch('https://oauth2.googleapis.com/token', {\r\n      method: 'post',\r\n      payload: {\r\n        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\r\n        assertion: jwt\r\n      },\r\n      muteHttpExceptions: true\r\n    });\r\n\r\n    if (response.getResponseCode() !== 200) {\r\n      console.error('Token exchange failed:', response.getContentText());\r\n      return null;\r\n    }\r\n\r\n    const tokenData = JSON.parse(response.getContentText());\r\n    // Cache for 50 minutes (3000 seconds)\r\n    cache.put(cacheKey, tokenData.access_token, 3000);\r\n\r\n    return tokenData.access_token;\r\n  } catch (error) {\r\n    console.error('Error getting SA token:', error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n// Manual test functions\r\nfunction testSendCheckIn() {\r\n  const config = getConfig();\r\n  const email = config.settings.manager_email;\r\n  const tasks = getTasksForUser(email, 'today');\r\n  const msg = getMorningCheckInMessage({ email, name: 'Test' }, tasks, false);\r\n  sendDirectMessage(email, msg);\r\n  logPromptSent(email, 'CHECKIN');\r\n  setUserState(email, 'AWAITING_CHECKIN');\r\n  console.log(`Check-in sent to ${email}`);\r\n}\r\n\r\nfunction testSendEodRequest() {\r\n  const config = getConfig();\r\n  const email = config.settings.manager_email;\r\n  const tasks = getTasksForUser(email, 'today');\r\n  const eod = getEodRequestMessage({ email }, tasks);\r\n  const result = sendDirectMessage(email, eod.text, eod.cardsV2);\r\n  logPromptSent(email, 'EOD');\r\n  setUserState(email, 'AWAITING_EOD');\r\n  console.log(`EOD sent to ${email}`, result);\r\n}\r\n\r\n/**\r\n * Test service account configuration\r\n */\r\nfunction testServiceAccount() {\r\n  console.log('=== Service Account Test ===');\r\n\r\n  // Check if configured\r\n  if (!isServiceAccountConfigured()) {\r\n    console.log('‚ùå Service account NOT configured');\r\n    console.log('To configure: Add SERVICE_ACCOUNT_KEY to Script Properties');\r\n    console.log('The value should be the entire JSON key file contents');\r\n    return false;\r\n  }\r\n\r\n  console.log('‚úÖ Service account key found in Script Properties');\r\n\r\n  // Try to get a token\r\n  const token = getServiceAccountToken();\r\n  if (token) {\r\n    console.log('‚úÖ Successfully obtained service account token');\r\n    console.log('Token preview:', token.substring(0, 20) + '...');\r\n    return true;\r\n  } else {\r\n    console.log('‚ùå Failed to obtain service account token');\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Test sending a message with cards using service account\r\n */\r\nfunction testSendCardMessage() {\r\n  console.log('=== Test Card Message ===');\r\n\r\n  const config = getConfig();\r\n  const email = config.settings.manager_email;\r\n\r\n  // Get DM space\r\n  const spaceName = getDMSpace(email);\r\n  if (!spaceName) {\r\n    console.log(`‚ùå No DM space found for ${email}`);\r\n    console.log('The user must first message the bot to establish a DM space');\r\n    return false;\r\n  }\r\n\r\n  console.log(`Found DM space: ${spaceName}`);\r\n\r\n  // Create a simple test card\r\n  const testCards = [{\r\n    cardId: 'test_card',\r\n    card: {\r\n      header: {\r\n        title: 'üß™ Test Card',\r\n        subtitle: 'Service Account Test'\r\n      },\r\n      sections: [{\r\n        widgets: [{\r\n          decoratedText: {\r\n            text: 'If you see this card, service account is working!',\r\n            startIcon: { knownIcon: 'STAR' }\r\n          }\r\n        }]\r\n      }]\r\n    }\r\n  }];\r\n\r\n  const result = sendMessageToSpace(spaceName, 'Testing card delivery with service account:', testCards);\r\n\r\n  if (result.sent) {\r\n    console.log('‚úÖ Message sent successfully!');\r\n    console.log('Has cards:', result.hasCards);\r\n    return true;\r\n  } else {\r\n    console.log('‚ùå Failed to send message:', result.error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Setup helper: Store service account key\r\n * Run this function after pasting your service account JSON key\r\n */\r\nfunction setupServiceAccountKey() {\r\n  // INSTRUCTIONS:\r\n  // 1. Create a service account in GCP Console\r\n  // 2. Download the JSON key file\r\n  // 3. Copy the ENTIRE contents of the JSON file\r\n  // 4. Replace the placeholder below with the JSON contents\r\n  // 5. Run this function ONCE to store the key\r\n  // 6. Delete the key from this code after running!\r\n\r\n  const serviceAccountKey = {\r\n    // PASTE YOUR SERVICE ACCOUNT JSON KEY HERE\r\n    // Example structure (DO NOT USE THIS - use your actual key):\r\n    // \"type\": \"service_account\",\r\n    // \"project_id\": \"your-project-id\",\r\n    // \"private_key_id\": \"...\",\r\n    // \"private_key\": \"-----BEGIN PRIVATE KEY-----\\n...\\n-----END PRIVATE KEY-----\\n\",\r\n    // \"client_email\": \"checkin-bot-service@your-project.iam.gserviceaccount.com\",\r\n    // \"client_id\": \"...\",\r\n    // ...\r\n  };\r\n\r\n  if (!serviceAccountKey.type || !serviceAccountKey.private_key) {\r\n    console.log('‚ùå Please paste your service account JSON key in the setupServiceAccountKey function');\r\n    console.log('The key should have \"type\" and \"private_key\" fields');\r\n    return;\r\n  }\r\n\r\n  PropertiesService.getScriptProperties().setProperty(\r\n    'SERVICE_ACCOUNT_KEY',\r\n    JSON.stringify(serviceAccountKey)\r\n  );\r\n\r\n  console.log('‚úÖ Service account key stored successfully!');\r\n  console.log('‚ö†Ô∏è IMPORTANT: Now delete the key from this code for security!');\r\n}\r\n\r\n/**\r\n * Helper to build a common Google Chat response for Add-on style events\r\n * @param {any} responseData The message text (string) or a message object (e.g. with cards)\r\n * @return {object} Structured JSON response\r\n */\r\nfunction createChatResponse(responseData) {\r\n  var message = typeof responseData === 'string' ? { text: responseData } : responseData;\r\n  return {\r\n    hostAppDataAction: {\r\n      chatDataAction: {\r\n        createMessageAction: {\r\n          message: message\r\n        }\r\n      }\r\n    }\r\n  };\r\n}"
    },
    {
      "name": "appsscript",
      "type": "json",
      "source": "{\r\n  \"timeZone\": \"America/Chicago\",\r\n  \"exceptionLogging\": \"STACKDRIVER\",\r\n  \"runtimeVersion\": \"V8\",\r\n  \"dependencies\": {\r\n    \"enabledAdvancedServices\": [\r\n      {\r\n        \"userSymbol\": \"BigQuery\",\r\n        \"version\": \"v2\",\r\n        \"serviceId\": \"bigquery\"\r\n      }\r\n    ]\r\n  },\r\n  \"oauthScopes\": [\r\n    \"https://www.googleapis.com/auth/spreadsheets\",\r\n    \"https://www.googleapis.com/auth/drive\",\r\n    \"https://www.googleapis.com/auth/script.external_request\",\r\n    \"https://www.googleapis.com/auth/bigquery\",\r\n    \"https://www.googleapis.com/auth/chat.messages.create\",\r\n    \"https://www.googleapis.com/auth/chat.spaces.readonly\",\r\n    \"https://www.googleapis.com/auth/script.scriptapp\"\r\n  ],\r\n  \"addOns\": {\r\n    \"chat\": {},\r\n    \"common\": {\r\n      \"name\": \"Check-in Bot\",\r\n      \"logoUrl\": \"https://www.gstatic.com/images/branding/product/2x/chat_2020q4_48dp.png\",\r\n      \"layoutProperties\": {\r\n        \"primaryColor\": \"#2772ed\"\r\n      }\r\n    }\r\n  }\r\n}"
    }
  ]
}